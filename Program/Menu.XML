<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Menu</name>
    </assembly>
    <members>
        <member name="F:ORTS.OptionsForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.OptionsForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.OptionsForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MSTS.CONFile">
            <summary>
            Work with consist files
            </summary>
        </member>
        <member name="T:MSTS.ACTFile">
            <summary>
            Summary description for Class1.
            </summary>
        </member>
        <member name="M:MSTS.EventCategoryLocation.#ctor(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Create a new 'ActivitySuccess' LocationEvent
            </summary>
        </member>
        <member name="M:MSTS.EventCategoryAction.#ctor(System.Int32)">
            <summary>
            Build a default EventTypeAllStops event
            </summary>
        </member>
        <member name="F:ORTS.ExploreForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.ExploreForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.ExploreForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:ORTS.DetailsForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.DetailsForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.DetailsForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:ORTS.MainForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.MainForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.MainForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MSTS.STFReader">
            <summary>Used for reading data from Structured Text Format (MSTS1 style) files.
            </summary><remarks><para>
            An STF file is whitespace delimitered file, taking the format - {item}{whitespace}[repeated].</para><para>
             </para><para>
            At it's most simple an STF file has the format - {token_item}{whitespace}{data_item}{whitespace}(repeated)</para><para>
            Even, more simplisitically every {data_item} can be a {constant_item}</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name SimpleSTFfile</para><para>
                weight 100</para><para>
                speed 50.25</para>
            </code> <para>
            STF also has a block methodology where a {data_item} following a {token_item} can start with '(' followed by any number of {data_item}s and closed with a ')'.
            The contents of the block are defined in the specific file schema, and not in the STF definition.
            The STF defintion allows that inside a pair of parentheses may be a single {constant_item}, multiple whitespace delimitered {constant_item}s, or a nested {token_item}{data_item} pair (which could contain a further nested block recursively).</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name BlockedSTFfile</para><para>
                root_constant 100</para><para>
                root_block_1</para><para>
                (</para><para>
                      nested_block_1_1</para><para>
                      (</para><para>
                            1</para><para>
                      )</para><para>
                      nested_block_1_2 ( 5 )</para><para>
                )</para><para>
                root_block_2</para><para>
                (</para><para>
                      1 2 3</para><para>
                )</para><para>
                root_block_3 ( a b c )</para>
            </code> <para>
            Numeric {constan_item}s can include a 'unit' suffix, which is handled in the ReadDouble() function.</para><para>
            Within ReadDouble these units are then converted to the standards used throughout OR - meters, newtons, kilograms.</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name STFfileWithUnits</para><para>
                weight 100kg</para><para>
                speed 50mph</para>
            </code> <para>
            Whitespaces can be included within any {item} using a double quotation notation.
            Quoted values also support a trailing addition operator to indicate an append operation of multiple quoted strings.</para><para>
            Although append operations are technically allowed for {token_item}'s this practice is *strongly* discouraged for readability.</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                simple_token "Data Item with" + " whitespace"</para><para>
                block_token ( "Data " + "Item 1" "Data Item 2" )</para><para>
                "discouraged_" + "token" -1</para><para>
                Error Example:</para><para>
                error1 "You cannot use append suffix to non quoted " + items</para>
            </code> <para>
            The STF format also supports 3 special {token_item}s - include, comment &amp; skip.</para><list class="bullet">
            <listItem><para>include - must be at the root level (that is to say it cannot be included within a block).
            After an include directive the {constant_item} is a filename relative to the current processing STF file.
            The include token has the effect of in-lining the defined file into the current document.</para></listItem>
            <listItem><para>comment &amp; skip - must be followed by a block which will not be processed in OR</para></listItem>
            </list> <para>
            Finally any token which begins with a '#' character will be ignored, and then the next {data_item} (constant or block) will not be processed.</para><para>
             </para>
            <alert class="important"><para>NB!!! If a comment/skip/#*/_* is the last {item} in a block, rather than being totally consumed a dummy "#\u00b6" is returned, so if EndOFBlock() returns false, you always get an {item} (which can then just be ignored).</para></alert>
            </remarks>
            <example><code lang="C#" title="STF parsing using Parse...() and delegate/lambda functions in C#">
                using (STFReader stf = new STFReader(filename, false))
                    stf.ParseFile(new STFReader.TokenProcessor[] {
                        new STFReader.TokenProcessor("item_single_constant", ()=&gt;{ float isc = stf.ReadFloat(STFReader.UNITS.None, 0); }),
                        new STFReader.TokenProcessor("item_single_speed", ()=&gt;{ float iss_mps = stf.ReadFloat(STFReader.UNITS.Speed, 0); }),
                        new STFReader.TokenProcessor("block_single_constant", ()=&gt;{ float bsc = stf.ReadFloatBlock(STFReader.UNITS.None, 0); }),
                        new STFReader.TokenProcessor("block_fixed_format", ()=&gt;{
                            stf.MustMatch("(");
                            int bff1 = stf.ReadInt(STFReader.UNITS.None, 0);
                            string bff2 = stf.ReadString();
                            stf.SkipRestOfBlock();
                        }),
                        new STFReader.TokenProcessor("block_variable_contents", ()=&gt;{ stf.MustMatch("("); stf.ParseBlock(new STFReader.TokenProcessor[] {
                            new STFReader.TokenProcessor("subitem", ()=&gt;{ string si = stf.ReadString(); }),
                            new STFReader.TokenProcessor("subblock", ()=&gt;{ string sb = stf.ReadStringBlock(""); }),
                        });}),
                    });
            </code></example>
            <example><code lang="C#" title="Alternate functional method to parse STF using C#">
                   using (STFReader stf = new STFReader(filename, false))
                       while (!stf.EOF)
                           switch (stf.ReadItem().ToLower())
                           {
                               case "item_single_constant": float isc = stf.ReadFloat(STFReader.UNITS.None, 0); break;
                               case "item_single_speed": float iss_mps = stf.ReadFloat(STFReader.UNITS.Speed, 0); break;
                               case "block_single_constant": float bsc = stf.ReadFloatBlock(STFReader.UNITS.None, 0); break;
                               case "block_fixed_format":
                                   stf.MustMatch("(");
                                   int bff1 = stf.ReadInt(STFReader.UNITS.None, 0);
                                   string bff2 = stf.ReadString();
                                   stf.SkipRestOfBlock();
                                   break;
                               case "block_variable_contents":
                                   stf.MustMatch("(");
                                   while (!stf.EndOfBlock())
                                       switch (stf.ReadItem().ToLower())
                                       {
                                           case "subitem": string si = stf.ReadString(); break;
                                           case "subblock": string sb = stf.ReadStringBlock(""); break;
                                           case "(": stf.SkipRestOfBlock();
                                       }
                                   break;
                               case "(": stf.SkipRestOfBlock(); break;
                           }
            </code></example>
            <exception cref="T:MSTS.STFException"><para>
            STF reports errors using the  exception static members</para><para>
            There are three broad categories of error</para><list class="bullet">
            <listItem><para>Failure - Something which prevents loading from continuing, this throws an unhandled exception and drops out of Open Rails.</para></listItem>
            <listItem><para>Error - The data read does not have logical meaning - STFReader does not generate these errors, this is only appropriate STFReader consumers who understand the context of the data being processed</para></listItem>
            <listItem><para>Warning - When an error which can be programatically recovered from should be reported back to the user</para></listItem>
            </list>
            </exception>
        </member>
        <member name="M:MSTS.STFReader.#ctor(System.String,System.Boolean)">
            <summary>Open a file, reader the header line, and prepare for STF parsing
            </summary>
            <param name="filename">Filename of the STF file to be opened and parsed.</param>
            <param name="useTree"><para>true - if the consumer is going to use the Tree Property as it's parsing method (MSTS wagons &amp; engines)</para>
            <para>false - if Tree is not used which signicantly reduces GC</para></param>
        </member>
        <member name="M:MSTS.STFReader.#ctor(System.IO.Stream,System.String,System.Text.Encoding,System.Boolean)">
            <summary>Use an open stream for STF parsing, this constructor assumes that the SIMIS signature has already been gathered (or there isn't one)
            </summary>
            <param name="inputStream">Stream that will be parsed.</param>
            <param name="fileName">Is only used for error reporting.</param>
            <param name="encoding">One of the Encoding formats, defined as static members in Encoding which return an Encoding type.  Eg. Encoding.ASCII or Encoding.Unicode</param>
            <param name="useTree"><para>true - if the consumer is going to use the Tree Property as it's parsing method (MSTS wagons &amp; engines)</para>
            <para>false - if Tree is not used which signicantly reduces GC</para></param>
        </member>
        <member name="M:MSTS.STFReader.Dispose">
            <summary>Implements the IDisposable interface so this class can be implemented with the 'using(STFReader r = new STFReader(...)) {...}' C# statement.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.Dispose(System.Boolean)">
            <summary>Releases the resources used by the STFReader.
            </summary>
            <param name="disposing">
            <para>true - release managed and unmanaged resources.</para>
            <para>false - release only unmanaged resources.</para>
            </param>
        </member>
        <member name="M:MSTS.STFReader.ReadItem">
            <summary>Returns the next whitespace delimited {item} from the STF file skipping comments, etc.
            </summary>
            <remarks>
            <alert class="important">If a comment/skip/#*/_* ignore block is the last {item} in a block, rather than being totally consumed a dummy '#' is returned, so if EndOFBlock() returns false, you always get an {item} (which can then just be ignored).</alert>
            </remarks>
            <returns>The next {item} from the STF file, any surrounding quotations will be not be returned.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadItem(System.Boolean)">
            <summary>This is an internal function in STFReader, it returns the next whitespace delimited {item} from the STF file.
            </summary>
            <remarks>
            <alert class="important">If a comment/skip/#*/_* ignore block is the last {item} in a block, rather than being totally consumed a dummy '#' is returned, so if EndOFBlock() returns false, you always get an {item} (which can then just be ignored).</alert>
            </remarks>
            <param name="string_mode">When true normal comment processing is disabled.</param>
            <returns>The next {item} from the STF file, any surrounding quotations will be not be returned.</returns>
        </member>
        <member name="M:MSTS.STFReader.StepBackOneItem">
            <summary>Calling this function causes ReadItem() to repeat the last {item} that was read from the STF file
            </summary>
            <remarks>
            <para>The current implementation of StepBackOneItem() only allows for one "step back".</para>
            <para>This means that there each call to StepBackOneItem() must have an intervening call to ReadItem().</para>
            </remarks>
        </member>
        <member name="M:MSTS.STFReader.MustMatch(System.String)">
            <summary>Reports a critical error if the next {item} does not match the target.
            </summary>
            <param name="target">The next {item} contents we are expecting in the STF file.</param>
            <returns>The {item} read from the STF file</returns>
        </member>
        <member name="M:MSTS.STFReader.EndOfBlock">
            <summary>Returns true if the next character is the end of block, or end of file. Consuming the closing ")" all other values are not consumed.
            </summary>
            <remarks>
            <para>An STF block should be enclosed in parenthesis, ie ( {data_item} {data_item} )</para>
            </remarks>
            <returns>
            <para>true - An EOF, or closing parenthesis was found and consumed.</para>
            <para>false - Another type of {item} was found but not consumed.</para>
            </returns>
        </member>
        <member name="M:MSTS.STFReader.SkipBlock">
            <summary>Read a block open (, and then consume the rest of the block without processing.
            If we find an immediate close ), then produce a warning, and return without consuming the parenthesis.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.SkipRestOfBlock">
            <summary>Skip to the end of this block, ignoring any nested blocks
            </summary>
        </member>
        <member name="M:MSTS.STFReader.ReadString">
            <summary>Return next whitespace delimited string from the STF file.
            </summary>
            <remarks>
            <alert class="important">This differs from ReadInt in that normal comment processing is disabled.  ie an item that starts with _ is returned and not skipped.</alert>
            </remarks>
            <returns>The next {string_item} from the STF file, any surrounding quotations will be not be returned.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadHex(System.Nullable{System.UInt32})">
            <summary>Read an hexidecimal encoded number {constant_item}
            </summary>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadInt(MSTS.STFReader.UNITS,System.Nullable{System.Int32})">
            <summary>Read an signed integer {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadUInt(MSTS.STFReader.UNITS,System.Nullable{System.UInt32})">
            <summary>Read an unsigned integer {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadFloat(MSTS.STFReader.UNITS,System.Nullable{System.Single})">
            <summary>Read an single precision floating point number {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadDouble(MSTS.STFReader.UNITS,System.Nullable{System.Double})">
            <summary>Read an double precision floating point number {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ParseUnitSuffix(System.String@,MSTS.STFReader.UNITS)">
            <summary>This function removes known unit suffixes, and returns a scaler to bring the constant into the standard OR units.
            </summary>
            <remarks>This function is marked internal so it can be used to support arithmetic processing once the elements are seperated (eg. 5*2m)
            </remarks>
            <param name="constant">string with suffix (ie "23 mph"), after the function call the suffix is removed.</param>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <returns>The scaler that should be used to modify the constant to standard OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadStringBlock(System.String)">
            <summary>Read an string constant from the STF format '( {string_constant} ... )'
            </summary>
            <param name="default_val">the default value if the item is not found in the block.</param>
            <returns>The first item inside the STF block.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadHexBlock(System.Nullable{System.UInt32})">
            <summary>Read an hexidecimal encoded number from the STF format '( {int_constant} ... )'
            </summary>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a integer constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadIntBlock(MSTS.STFReader.UNITS,System.Nullable{System.Int32})">
            <summary>Read an integer constant from the STF format '( {int_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a integer constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadUIntBlock(MSTS.STFReader.UNITS,System.Nullable{System.UInt32})">
            <summary>Read an unsigned integer constant from the STF format '( {uint_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a unsigned integer constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadFloatBlock(MSTS.STFReader.UNITS,System.Nullable{System.Single})">
            <summary>Read an single precision constant from the STF format '( {float_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a single precision constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadDoubleBlock(MSTS.STFReader.UNITS,System.Nullable{System.Double})">
            <summary>Read an double precision constant from the STF format '( {double_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a double precision constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadBoolBlock(System.Boolean)">
            <summary>Reads the first item from a block in the STF format '( {double_constant} ... )' and return true if is not-zero or 'true'
            </summary>
            <param name="default_val">the default value if a item is not found in the block.</param>
            <returns><para>true - If the first {item} in the block is non-zero or 'true'.</para>
            <para>false - If the first {item} in the block is zero or 'false'.</para></returns>
        </member>
        <member name="M:MSTS.STFReader.ReadVector3Block(MSTS.STFReader.UNITS,Microsoft.Xna.Framework.Vector3)">
            <summary>Read a Vector3 object in the STF format '( {X} {Y} {Z} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">The default vector if any of the values are not specified</param>
            <returns>The STF block as a Vector3</returns>
        </member>
        <member name="M:MSTS.STFReader.ParseFile(MSTS.STFReader.TokenProcessor[])">
            <summary>Parse an STF file until the EOF, using the array of lower case tokens, with a processor delegate/lambda
            </summary>
            <param name="processors">Array of lower case token, and the delegate/lambda to call when matched.</param>
        </member>
        <member name="M:MSTS.STFReader.ParseFile(MSTS.STFReader.ParsingBreak,MSTS.STFReader.TokenProcessor[])">
            <summary>Parse an STF file until the EOF, using the array of lower case tokens, with a processor delegate/lambda
            </summary>
            <param name="breakout">A delegate that returns true, if the processing should be halted prematurely</param>
            <param name="processors">Array of lower case token, and the delegate/lambda to call when matched.</param>
        </member>
        <member name="M:MSTS.STFReader.ParseBlock(MSTS.STFReader.TokenProcessor[])">
            <summary>Parse an STF file until the end of block ')' marker, using the array of lower case tokens, with a processor delegate/lambda
            </summary>
            <param name="processors">Array of lower case token, and the delegate/lambda to call when matched.</param>
        </member>
        <member name="M:MSTS.STFReader.ParseBlock(MSTS.STFReader.ParsingBreak,MSTS.STFReader.TokenProcessor[])">
            <summary>Parse an STF file until the end of block ')' marker, using the array of lower case tokens, with a processor delegate/lambda
            </summary>
            <param name="breakout">A delegate that returns true, if the processing should be halted prematurely</param>
            <param name="processors">Array of lower case token, and the delegate/lambda to call when matched.</param>
        </member>
        <member name="F:MSTS.STFReader.streamSTF">
            <summary>The I/O stream for the STF file we are processing
            </summary>
        </member>
        <member name="F:MSTS.STFReader.includeReader">
            <summary>includeReader is used recursively in ReadItem() to handle the 'include' token, file include mechanism
            </summary>
        </member>
        <member name="F:MSTS.STFReader.previousItem">
            <summary>Remembers the last returned ReadItem().  If the next {item] is a '(', this is the block name used in the tree.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.block_depth">
            <summary>How deep in nested blocks the current parser is
            </summary>
        </member>
        <member name="F:MSTS.STFReader.tree">
            <summary>A list describing the hierachy of nested block tokens
            </summary>
        </member>
        <member name="F:MSTS.STFReader.tree_cache">
            <summary>The tree cache is used to minimize the calls to StringBuilder when Tree is called repetively for the same hierachy.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.stepbackoneitemFlag">
            <summary>This flag is set in StepBackOneItem(), and causes ReadItem(), to use the stepback* variables to do an item repeat
            </summary>
        </member>
        <member name="F:MSTS.STFReader.itemBuilder">
            <summary>This is really a local variable in the function ReadItem(...) but it is a class member to stop unnecessary memory re-allocations.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.ReadItem(System.Boolean,System.Boolean)">
            <summary>Internal Implementation - This is the main function that reads an item from the STF stream.
            </summary>
            <param name="skip_mode">True - we are in a skip function, and so we don't want to do any special token processing.</param>
            <param name="string_mode">True - we are expecting a string, so don't skip comments.</param>
            <returns>The next item from the STF file</returns>
        </member>
        <member name="M:MSTS.STFReader.UpdateTreeAndStepBack(System.String)">
            <summary>Internal Implementation
            <para>This function is called by ReadItem() for every item read from the STF file (and Included files).</para>
            <para>If a block instuction is found, then tree list is updated.</para>
            <para>As this function is called once per ReadItem() is stores the previous value in stepback* variables (there is additional optimization that we only copy stepbackTree if the tree has changed.</para>
            <para>Now when the stepbackoneitemFlag flag is set, we use the stepback* copies, to move back exactly one item.</para>
            </summary>
            <param name="token"></param>
        </member>
        <member name="P:MSTS.STFReader.EOF">
            <summary>Property that returns true when the EOF has been reached
            </summary>
        </member>
        <member name="P:MSTS.STFReader.FileName">
            <summary>Filename property for the file being parsed - for reporting purposes
            </summary>
        </member>
        <member name="P:MSTS.STFReader.LineNumber">
            <summary>Line Number property for the file being parsed - for reporting purposes
            </summary>
        </member>
        <member name="P:MSTS.STFReader.SIMISsignature">
            <summary>SIMIS header read from the first line of the file being parsed
            </summary>
        </member>
        <member name="P:MSTS.STFReader.Tree">
            <summary>Property returning the last {item} read using ReadItem() prefixed with string describing the nested block hierachy.
            <para>The string returned is formatted 'rootnode(nestednode(childnode(previous_item'.</para>
            </summary>
            <remarks>
            Tree is expensive method of reading STF files (especially for the GC) and should be avoided if possible.
            </remarks>
        </member>
        <member name="T:MSTS.STFReader.UNITS">
            <summary>Enumeration limiting which units are valid when parsing a numeric constant.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.None">
            <summary>No unit parsing is done on the {constant_item} - which is obviously fastest
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Compulsary">
            <summary>Combined using an | with other UNITS if the unit is compulsary (compulsary units will slow parsing)
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Distance">
            <summary>Valid Units: m, cm, mm, km, ft, ', in, "
            <para>Scaled to meters.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Speed">
            <summary>Valid Units: m/s, mph, kph, kmh, km/h
            <para>Scaled to meters/second.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Mass">
            <summary>Valid Units: kg, t, lb
            <para>Scaled to kilograms.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Force">
            <summary>Valid Units: n, kn, lbf
            <para>Scaled to newtons.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Power">
            <summary>Valid Units: w, kw, hp
            <para>Scaled to watts.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Stiffness">
            <summary>Valid Units: n/m
            <para>Scaled to newtons/metre.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Resistance">
            <summary>Valid Units: n/m/s (+ '/m/s' in case the newtons is missed) 
            <para>Scaled to newtons/speed(m/s)</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.MassRate">
            <summary>Valid Units: lb/h
            <para>Scaled to pounds per hour.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Volume">
            <summary>Valid Units: *(ft^3)
            <para>Scaled to cubic feet.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Pressure">
            <summary>Valid Units: psi
            <para>Scaled to pounds per square inch.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Area">
            <summary>Valid Units: *(ft^2)
            <para>Scaled to square meters.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.EnergyDensity">
            <summary>Valid Units: kj/kg, j/g, btu/lb
            <para>Scaled to kj/kg.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Any">
            <summary>This is only provided for backwards compatibility - all new users should limit the units to appropriate types
            </summary>
        </member>
        <member name="T:MSTS.STFReader.Processor">
            <summary>This delegate definition is used by the ParseFile and ParseBlock methods, and is called when an associated matching token is found.
            </summary>
        </member>
        <member name="T:MSTS.STFReader.ParsingBreak">
            <summary>This delegate definition is used by the ParseFile and ParseBlock methods, and is used to break out of the processing loop prematurely.
            </summary>
            <returns>true - if the parsing should be aborted prematurely</returns>
        </member>
        <member name="T:MSTS.STFReader.TokenProcessor">
            <summary>A structure used to index lambda functions to a lower cased token.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.TokenProcessor.#ctor(System.String,MSTS.STFReader.Processor)">
            <summary>This constructor is used for the arguments to ParseFile and ParseBlock.
            </summary>
            <param name="t">The lower case token.</param>
            <param name="p">A lambda function or delegate that will be called from the Parse...() method.</param>
        </member>
        <member name="T:MSTS.STFReader.STEPBACK">
            <summary>Internal Structure used to group together the variables used to implement step back functionality.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.Item">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. stepbackItem ?ReadItem() return
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.PrevItem">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. stepbackCurrItem ?previousItem
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.Tree">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. stepbackTree ?tree
            <para>This item, is optimized, so when value is null it means stepbackTree was the same as Tree, so we don't create unneccessary memory duplicates of lists.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.BlockDepth">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. BlockDepth ?block_depth
            </summary>
        </member>
        <member name="T:MSTS.MSTSPath">
            <summary>
            Deals with the MSTS file structure.
            </summary>
        </member>
        <member name="M:MSTS.MSTSPath.Base">
            <summary>
            Returns the base path of the MSTS installation
            </summary>
            <returns>no trailing \</returns>
        </member>
        <member name="M:MSTS.MSTSPath.RouteFolder(System.String)">
            <summary>
            Returns the route folder with out trailing \
            </summary>
            <param name="route"></param>
            <returns></returns>
        </member>
        <member name="M:MSTS.MSTSPath.TrainSoundPath(System.String,System.String)">
            <summary>
            Given a soundfile reference in a wag or eng file, return the path the sound file
            </summary>
            <param name="wagfilename"></param>
            <param name="soundfile"></param>
            <returns></returns>
        </member>
        <member name="M:MSTS.MSTSPath.SMSSoundPath(System.String,System.String)">
            <summary>
            Given a soundfile reference in a cvf file, return the path to the sound file
            </summary>
        </member>
        <member name="F:ORTS.FormFolderName.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.FormFolderName.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.FormFolderName.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:MSTS.PATTraveller.#ctor(System.String)">
            <summary>
            Initializes the traveller to the first waypoint 
            in the specified path file.
            </summary>
            <param name="PATFilePath"></param>
        </member>
        <member name="T:MSTS.PATFile">
            <summary>
            Work with consist files, contains an ArrayList of ConsistTrainset
            </summary>
        </member>
        <member name="M:MSTS.PATFile.#ctor(System.String)">
            <summary>
            Open a PAT file, 
            filePath includes full path and extension
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:ORTS.Program.SetBuildRevision">
            <summary>
            Set up the global Build and Revision variables
            from assembly data and the revision.txt file.
            </summary>
        </member>
    </members>
</doc>
