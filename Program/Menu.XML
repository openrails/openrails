<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Menu</name>
    </assembly>
    <members>
        <member name="F:ORTS.DetailsForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.DetailsForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.DetailsForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:ORTS.ExploreForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.ExploreForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.ExploreForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:ORTS.OptionsForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.OptionsForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.OptionsForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:ORTS.MainForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.MainForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.MainForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MSTS.STFReader">
            <summary>Used for reading data from Structured Text Format (MSTS1 style) files.
            </summary><remarks><para>
            An STF file is whitespace delimitered file, taking the format - {item}{whitespace}[repeated].</para><para>
             </para><para>
            At it's most simple an STF file has the format - {token_item}{whitespace}{data_item}{whitespace}(repeated)</para><para>
            Even, more simplisitically every {data_item} can be a {constant_item}</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name SimpleSTFfile</para><para>
                weight 100</para><para>
                speed 50.25</para>
            </code> <para>
            STF also has a block methodology where a {data_item} following a {token_item} can start with '(' followed by any number of {data_item}s and closed with a ')'.
            The contents of the block are defined in the specific file schema, and not in the STF definition.
            The STF defintion allows that inside a pair of parentheses may be a single {constant_item}, multiple whitespace delimitered {constant_item}s, or a nested {token_item}{data_item} pair (which could contain a further nested block recursively).</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name BlockedSTFfile</para><para>
                root_constant 100</para><para>
                root_block_1</para><para>
                (</para><para>
                      nested_block_1_1</para><para>
                      (</para><para>
                            1</para><para>
                      )</para><para>
                      nested_block_1_2 ( 5 )</para><para>
                )</para><para>
                root_block_2</para><para>
                (</para><para>
                      1 2 3</para><para>
                )</para><para>
                root_block_3 ( a b c )</para>
            </code> <para>
            Numeric {constan_item}s can include a 'unit' suffix, which is handled in the ReadDouble() function.</para><para>
            Within ReadDouble these units are then converted to the standards used throughout OR - meters, newtons, kilograms.</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name STFfileWithUnits</para><para>
                weight 100kg</para><para>
                speed 50mph</para>
            </code> <para>
            Whitespaces can be included within any {item} using a double quotation notation.
            Quoted values also support a trailing addition operator to indicate an append operation of multiple quoted strings.</para><para>
            Although append operations are technically allowed for {token_item}'s this practice is *strongly* discouraged for readability.</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                simple_token "Data Item with" + " whitespace"</para><para>
                block_token ( "Data " + "Item 1" "Data Item 2" )</para><para>
                "discouraged_" + "token" -1</para><para>
                Error Example:</para><para>
                error1 "You cannot use append suffix to non quoted " + items</para>
            </code> <para>
            The STF format also supports 3 special {token_item}s - include, comment &amp; skip.</para><list class="bullet">
            <listItem><para>include - must be at the root level (that is to say it cannot be included within a block).
            After an include directive the {constant_item} is a filename relative to the current processing STF file.
            The include token has the effect of in-lining the defined file into the current document.</para></listItem>
            <listItem><para>comment &amp; skip - must be followed by a {data_item} which will not be processed in OR</para></listItem>
            </list>
            </remarks>
            <example>
            !!!TODO!!!
            </example>
            <exception cref="T:MSTS.STFException"><para>
            STF reports errors using the  exception static members</para><para>
            There are three broad categories of error</para><list class="bullet">
            <listItem><para>Failure - Something which prevents loading from continuing, this throws an unhandled exception and drops out of Open Rails.</para></listItem>
            <listItem><para>Error - The data read does not have logical meaning - STFReader does not generate these errors, this is only appropriate STFReader consumers who understand the context of the data being processed</para></listItem>
            <listItem><para>Warning - When an error which can be programatically recovered from should be reported back to the user</para></listItem>
            </list>
            </exception>
        </member>
        <member name="M:MSTS.STFReader.#ctor(System.String)">
            <summary>Open a file, reader the header line, and prepare for STF parsing
            </summary>
            <param name="filename">Filename of the STF file to be opened and parsed.</param>
        </member>
        <member name="M:MSTS.STFReader.#ctor(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>Use an open stream for STF parsing, this constructor assumes that the SIMIS signature has already been gathered (or there isn't one)
            </summary>
            <param name="inputStream">Stream that will be parsed.</param>
            <param name="fileName">Is only used for error reporting.</param>
            <param name="encoding">One of the Encoding formats, defined as static members in Encoding which return an Encoding type.  Eg. Encoding.ASCII or Encoding.Unicode</param>
        </member>
        <member name="M:MSTS.STFReader.Dispose">
            <summary>Implements the IDisposable interface so this class can be implemented with the 'using(STFReader r = new STFReader(...)) {...}' C# statement.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.Dispose(System.Boolean)">
            <summary>Releases the resources used by the STFReader.
            </summary>
            <param name="disposing">
            <para>true - release managed and unmanaged resources.</para>
            <para>false - release only unmanaged resources.</para>
            </param>
        </member>
        <member name="M:MSTS.STFReader.ReadItem">
            <summary>This is the main function in STFReader, it returns the next whitespace delimited {item} from the STF file.
            </summary>
            <returns>The next {item} from the STF file, any surrounding quotations will be not be returned.</returns>
        </member>
        <member name="M:MSTS.STFReader.RewindItem">
            <summary>Calling this function causes ReadItem() to repeat the last {item} that was read from the STF file
            </summary>
            <remarks>
            <para>The current implementation of RewindItem() only allows for "rewind".</para>
            <para>This means that there each call to RewindItem() must have an intervening call to ReadItem().</para>
            </remarks>
        </member>
        <member name="M:MSTS.STFReader.MustMatch(System.String)">
            <summary>Reports a critical error if the next {item} does not match the target.
            </summary>
            <param name="target">The next {item} contents we are expecting in the STF file.</param>
            <returns>The {item} read from the STF file</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadTokenNoComment">
            <summary>Read the next {token_item} skipping past any 'comment', 'skip', '#*' or '_*' tokens.
            </summary>
            <remarks>
            <para>This cursor should be called when placed at a {token_item} and not at a {data_item}.</para>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MSTS.STFReader.EndOfBlock">
            <summary>Returns true if the next character is the end of block, or end of file. Consuming the closing ")" all other values are not consumed.
            </summary>
            <remarks>
            <para>An STF block should be enclosed in parenthesis, ie ( {data_item} {data_item} )</para>
            </remarks>
            <returns>
            <para>true - An EOF, or closing parenthesis was found and consumed.</para>
            <para>false - Another type of {item} was found but not consumed.</para>
            </returns>
        </member>
        <member name="M:MSTS.STFReader.SkipBlock">
            <summary>Read a block open (, and then consume the rest of the block without processing.
            If we find an immediate close ), then produce a warning, and return without consuming the parenthesis.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.SkipRestOfBlock">
            <summary>Skip to the end of this block, ignoring any nested blocks
            </summary>
        </member>
        <member name="F:MSTS.STFReader.IncludeReader">
            <summary>IncludeReader is used recursively in ReadItem() to handle the 'include' token, file include mechanism
            </summary>
        </member>
        <member name="F:MSTS.STFReader.previousItem">
            <summary>Remembers the last returned ReadItem().  If the next {item] is a '(', this is the block name used in the tree.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.tree">
            <summary>A list describing the hierachy of nested block tokens
            </summary>
        </member>
        <member name="F:MSTS.STFReader.rewindNextReadItemFlag">
            <summary>This flag is set in RewindItem(), and causes ReadItem(), to use the rewind* variables to do an item repeat
            </summary>
        </member>
        <member name="F:MSTS.STFReader.rewindTree">
            <summary>The rewind* variables store the previous state, so RewindItem() can jump back on {item}. rewindTree « tree
            <para>This item, is optimized, so when value is null it means rewindTree was the same as Tree, so we don't create unneccessary memory duplicates of lists.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.rewindCurrItem">
            <summary>The rewind* variables store the previous state, so RewindItem() can jump back on {item}. rewindCurrItem « previousItem
            </summary>
        </member>
        <member name="F:MSTS.STFReader.rewindItem">
            <summary>The rewind* variables store the previous state, so RewindItem() can jump back on {item}. rewindItem « ReadItem() return
            </summary>
        </member>
        <member name="M:MSTS.STFReader.UpdateTreeAndRewindBuffer(System.String)">
            <summary>Internal Implementation
            <para>This function is called by ReadItem() for every item read from the STF file (and Included files).</para>
            <para>If a block instuction is found, then tree list is updated.</para>
            <para>As this function is called once per ReadItem() is stores the previous value in rewind* variables (there is additional optimization that we only copy rewindTree if the tree has changed.</para>
            <para>Now when the rewind flag is set, we use the rewind* copies, to move back exactly one item.</para>
            </summary>
            <param name="token"></param>
        </member>
        <member name="P:MSTS.STFReader.EOF">
            <summary>Property that returns true when the EOF has been reached
            </summary>
        </member>
        <member name="P:MSTS.STFReader.FileName">
            <summary>Filename property for the file being parsed - for reporting purposes
            </summary>
        </member>
        <member name="P:MSTS.STFReader.LineNumber">
            <summary>Line Number property for the file being parsed - for reporting purposes
            </summary>
        </member>
        <member name="P:MSTS.STFReader.SIMISsignature">
            <summary>SIMIS header read from the first line of the file being parsed
            </summary>
        </member>
        <member name="P:MSTS.STFReader.Tree">
            <summary>Property returning the last {item} read using ReadItem() prefixed with string describing the nested block hierachy.
            <para>The string returned is formatted 'rootnode(nestednode(childnode(previous_item'.</para>
            </summary>
            <remarks>
            Tree is expensive method of reading STF files (especially for the GC) and should be avoided if possible.
            </remarks>
        </member>
        <member name="T:MSTS.MSTSPath">
            <summary>
            Deals with the MSTS file structure.
            </summary>
        </member>
        <member name="M:MSTS.MSTSPath.Base">
            <summary>
            Returns the base path of the MSTS installation
            </summary>
            <returns>no trailing \</returns>
        </member>
        <member name="M:MSTS.MSTSPath.RouteFolder(System.String)">
            <summary>
            Returns the route folder with out trailing \
            </summary>
            <param name="route"></param>
            <returns></returns>
        </member>
        <member name="M:MSTS.MSTSPath.TrainSoundPath(System.String,System.String)">
            <summary>
            Given a soundfile reference in a wag or eng file, return the path the sound file
            </summary>
            <param name="wagfilename"></param>
            <param name="soundfile"></param>
            <returns></returns>
        </member>
        <member name="M:MSTS.MSTSPath.SMSSoundPath(System.String,System.String)">
            <summary>
            Given a soundfile reference in a cvf file, return the path to the sound file
            </summary>
            <param name="wagfilename"></param>
            <param name="soundfile"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.Program.SetBuildRevision">
            <summary>
            Set up the global Build and Revision variables
            from assembly data and the revision.txt file.
            </summary>
        </member>
        <member name="F:ORTS.FormFolderName.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.FormFolderName.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.FormFolderName.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MSTS.ACTFile">
            <summary>
            Summary description for Class1.
            </summary>
        </member>
        <member name="M:MSTS.EventCategoryLocation.#ctor(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Create a new 'ActivitySuccess' LocationEvent
            </summary>
        </member>
        <member name="M:MSTS.EventCategoryAction.#ctor(System.Int32)">
            <summary>
            Build a default EventTypeAllStops event
            </summary>
        </member>
        <member name="T:ORTS.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ORTS.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ORTS.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
    </members>
</doc>
