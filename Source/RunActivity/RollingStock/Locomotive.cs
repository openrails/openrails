/* LOCOMOTIVE CLASSES
 * 
 * Used a a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  LocomotiveSimulator - defines the behaviour, ie physics, motion, power generated etc
 *  LocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCarSimulator - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */
/// COPYRIGHT 2009 by the Open Rails project.
/// This code is provided to enable you to contribute improvements to the open rails program.  
/// Use of the code for any other purpose or distribution of the code to anyone else
/// is prohibited without specific written permission from admin@openrails.org.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MSTS;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework;



namespace ORTS
{

    ///////////////////////////////////////////////////
    ///   SIMULATION BEHAVIOUR
    ///////////////////////////////////////////////////


    /// <summary>
    /// Adds Throttle, Direction, Horn, Sander and Wiper control
    /// to the basic TrainCar.
    /// Use as a base for Electric, Diesel or Steam locomotives.
    /// </summary>
    public class Locomotive: TrainCar
    {
        public float ThrottlePercent = 0;
        public bool Forward = true;  // true = forward, false = reverse
        public bool Horn = false;
        public bool Bell = false;
        public bool Sander = false;  // false = off
        public bool Wiper = false;   // false = off

        public Locomotive(WAGFile wagFile)
            : base(wagFile)
        {
        }

        public override TrainCarViewer GetViewer(Viewer3D viewer)
        {
            return new LocomotiveViewer(viewer, this);
        }

        public void HandleUserInput()
        {
            // Direction Control
            if (UserInput.IsPressed(Keys.W))
            {
                this.Forward = true;
                CreateEvent(15);
            }
            if (UserInput.IsPressed(Keys.S))
            {
                this.Forward = false;
                CreateEvent(16);
            }
            Train.TrainDirectionForward = this.Forward;

            // Some extremely simple physics for the Throttle
            if (UserInput.IsPressed(Keys.D)) this.ThrottlePercent += 10;
            if (UserInput.IsPressed(Keys.A)) this.ThrottlePercent -= 10;
            if (this.ThrottlePercent < 0) this.ThrottlePercent = 0;
            if (this.ThrottlePercent > 100) this.ThrottlePercent = 100;

            //Some extremely simple physics for the Brake
            if (UserInput.IsPressed(Keys.OemQuotes) || UserInput.IsPressed(Keys.E)) Train.TrainBrakePercent += 10;
            if (UserInput.IsPressed(Keys.OemSemicolon) || UserInput.IsPressed(Keys.Q)) Train.TrainBrakePercent -= 10;
            if (Train.TrainBrakePercent < 0) Train.TrainBrakePercent = 0;
            if (Train.TrainBrakePercent > 100) Train.TrainBrakePercent = 100;

            Train.TrainThrottlePercent = this.ThrottlePercent;

            // Horn
            if (UserInput.IsKeyDown(Keys.Space))
            {
                if (!Horn)
                {
                    Horn = true;
                    CreateEvent(8);
                }
            }
            else 
            {
                if (Horn)
                {
                    Horn = false;
                    CreateEvent(9);
                }
            }

            // Bell
            if (UserInput.IsKeyDown(Keys.B))
            {
                if (!Bell)
                {
                    Bell = true;
                    CreateEvent(10);
                }
            }
            else
            {
                if (Bell)
                {
                    Bell = false;
                    CreateEvent(11);
                }
            }

            // Sander
            if (UserInput.IsPressed(Keys.X))
            {
                Sander = !Sander;
                CreateEvent(26);  // sander toggled
                CreateEvent(Sander ? 4 : 5);  // on or off event
            }

            // Wiper
            if (UserInput.IsPressed(Keys.V))
            {
                Wiper = !Wiper;
                CreateEvent(Wiper ? 6 : 7);  // on or off event
            }

        }

        public override void Update( float elapsedClockSeconds )
        {
            // TODO  this is a wild simplification for electric and diesel electric
            float maxForceN = 300e3f * Train.TrainThrottlePercent/100f;   // TODO pull 300e3 from wag file
            float maxSpeedMpS = MpS.FromMpH(50) * Train.TrainThrottlePercent/100f;  // TODO pull 50 from wag file
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            float balanceRatio = 1;
            if (maxSpeedMpS > currentSpeedMpS)
                balanceRatio = currentSpeedMpS / maxSpeedMpS;

            MotiveForceN = (Train.TrainDirectionForward ? 1 : -1) * maxForceN * ( 1f-balanceRatio); 

            // Variable1 is wheel rotation in m/sec for steam locomotives
            Variable2 = MotiveForceN/300e3f;   // force generated
            Variable1 = ThrottlePercent / 100f;   // throttle setting

            base.Update( elapsedClockSeconds );
        }

    } // LocomotiveSimualtor

    ///////////////////////////////////////////////////
    ///   3D VIEW
    ///////////////////////////////////////////////////

    /// <summary>
    /// Adds animation for wipers to the basic TrainCar
    /// </summary>
    class LocomotiveViewer : TrainCarViewer
    {
        Locomotive Locomotive;

        List<int> WiperPartIndexes = new List<int>();

        float WiperAnimationKey = 0;

        public LocomotiveViewer(Viewer3D viewer, Locomotive car)
            : base(viewer, car)
        {
            Locomotive = car;

            // Find the animated parts
            if (TrainCarShape.SharedShape.Animations != null)
            {
                for (int iMatrix = 0; iMatrix < TrainCarShape.SharedShape.MatrixNames.Length; ++iMatrix)
                {
                    string matrixName = TrainCarShape.SharedShape.MatrixNames[iMatrix].ToUpper();
                    switch (matrixName)
                    {
                        case "WIPERARMLEFT1":
                        case "WIPERBLADELEFT1":
                        case "WIPERARMRIGHT1":
                        case "WIPERBLADERIGHT1":
                            if (TrainCarShape.SharedShape.Animations[0].FrameCount > 1)  // ensure shape file is properly animated for wipers
                                WiperPartIndexes.Add(iMatrix);
                            break;
                        case "MIRRORARMLEFT1":
                        case "MIRRORLEFT1":
                        case "MIRRORARMRIGHT1":
                        case "MIRRORRIGHT1":
                            // TODO
                            break;
                    }
                }
            }
        }

        public override void HandleUserInput( ElapsedTime elapsedTime )
        {
            Locomotive.HandleUserInput(); // TODO, replace this with calls to loco controls, ie SetThrottle, SetDirection etc 
            base.HandleUserInput( elapsedTime );
        }


        public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime )
        {
            float elapsedClockMilliseconds = elapsedTime.ClockSeconds / 1000.0f;
            // Wiper animation
            if (WiperPartIndexes.Count > 0)  // skip this if there are no wipers
            {
                if (Locomotive.Wiper) // on
                {
                    // Wiper Animation
                    // Compute the animation key based on framerate etc
                    // ie, with 8 frames of animation, the key will advance from 0 to 8 at the specified speed.
                    WiperAnimationKey += ((float)TrainCarShape.SharedShape.Animations[0].FrameRate / 10f) * elapsedClockMilliseconds;
                    while (WiperAnimationKey >= TrainCarShape.SharedShape.Animations[0].FrameCount) WiperAnimationKey -= TrainCarShape.SharedShape.Animations[0].FrameCount;
                    while (WiperAnimationKey < -0.00001) WiperAnimationKey += TrainCarShape.SharedShape.Animations[0].FrameCount;
                    foreach (int iMatrix in WiperPartIndexes)
                        TrainCarShape.AnimateMatrix(iMatrix, WiperAnimationKey);
                }
                else // off
                {
                    if (WiperAnimationKey > 0.001)  // park the blades
                    {
                        WiperAnimationKey += ((float)TrainCarShape.SharedShape.Animations[0].FrameRate / 10f) * elapsedClockMilliseconds;
                        if (WiperAnimationKey >= TrainCarShape.SharedShape.Animations[0].FrameCount) WiperAnimationKey = 0;
                        foreach (int iMatrix in WiperPartIndexes)
                            TrainCarShape.AnimateMatrix(iMatrix, WiperAnimationKey);
                    }
                }
            }

            base.PrepareFrame( frame, elapsedTime );
        }

    } // Class LocomotiveViewer



}
