// COPYRIGHT 2009, 2010, 2011, 2012, 2013 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

/* LOCOMOTIVE CLASSES
 * 
 * Used as a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  MSTSLocomotive - defines the behaviour, ie physics, motion, power generated etc
 *  MSTSLocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCar - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */

//#define ALLOW_ORTS_SPECIFIC_ENG_PARAMETERS

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using MSTS.Formats;
using MSTS.Parsers;
using ORTS.Common;
using ORTS.Viewer3D;
using ORTS.Viewer3D.Popups;

namespace ORTS
{

    ///////////////////////////////////////////////////
    ///   SIMULATION BEHAVIOUR
    ///////////////////////////////////////////////////

    public enum CabViewType
    {
        Front = 0,
        Rear = 1,
    }

    /// <summary>
    /// Adds Throttle, Direction, Horn, Sander and Wiper control
    /// to the basic TrainCar.
    /// Use as a base for Electric, Diesel or Steam locomotives.
    /// </summary>
    public partial class MSTSLocomotive : MSTSWagon
    {
        /// <summary>
        /// Supply types for locos. Could perhaps be extended to freight wagons?
        /// </summary>
        public enum PickupType
        {
            FuelWater = 5,
            FuelCoal = 6,
            FuelDiesel = 7,
            FuelWood = 8    // Think this is new to OR and not recognised by MSTS
        }

        // simulation parameters
        public bool Horn;
        public bool AlerterSnd;
        public bool VigilanceMonitor;
        public bool Bell;
        public bool Sander;
        public bool Wiper;
        public bool BailOff;
        public bool DynamicBrake;
        public float MaxPowerW;
        public float MaxForceN;
        public float MaxSpeedMpS = 1e3f;
        public float MainResPressurePSI = 130;
        public bool CompressorIsOn;
        public float AverageForceN;
        public bool PowerOn;
        public float PowerOnDelayS;
        public bool CabLightOn;
        public bool ShowCab = true;

        bool DoesHornTriggerBell;

        // wag file data
        public string CabSoundFileName;
        public string CVFFileName;
        public float MaxMainResPressurePSI = 130;
        public float MainResVolumeFT3 = 10;
        public float CompressorRestartPressurePSI = 110;
        public float MainResChargingRatePSIpS = .4f;
        public float EngineBrakeReleaseRatePSIpS = 12.5f;
        public float EngineBrakeApplyRatePSIpS = 12.5f;
        public float BrakePipeTimeFactorS = .003f;
        public float BrakeServiceTimeFactorS = 1.009f;
        public float BrakeEmergencyTimeFactorS = .1f;
        public float BrakePipeChargingRatePSIpS;
        public Interpolator2D TractiveForceCurves;
        public Interpolator2D DynamicBrakeForceCurves;
        public float DynamicBrakeSpeed1MpS = MpS.FromKpH(5);
        public float DynamicBrakeSpeed2MpS = MpS.FromKpH(30);
        public float DynamicBrakeSpeed3MpS = MpS.FromKpH(999);
        public float DynamicBrakeSpeed4MpS = MpS.FromKpH(999);
        public float MaxDynamicBrakeForceN;
        public float DynamicBrakeDelayS;
        public bool DynamicBrakeAutoBailOff;
        public bool UsingRearCab;

        public bool HasCombCtrl;
        public bool HasCombThrottleTrainBrake;
        public bool RDHasCombThrottleTrainBrake;    // Temp added for RD exception bug #
        public bool HasDefectiveComboDynamicBreak;
        public bool HasSmoothStruc;
        public int ComboCtrlCrossOver = 5;

        public float MaxContinuousForceN;
        public float ContinuousForceTimeFactor = 1800;
        public float NumWheelsAdhesionFactor = 4;   // MSTS adhesion factor loosely based on the number of driven axles
        public bool AntiSlip;
        public float SanderSpeedEffectUpToMpS;
        public float SanderSpeedOfMpS = 30.0f;
        public string EngineOperatingProcedures;

        public bool EmergencyCausesPowerDown;
        public bool EmergencyCausesThrottleDown;
        public bool EmergencyEngagesHorn;
        public bool EmergencyButtonPressed;
        public bool WheelslipCausesThrottleDown;
        
        public string EngineType;
        public bool IsSteam;
        public bool IsDiesel;
        public bool IsElectric;

		public float CabRotationZ
		{
			get
			{
				return ((UsingRearCab ||
					((CabViewList[(int)CabViewType.Front].ViewPointList[0].StartDirection.Y >= 90) ||
					(CabViewList[(int)CabViewType.Front].ViewPointList[0].StartDirection.Y <= -90)) && !Flipped) == true ?
					-totalRotationZ * Program.Simulator.CabRotating : totalRotationZ * Program.Simulator.CabRotating);
			}
		}
        public Dictionary<string, List<ParticleEmitterData>> EffectData = new Dictionary<string, List<ParticleEmitterData>>();

        public List<CabView> CabViewList = new List<CabView>();

        public MSTSNotchController ThrottleController;
        public MSTSBrakeController TrainBrakeController;
        public MSTSBrakeController EngineBrakeController;
        public AirSinglePipe.ValveState EngineBrakeState = AirSinglePipe.ValveState.Lap;
        public MSTSNotchController DynamicBrakeController;
        public MSTSNotchController GearBoxController;

        public Axle LocomotiveAxle;
        public IIRFilter CurrentFilter;
        public IIRFilter AdhesionFilter;

        public float FilteredMotiveForceN;

        public double CommandStartTime;

        public MSTSLocomotive(Simulator simulator, string wagPath)
            : base(simulator, wagPath)
        {
            BrakePipeChargingRatePSIpS = simulator.Settings.BrakePipeChargingRate;

            LocomotiveAxle = new Axle();
            LocomotiveAxle.DriveType = AxleDriveType.ForceDriven;
            LocomotiveAxle.DampingNs = MassKG / 1000.0f;
            LocomotiveAxle.FrictionN = MassKG / 100.0f;
            LocomotiveAxle.AdhesionK = AdhesionK;
            LocomotiveAxle.CurtiusKnifflerA = Curtius_KnifflerA;
            LocomotiveAxle.CurtiusKnifflerB = Curtius_KnifflerB;
            LocomotiveAxle.CurtiusKnifflerC = Curtius_KnifflerC;
            LocomotiveAxle.StabilityCorrection = true;
            LocomotiveAxle.FilterMovingAverage.Size = Simulator.Settings.AdhesionMovingAverageFilterSize;
            CurrentFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(0.5f), 0.001f);
            AdhesionFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(0.1f), 0.001f);
        }

        /// <summary>
        /// This initializer is called when we haven't loaded this type of car before
        /// and must read it new from the wag file.
        /// </summary>
        public override void InitializeFromWagFile(string wagFilePath)
        {
            TrainBrakeController = new MSTSBrakeController(Simulator);
            EngineBrakeController = new MSTSBrakeController(Simulator);
            DynamicBrakeController = new MSTSNotchController();
            TrainControlSystem = new ScriptedTrainControlSystem(this);
            base.InitializeFromWagFile(wagFilePath);

            if (ThrottleController == null)
            {
                //If no controller so far, we create a default one
                ThrottleController = new MSTSNotchController();
                ThrottleController.StepSize = 0.1f;
            }

            if (VigilanceMonitor)
            {
                TrainControlSystem.Initialize();
            }

            // Assumes that CabViewList[0] is the front cab
            // and that CabViewList[1] is the rear cab, if present.
            // Could be extended to more than 2 cabs.
            if (CVFFileName != null)
            {
                var cabView = BuildCabView(WagFilePath, CVFFileName, CabViewType.Front);
                if (cabView != null)
                {
                    CabViewList.Add(cabView);
                    var reverseCVFFileName = Path.Combine(Path.GetDirectoryName(CVFFileName),
                        // Some CVF paths begin with "..\..\"
                        // so Path.GetDirectoryName() is needed.
                                                            Path.GetFileNameWithoutExtension(CVFFileName) + "_rv.cvf");
                    {
                        cabView = BuildCabView(WagFilePath, reverseCVFFileName, CabViewType.Rear);
                        if (cabView != null)
                            CabViewList.Add(cabView);
                    }
                }
                else
                {
                    Trace.TraceWarning("{0} locomotive's CabView references non-existent {1}", wagFilePath, CVFFileName);
                }
            }

            IsDriveable = true;
            if (!TrainBrakeController.IsValid())
                TrainBrakeController = new MSTSBrakeController(Simulator); //create a blank one
            if (!EngineBrakeController.IsValid())
                EngineBrakeController = null;

            // need to test for Dynamic brake problem on 3DTS and SLI
            if (DynamicBrakeController.IsValid())
            {
                if (DynamicBrakeController.NotchCount() <= 3)
                {
                    // Trace.TraceInformation("Smooth Dynamic Brake may have inaccurate display");
                    HasSmoothStruc = true;
                }
            }
            if (!DynamicBrakeController.IsValid())
                DynamicBrakeController = null;
            if (DynamicBrakeForceCurves == null && MaxDynamicBrakeForceN > 0)
            {
                DynamicBrakeForceCurves = new Interpolator2D(2);
                Interpolator interp = new Interpolator(2);
                interp[0] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[0] = interp;
                interp = new Interpolator(4);
                interp[DynamicBrakeSpeed1MpS] = 0;
                interp[DynamicBrakeSpeed2MpS] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed3MpS] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4MpS] = 0;
                DynamicBrakeForceCurves[1] = interp;
            }
        }

        private CabView BuildCabView(string wagFilePath, string cvfFileName, CabViewType type)
        {
            var viewPointList = new List<ViewPoint>();
            var extendedCVF = new ExtendedCVF();

            var cvfBasePath = Path.Combine(Path.GetDirectoryName(wagFilePath), "CABVIEW");
            var cvfFilePath = Path.Combine(cvfBasePath, cvfFileName);
            if (!File.Exists(cvfFilePath))
                return null;

            var cvfFile = new CVFFile(cvfFilePath, cvfBasePath);
            var viewPoint = new ViewPoint();                    // Set up camera locations for the cab views
            for (int i = 0; i < cvfFile.Locations.Count; ++i)
            {
                if (i >= cvfFile.Locations.Count || i >= cvfFile.Directions.Count)
                {
                    Trace.TraceWarning("Skipped cab view camera {1} missing Position and Direction in {0}", cvfFilePath, i);
                    break;
                }
                viewPoint = new ViewPoint();
                viewPoint.Location = cvfFile.Locations[i];
                viewPoint.StartDirection = cvfFile.Directions[i];
                viewPoint.RotationLimit = new Vector3(0, 0, 0);  // cab views have a fixed head position
                viewPointList.Add(viewPoint);
            }

            if (!(this is MSTSSteamLocomotive))
            {
                InitializeFromORTSSpecific(cvfFilePath, extendedCVF);
            }
            return new CabView(cvfFile, viewPointList, extendedCVF);
        }

        protected void ParseEffects(string lowercasetoken, STFReader stf)
        {
            stf.MustMatch("(");
            string s;

            while ((s = stf.ReadItem()) != ")")
            {
                var data = new ParticleEmitterData(stf);
                if (!EffectData.ContainsKey(s))
                    EffectData.Add(s, new List<ParticleEmitterData>());
                EffectData[s].Add(data);
            }
        }

        /// <summary>
        /// Parse the wag file parameters required for the simulator and viewer classes
        /// </summary>
        public override void Parse(string lowercasetoken, STFReader stf)
        {
            if (lowercasetoken.StartsWith("engine(trainbrakescontroller"))
                TrainBrakeController.ParseBrakeValue(lowercasetoken.Substring(28), stf);
            if (lowercasetoken.StartsWith("engine(enginebrakescontroller"))
                EngineBrakeController.ParseBrakeValue(lowercasetoken.Substring(29), stf);
            switch (lowercasetoken)
            {
                case "engine(sound": CabSoundFileName = stf.ReadStringBlock(null); break;
                case "engine(cabview": CVFFileName = stf.ReadStringBlock(null); break;
                case "engine(maxpower": MaxPowerW = stf.ReadFloatBlock(STFReader.UNITS.Power, null); break;
                case "engine(maxforce": MaxForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxcontinuousforce": MaxContinuousForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxvelocity": MaxSpeedMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;

                case "engine(type":
                    stf.MustMatch("(");
                    string typeString = stf.ReadString();
                    IsSteam = String.Compare(typeString, "Steam") == 0 ? true : false;
                    IsDiesel = String.Compare(typeString, "Diesel") == 0 ? true : false;
                    IsElectric = String.Compare(typeString, "Electric") == 0 ? true : false;
                    break;

                case "engine(enginecontrollers(throttle": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(regulator": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(brake_train":
                    TrainBrakeController.Parse(stf);
                    break;
                case "engine(enginecontrollers(brake_engine":
                    EngineBrakeController.Parse(stf);
                    break;
                case "engine(enginecontrollers(brake_dynamic": DynamicBrakeController.Parse(stf); break;

                case "engine(ortstraincontrolsystem":
                case "engine(ortstraincontrolsystemsound":
                case "engine(ortstraincontrolsystemparameters":
                case "engine(vigilancemonitor":
                case "engine(emergencystopmonitor":
                case "engine(awsmonitor":
                case "engine(overspeedmonitor": VigilanceMonitor = true; TrainControlSystem.Parse(lowercasetoken, stf); break;

                // case "engine(enginecontrollers(combined_control": HasCombCtrl = true; if (!DynamicBrakeController.IsValid()) DynamicBrakeController = new MSTSNotchController(0, 1, .05f); break;
                case "engine(enginecontrollers(combined_control":
                    ParseCombData(lowercasetoken, stf); break;

                case "engine(airbrakesmainresvolume": MainResVolumeFT3 = stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null); break;
                case "engine(airbrakesmainmaxairpressure": MainResPressurePSI = MaxMainResPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(airbrakescompressorrestartpressure": CompressorRestartPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(ortsmainreschargingrate": MainResChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsenginebrakereleaserate": EngineBrakeReleaseRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsenginebrakeapplicationrate": EngineBrakeApplyRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsbrakepipetimefactor": BrakePipeTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(ortsbrakeservicetimefactor": BrakeServiceTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(ortsbrakeemergencytimefactor": BrakeEmergencyTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(ortsbrakepipechargingrate": BrakePipeChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsmaxtractiveforcecurves": TractiveForceCurves = new Interpolator2D(stf, false); break;
                case "engine(ortstractioncharacteristics": TractiveForceCurves = new Interpolator2D(stf, true); break;
                case "engine(ortsdynamicbrakeforcecurves": DynamicBrakeForceCurves = new Interpolator2D(stf, false); break;
                case "engine(ortscontinuousforcetimefactor": ContinuousForceTimeFactor = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(orts(ortssanderspeedeffectupto": SanderSpeedEffectUpToMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(orts(ortspowerondelay": PowerOnDelayS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(orts(ortsemergencycausespowerdown": EmergencyCausesPowerDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(ortsemergencycausesthrottledown": EmergencyCausesThrottleDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(ortsemergencyengageshorn": EmergencyEngagesHorn = stf.ReadBoolBlock(false); break;
                case "engine(orts(ortswheelslipcausesthrottledown": WheelslipCausesThrottleDown = stf.ReadBoolBlock(false); break;
                case "engine(dynamicbrakesminusablespeed": DynamicBrakeSpeed1MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesfadingspeed": DynamicBrakeSpeed2MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesmaximumeffectivespeed": DynamicBrakeSpeed3MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesmaximumspeedforfadeout": DynamicBrakeSpeed4MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesmaximumforce": MaxDynamicBrakeForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(dynamicbrakehasautobailoff":
                case "engine(ortsdynamicbrakeshasautobailoff": DynamicBrakeAutoBailOff = stf.ReadBoolBlock(true); break;
                case "engine(dynamicbrakesdelaytimebeforeengaging": DynamicBrakeDelayS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(numwheels": NumWheelsAdhesionFactor = stf.ReadFloatBlock(STFReader.UNITS.None, 4.0f); if (NumWheelsAdhesionFactor < 1) STFException.TraceWarning(stf, "Engine:NumWheels is less than 1, parts of the simulation may not function correctly"); break;
                case "engine(antislip": AntiSlip = stf.ReadBoolBlock(false); break;
                case "engine(engineoperatingprocedures": EngineOperatingProcedures = stf.ReadStringBlock(""); break;
                case "engine(headout":
                    HeadOutViewpoints.Add(new ViewPoint(stf.ReadVector3Block(STFReader.UNITS.Distance, Vector3.Zero)));
                    HeadOutViewpoints.Add(new ViewPoint(HeadOutViewpoints[0], true));
                    break;
                case "engine(sanding": SanderSpeedOfMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, 30.0f); break;
                case "engine(doeshorntriggerbell": DoesHornTriggerBell = stf.ReadBoolBlock(false); break;



                default: base.Parse(lowercasetoken, stf); break;
            }
        }

        /// <summary>
        /// This initializer is called when we are making a new copy of a car already
        /// loaded in memory.  We use this one to speed up loading by eliminating the
        /// need to parse the wag file multiple times.
        /// </summary>
        public override void InitializeFromCopy(MSTSWagon copy)
        {
            MSTSLocomotive locoCopy = (MSTSLocomotive)copy;
            CabSoundFileName = locoCopy.CabSoundFileName;
            CVFFileName = locoCopy.CVFFileName;
            CabViewList = locoCopy.CabViewList;

            MaxPowerW = locoCopy.MaxPowerW;
            MaxForceN = locoCopy.MaxForceN;
            MaxSpeedMpS = locoCopy.MaxSpeedMpS;
            IsSteam = locoCopy.IsSteam;
            TractiveForceCurves = locoCopy.TractiveForceCurves;
            MaxContinuousForceN = locoCopy.MaxContinuousForceN;
            ContinuousForceTimeFactor = locoCopy.ContinuousForceTimeFactor;
            DynamicBrakeForceCurves = locoCopy.DynamicBrakeForceCurves;
            DynamicBrakeAutoBailOff = locoCopy.DynamicBrakeAutoBailOff;
            DynamicBrakeDelayS = locoCopy.DynamicBrakeDelayS;
            NumWheelsAdhesionFactor = locoCopy.NumWheelsAdhesionFactor;
            AntiSlip = locoCopy.AntiSlip;
            EffectData = locoCopy.EffectData;
            SanderSpeedEffectUpToMpS = locoCopy.SanderSpeedEffectUpToMpS;
            SanderSpeedOfMpS = locoCopy.SanderSpeedOfMpS;
            PowerOnDelayS = locoCopy.PowerOnDelayS;
            DoesHornTriggerBell = locoCopy.DoesHornTriggerBell;

            EmergencyCausesPowerDown = locoCopy.EmergencyCausesPowerDown;
            EmergencyCausesThrottleDown = locoCopy.EmergencyCausesThrottleDown;
            EmergencyEngagesHorn = locoCopy.EmergencyEngagesHorn;

            WheelslipCausesThrottleDown = locoCopy.WheelslipCausesThrottleDown;

            IsDriveable = copy.IsDriveable;
            //ThrottleController = MSTSEngineController.Copy(locoCopy.ThrottleController);
            ThrottleController = (MSTSNotchController)locoCopy.ThrottleController.Clone();
            TrainBrakeController = (MSTSBrakeController)locoCopy.TrainBrakeController.Clone();
            EngineBrakeController = locoCopy.EngineBrakeController != null ? (MSTSBrakeController)locoCopy.EngineBrakeController.Clone() : null;
            DynamicBrakeController = locoCopy.DynamicBrakeController != null ? (MSTSNotchController)locoCopy.DynamicBrakeController.Clone() : null;
            TrainControlSystem = locoCopy.TrainControlSystem != null ? locoCopy.TrainControlSystem.Clone(this) : null;

            Initialize();

            base.InitializeFromCopy(copy);  // each derived level initializes its own variables
        }

        /// <summary>
        /// We are saving the game.  Save anything that we'll need to restore the 
        /// status later.
        /// </summary>
        public override void Save(BinaryWriter outf)
        {
            // we won't save the horn state
            outf.Write(Bell);
            outf.Write(Sander);
            outf.Write(Wiper);
            outf.Write(MainResPressurePSI);
            outf.Write(CompressorIsOn);
            outf.Write(AverageForceN);
            outf.Write(LocomotiveAxle.AxleSpeedMpS);
            outf.Write(CabLightOn);
            outf.Write(UsingRearCab);
            ControllerFactory.Save(ThrottleController, outf);
            ControllerFactory.Save(TrainBrakeController, outf);
            ControllerFactory.Save(EngineBrakeController, outf);
            ControllerFactory.Save(DynamicBrakeController, outf);
            base.Save(outf);
        }

        /// <summary>
        /// We are restoring a saved game.  The TrainCar class has already
        /// been initialized.   Restore the game state.
        /// </summary>
        public override void Restore(BinaryReader inf)
        {
            if (inf.ReadBoolean()) SignalEvent(Event.BellOn);
            if (inf.ReadBoolean()) SignalEvent(Event.SanderOn);
            if (inf.ReadBoolean()) SignalEvent(Event.WiperOn);
            MainResPressurePSI = inf.ReadSingle();
            CompressorIsOn = inf.ReadBoolean();
            AverageForceN = inf.ReadSingle();
            LocomotiveAxle.Reset(inf.ReadSingle());
            CabLightOn = inf.ReadBoolean();
            UsingRearCab = inf.ReadBoolean();
            ThrottleController = (MSTSNotchController)ControllerFactory.Restore(Simulator, inf);
            TrainBrakeController = (MSTSBrakeController)ControllerFactory.Restore(Simulator, inf);
            EngineBrakeController = (MSTSBrakeController)ControllerFactory.Restore(Simulator, inf);
            DynamicBrakeController = (MSTSNotchController)ControllerFactory.Restore(Simulator, inf);
            AdhesionFilter.Reset(0.5f);

            base.Restore(inf);
        }

        public bool IsLeadLocomotive()
        {
            return Train.LeadLocomotive == this;
        }

        private void ParseCombData(string lowercasetoken, STFReader stf)
        {
            HasCombCtrl = true;

            string s;
            int i = 0;
            string[] comboData = new string[10];

            while ((s = stf.ReadItem()) != ")")
            {
                comboData[i] = s;
                i++;
            }

            if (comboData[6] == "train")
            {
                // ComboBrakeType = "train";
                // HasCombThrottleTrainBrake = true;    not to be enabled until train/brake logic is correct
                RDHasCombThrottleTrainBrake = true;
                //if (!TrainBrakeController.IsValid())
                //    TrainBrakeController = new MSTSBrakeController(Simulator);
            }

            // TODO: Future use
            //if (comboData[6] == "dynamic")
            //{
            //    // ComboBrakeType = "dynamic";
            //    DynamicBrake = true;
            //    if (!DynamicBrakeController.IsValid())
            //        DynamicBrakeController = new MSTSNotchController(0, 1, .05f);
            //}

            // Note: We are always setting a dynamic !!!
            // This should be corrected when proper operation for Combo throttle/train is correct
            // RDHasCombThrottleTrainBrake was added to fix bug # when RailDriver is activeated
            DynamicBrake = true;
            if (!DynamicBrakeController.IsValid())
                DynamicBrakeController = new MSTSNotchController(0, 1, .05f);
        }

        /// <summary>
        /// Sets controler settings from other engine for cab switch
        /// </summary>
        /// <param name="other"></param>
        public override void CopyControllerSettings(TrainCar other)
        {
            base.CopyControllerSettings(other);
            if (ThrottleController != null)
                ThrottleController.SetValue(other.ThrottlePercent / 100);
            if (DynamicBrakeController != null)
                DynamicBrakeController.SetValue(other.DynamicBrakePercent / 100);
            if (TrainBrakeController != null)
                TrainBrakeController.SetValue(((MSTSLocomotive)other).TrainBrakeController.CurrentValue);
            if (EngineBrakeController != null)
                EngineBrakeController.SetValue(0);
        }

        public bool controlUpdated;
        public bool notificationReceived;

        /// <summary>
        /// Called just after the InitializeFromWagFile
        /// </summary>
        public override void Initialize()
        {
            base.Initialize();
        }

        /// <summary>
        /// This is a periodic update to calculate physics 
        /// parameters and update the base class's MotiveForceN 
        /// and FrictionForceN values based on throttle settings
        /// etc for the locomotive.
        /// </summary>
        public override void Update(float elapsedClockSeconds)
        {
            TrainBrakeController.Update(elapsedClockSeconds);
            if (TrainBrakeController.UpdateValue > 0.0)
            {
                Simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatus());
            }

            if (TrainBrakeController.UpdateValue < 0.0)
            {
                Simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatus());
            }

            if (EngineBrakeController != null)
            {
                EngineBrakeController.Update(elapsedClockSeconds);
                if (EngineBrakeController.UpdateValue > 0.0)
                {
                    Simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
                }
                if (EngineBrakeController.UpdateValue < 0.0)
                {
                    Simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Decrease, GetEngineBrakeStatus());
                }
            }

            if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0))
            {
                if (!DynamicBrake)
                {
                    if (DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)
                    {
                        DynamicBrake = true; // Engage
                        if (IsLeadLocomotive())
                            Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                    }
                    else if (IsLeadLocomotive())
                        Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
                }
                else if (this.IsLeadLocomotive())
                    DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
                else
                    DynamicBrakeController.Update(elapsedClockSeconds);
            }
            else if ((DynamicBrakeController != null) && (DynamicBrakePercent < 0) && (DynamicBrake))
            {
                if (DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)
                {
                    DynamicBrake = false; // Disengage
                    if (IsLeadLocomotive())
                        Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.Off);
                }
                else if (IsLeadLocomotive())
                    Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
            }

            //Currently the ThrottlePercent is global to the entire train
            //So only the lead locomotive updates it, the others only updates the controller (actually useless)
            if (this.IsLeadLocomotive() || (!AcceptMUSignals))
            {
                ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
                ConfirmWheelslip();
                LocalThrottlePercent = ThrottlePercent;
            }
            else
            {
                ThrottleController.Update(elapsedClockSeconds);
            }


#if INDIVIDUAL_CONTROL

			//this train is remote controlled, with mine as a helper, so I need to send the controlling information, but not the force.
			if (MultiPlayer.MPManager.IsMultiPlayer() && this.Train.TrainType == Train.TRAINTYPE.REMOTE && this == Program.Simulator.PlayerLocomotive)
			{
				//cannot control train brake as it is the remote's job to do so
				if ((EngineBrakeController != null && EngineBrakeController.UpdateValue != 0.0) || (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0) || ThrottleController.UpdateValue != 0.0)
				{
					controlUpdated = true;
				}
				ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
				if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0)) DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
				return; //done, will go back and send the message to the remote train controller
			}

			if (MultiPlayer.MPManager.IsMultiPlayer() && this.notificationReceived == true)
			{
				ThrottlePercent = ThrottleController.CurrentValue * 100.0f;
				this.notificationReceived = false;
			}
#endif
            // TODO  this is a wild simplification for electric and diesel electric
            float t = ThrottlePercent / 100f;
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            float currentWheelSpeedMpS = Math.Abs(WheelSpeedMpS);
            //Only if a power is "ON" - pantograph up or diesel is running

            if (!this.Simulator.UseAdvancedAdhesion)
                currentWheelSpeedMpS = currentSpeedMpS;

            UpdateMotiveForce(elapsedClockSeconds, t, currentSpeedMpS, currentWheelSpeedMpS);

#if !NEW_SIGNALLING
            if (this.IsLeadLocomotive())
            {
                switch (Direction)
                {
                    case Direction.Forward:
                        //MotiveForceN *= 1;     //Not necessary
                        break;
                    case Direction.Reverse:
                        MotiveForceN *= -1;
                        break;
                    case Direction.N:
                    default:
                        MotiveForceN *= 0;
                        break;
                }
            }
            else
            {
                int carCount = 0;
                int controlEngine = -1;

                // When not LeadLocomotive; check if lead is in Neutral
                // if so this loco will have no motive force
                var LeadLocomotive = Program.Simulator.PlayerLocomotive.Train;

                foreach (TrainCar car in LeadLocomotive.Cars)
                {
                    if (car.IsDriveable)
                        if (controlEngine == -1)
                        {
                            controlEngine = carCount;
                            if (car.Direction == Direction.N)
                                MotiveForceN *= 0;
                            else
                            {
                                switch (Direction)
                                {
                                    case Direction.Forward:
                                        MotiveForceN *= 1;     //Not necessary
                                        break;
                                    case Direction.Reverse:
                                        MotiveForceN *= -1;
                                        break;
                                    case Direction.N:
                                    default:
                                        MotiveForceN *= 0;
                                        break;
                                }
                            }
                        }
                    break;
                } // foreach
            } // end when not lead loco
#else
            if (Train.TrainType == Train.TRAINTYPE.PLAYER) // for player locomotives
            {

                if (this.IsLeadLocomotive())
                {
                    switch (Direction)
                    {
                        case Direction.Forward:
                            //MotiveForceN *= 1;     //Not necessary
                            break;
                        case Direction.Reverse:
                            MotiveForceN *= -1;
                            break;
                        case Direction.N:
                        default:
                            MotiveForceN *= 0;
                            break;
                    }
                }
                else
                {
                    // When not LeadLocomotive; check if lead is in Neutral
                    // if so this loco will have no motive force

                    var LeadLocomotive = Program.Simulator.PlayerLocomotive;

                    if (LeadLocomotive == null) { }
                    else if (LeadLocomotive.Direction == Direction.N)
                        MotiveForceN *= 0;
                    else
                    {
                        switch (Direction)
                        {
                            case Direction.Forward:
                                MotiveForceN *= 1;     //Not necessary
                                break;
                            case Direction.Reverse:
                                MotiveForceN *= -1;
                                break;
                            case Direction.N:
                            default:
                                MotiveForceN *= 0;
                                break;
                        }
                    }


                } // end when not lead loco
            }// end Player locomotive

            else // for AI locomotives
            {
                switch (Direction)
                {
                    case Direction.Reverse:
                        MotiveForceN *= -1;
                        break;
                    default:
                        break;
                }
            }// end AI locomotive
#endif

            if (DynamicBrakePercent > 0 && DynamicBrakeForceCurves != null)
            {
                float f = DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, currentSpeedMpS);
                if (f > 0)
                    MotiveForceN -= (SpeedMpS > 0 ? 1 : -1) * f;
            }


            switch (this.Train.TrainType)
            {
                case Train.TRAINTYPE.AI:
                    if (!PowerOn)
                    {
                        PowerOn = true;
                        Pan = true;
                        Pan1Up = true;
                    }
                    //LimitMotiveForce(elapsedClockSeconds);    //calls the advanced physics
                    LimitMotiveForce();                         //let's call the basic physics instead for now
                    WheelSpeedMpS = Flipped ? -currentSpeedMpS : currentSpeedMpS;            //make the wheels go round
                    break;
                case Train.TRAINTYPE.STATIC:
                    break;
                case Train.TRAINTYPE.PLAYER:
                case Train.TRAINTYPE.REMOTE:
                    // For notched throttle controls (e.g. Dash 9 found on Marias Pass) UpdateValue is always 0.0
                    if (ThrottleController.UpdateValue != 0.0)
                    {
                        Simulator.Confirmer.UpdateWithPerCent(
                            this is MSTSSteamLocomotive ? CabControl.Regulator : CabControl.Throttle,
                            ThrottleController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            ThrottleController.CurrentValue * 100);
                    }
                    if (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0 && DynamicBrake)
                    {
                        Simulator.Confirmer.UpdateWithPerCent(
                            CabControl.DynamicBrake,
                            DynamicBrakeController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            DynamicBrakeController.CurrentValue * 100);
                    }

                    LimitMotiveForce(elapsedClockSeconds);

                    if (WheelslipCausesThrottleDown && WheelSlip)
                        ThrottleController.SetValue(0.0f);
                    //Force to display
                    FilteredMotiveForceN = CurrentFilter.Filter(MotiveForceN, elapsedClockSeconds);
                    break;
                default:
                    break;

            }
            if ((MainResPressurePSI < CompressorRestartPressurePSI) && (!CompressorIsOn) && (PowerOn))
                SignalEvent(Event.CompressorOn);
            else if (MainResPressurePSI > MaxMainResPressurePSI && CompressorIsOn)
                SignalEvent(Event.CompressorOff);
            if (CompressorIsOn)
                MainResPressurePSI += elapsedClockSeconds * MainResChargingRatePSIpS;

            if (Train.TrainType == Train.TRAINTYPE.PLAYER && this.IsLeadLocomotive())
                TrainControlSystem.Update();

            PrevMotiveForceN = MotiveForceN;
            base.Update(elapsedClockSeconds);
        } // End Method Update

        protected virtual void UpdateMotiveForce(float elapsedClockSeconds, float t, float currentSpeedMpS, float currentWheelSpeedMpS)
        {
            // Method to set force and power info
            // An alternative method in the steam locomotive will override this and input force and power info for it.
            if (PowerOn)
            {
                if (TractiveForceCurves == null)
                {
                    float maxForceN = MaxForceN * t;
                    float maxPowerW = MaxPowerW * t * t;

                    if (maxForceN * currentWheelSpeedMpS > maxPowerW)
                        maxForceN = maxPowerW / currentWheelSpeedMpS;
                    //if (currentSpeedMpS > MaxSpeedMpS)
                    //    maxForceN = 0;
                    if (currentSpeedMpS > MaxSpeedMpS - 0.05f)
                        maxForceN = 20 * (MaxSpeedMpS - currentSpeedMpS) * maxForceN;
                    if (currentSpeedMpS > (MaxSpeedMpS))
                        maxForceN = 0;
                    MotiveForceN = maxForceN;
                }
                else
                {
                    MotiveForceN = TractiveForceCurves.Get(t, currentWheelSpeedMpS);
                    if (MotiveForceN < 0)
                        MotiveForceN = 0;
                }
            }


            if (MaxForceN > 0 && MaxContinuousForceN > 0)
            {
                MotiveForceN *= 1 - (MaxForceN - MaxContinuousForceN) / (MaxForceN * MaxContinuousForceN) * AverageForceN;
                float w = (ContinuousForceTimeFactor - elapsedClockSeconds) / ContinuousForceTimeFactor;
                if (w < 0)
                    w = 0;
                AverageForceN = w * AverageForceN + (1 - w) * MotiveForceN;
            }
        }

        enum Wheelslip
        {
            None,
            Warning,
            Occurring
        };

        Wheelslip WheelslipState = Wheelslip.None;

        public void ConfirmWheelslip()
        {
            if (Simulator.UseAdvancedAdhesion)
            {
                // Wheelslip
                if (LocomotiveAxle.IsWheelSlip)
                {
                    if (WheelslipState != Wheelslip.Occurring)
                    {
                        WheelslipState = Wheelslip.Occurring;
                        Simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                    }
                }
                else
                {
                    if (LocomotiveAxle.IsWheelSlipWarning)
                    {
                        if (WheelslipState != Wheelslip.Warning)
                        {
                            WheelslipState = Wheelslip.Warning;
                            Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Warn1);
                        }
                    }
                    else
                    {
                        if (WheelslipState != Wheelslip.None)
                        {
                            WheelslipState = Wheelslip.None;
                            Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                        }
                    }
                }
            }
            else
            {
                if (WheelSlip && (WheelslipState != Wheelslip.Occurring))
                {
                    WheelslipState = Wheelslip.Occurring;
                    Simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                }
                if ((!WheelSlip) && (WheelslipState != Wheelslip.None))
                {
                    WheelslipState = Wheelslip.None;
                    Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                }
            }
        }

        /// <summary>
        /// Calls the Update method in the parent class MSTSWagon.
        /// </summary>
        /// <param name="elapsedClockSeconds"></param>
        protected void UpdateParent(float elapsedClockSeconds)
        {
            base.Update(elapsedClockSeconds);
        }

        /// <summary>
        /// Adjusts the MotiveForce to account for adhesion limits
        /// If UseAdvancedAdhesion is true, dynamic adhesion model is computed
        /// If UseAdvancedAdhesion is false, the basic force limits are calculated the same way MSTS calculates them, but
        /// the weather handleing is different and Curtius-Kniffler curves are considered as a static limit
        /// </summary>
        public void LimitMotiveForce(float elapsedClockSeconds)
        {
            float currentSpeedMpS = Math.Abs(SpeedMpS);

            if (NumWheelsAdhesionFactor <= 0)
            {
                WheelSpeedMpS = currentSpeedMpS;
                return;
            }

            //Curtius-Kniffler computation for the basic model
            float max0 = 1.0f;  //Adhesion conditions [N]

            if ((Simulator.UseAdvancedAdhesion) && (!Simulator.Paused) && (!AntiSlip))
            {
                //Set the weather coeff
                if (Program.Simulator.Weather == WeatherType.Rain || Program.Simulator.Weather == WeatherType.Snow)
                {
                    if (Train.SlipperySpotDistanceM < 0)
                    {
                        Train.SlipperySpotLengthM = 10 + 40 * (float)Program.Random.NextDouble();
                        Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Program.Random.NextDouble();
                    }
                    if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                        max0 = .8f;
                    if (Program.Simulator.Weather == WeatherType.Rain)
                        max0 = 0.6f;
                    else
                        max0 = 0.4f;
                }
                else
                    max0 = 1.0f;
                //add sander
                if (Math.Abs(SpeedMpS) < SanderSpeedOfMpS)
                {
                    if (SanderSpeedEffectUpToMpS > 0.0f)
                    {
                        if ((Sander) && (Math.Abs(SpeedMpS) < SanderSpeedEffectUpToMpS))
                        {
                            switch (Program.Simulator.Weather)
                            {
                                case WeatherType.Clear: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 1.2f; break;
                                case WeatherType.Rain: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 1.8f; break;
                                case WeatherType.Snow: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 2.5f; break;
                            }
                        }
                    }
                    else
                        if (Sander)
                        {
                            switch (Program.Simulator.Weather)
                            {
                                case WeatherType.Clear: max0 *= 1.2f; break;
                                case WeatherType.Rain: max0 *= 1.8f; break;
                                case WeatherType.Snow: max0 *= 2.5f; break;
                            }
                        }
                }

                //Set adhesion coeff to the model
                //Pure condition
                //LocomotiveAxle.AdhesionConditions = max0;
                //Filtered condition
                //LocomotiveAxle.AdhesionConditions = AdhesionFilter.Filter(max0, elapsedClockSeconds);
                //Filtered random condition
                LocomotiveAxle.AdhesionConditions = AdhesionFilter.Filter(max0 + (float)(0.2 * Program.Random.NextDouble()), elapsedClockSeconds);
                //LocomotiveAxle.AdhesionConditions = max0;
                //Set axle inertia (this should be placed within the ENG parser)
                // but make sure the value is sufficietn
                //if (MaxPowerW < 200000.0f)
                //{
                //    if (NumWheelsAdhesionFactor > 4.0f)
                //        LocomotiveAxle.InertiaKgm2 = 2.0f * NumWheelsAdhesionFactor * 4000.0f;
                //    else
                //        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                //}
                //else
                //{
                //    if (NumWheelsAdhesionFactor > 4.0f)
                //        LocomotiveAxle.InertiaKgm2 = 2.0f * NumWheelsAdhesionFactor * MaxPowerW / 500.0f;
                //    else
                //        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                //}

                //Compute axle inertia from parameters if possible
                if (AxleInertiaKgm2 > 10000.0f)
                {
                    LocomotiveAxle.InertiaKgm2 = AxleInertiaKgm2;
                }
                else
                {
                    if (WheelAxles.Count > 0 && DriverWheelRadiusM > 0)
                    {
                        float upperLimit = 2.0f * WheelAxles.Count * (15000.0f * DriverWheelRadiusM - 2900.0f);
                        upperLimit = upperLimit < 100.0f ? 100.0f : upperLimit;

                        float lowerLimit = WheelAxles.Count * (9000.0f * DriverWheelRadiusM - 1750.0f);
                        lowerLimit = lowerLimit < 100.0f ? 100.0f : lowerLimit;

                        LocomotiveAxle.InertiaKgm2 = (upperLimit - lowerLimit) / (5000000.0f) * MaxPowerW + lowerLimit;
                    }
                    else
                        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                }
                //Limit the inertia to 40000 kgm2
                LocomotiveAxle.InertiaKgm2 = LocomotiveAxle.InertiaKgm2 > 40000.0f ? 40000.0f : LocomotiveAxle.InertiaKgm2;

                LocomotiveAxle.AxleRevolutionsInt.MinStep = LocomotiveAxle.InertiaKgm2 / MaxPowerW / 5.0f;


                //Set axle model parameters

                //LocomotiveAxle.BrakeForceN = FrictionForceN;
                LocomotiveAxle.BrakeForceN = BrakeForceN;
                LocomotiveAxle.AxleWeightN = 9.81f * MassKG;        //will be computed each time considering the tilting
                LocomotiveAxle.DriveForceN = MotiveForceN;           //Developed force
                LocomotiveAxle.TrainSpeedMpS = SpeedMpS;            //Set the train speed of the axle model

                LocomotiveAxle.Update(elapsedClockSeconds);         //Main updater of the axle model

                MotiveForceN = LocomotiveAxle.AxleForceN;           //Get the Axle force and use it for the motion
                WheelSlip = LocomotiveAxle.IsWheelSlip;             //Get the wheelslip indicator
                WheelSlipWarning = LocomotiveAxle.IsWheelSlipWarning;
                WheelSpeedMpS = LocomotiveAxle.AxleSpeedMpS;
            }
            else
            {
                LimitMotiveForce();
            }
        }

        public void LimitMotiveForce()
        {
            if (NumWheelsAdhesionFactor <= 0)
                return;
            //float max0 = MassKG * 9.8f * Adhesion3 / NumWheelsAdhesionFactor;   //Not used

            //Curtius-Kniffler computation
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            float uMax = 1.3f * (7.5f / (currentSpeedMpS * 3.6f + 44.0f) + 0.161f); // Curtius - Kniffler equation
            float adhesionUtil = 0.95f;   //Adhesion utilization

            float max0 = MassKG * 9.81f * adhesionUtil * uMax;  //Ahesion limit in [N]
            float max1;

            if (Program.Simulator.Weather == WeatherType.Rain || Program.Simulator.Weather == WeatherType.Snow)
            {
                if (Train.SlipperySpotDistanceM < 0)
                {
                    Train.SlipperySpotLengthM = 10 + 40 * (float)Program.Random.NextDouble();
                    Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Program.Random.NextDouble();
                }
                if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                    max0 *= .8f;
                if (Program.Simulator.Weather == WeatherType.Rain)
                    max0 *= .8f;
                else
                    max0 *= .7f;
            }
            //float max1 = (Sander ? .95f : Adhesion2) * max0;  //Not used this way
            max1 = MaxForceN;
            //add sander
            if (Math.Abs(SpeedMpS) < SanderSpeedOfMpS)
            {
                if (SanderSpeedEffectUpToMpS > 0.0f)
                {
                    if ((Sander) && (Math.Abs(SpeedMpS) < SanderSpeedEffectUpToMpS))
                    {
                        switch (Program.Simulator.Weather)
                        {
                            case WeatherType.Clear: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 1.2f; break;
                            case WeatherType.Rain: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 1.8f; break;
                            case WeatherType.Snow: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 2.5f; break;
                        }
                    }
                }
                else
                    if (Sander)
                    {
                        switch (Program.Simulator.Weather)
                        {
                            case WeatherType.Clear: max0 *= 1.2f; break;
                            case WeatherType.Rain: max0 *= 1.8f; break;
                            case WeatherType.Snow: max0 *= 2.5f; break;
                        }
                    }
            }

            max1 = max0;

            WheelSlip = false;

            // always set AntiSlip for AI trains
            if (Train.TrainType == Train.TRAINTYPE.AI)
            {
                AntiSlip = true;
            }

            if (MotiveForceN > max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = max1;
                else
                    MotiveForceN = Adhesion1 * max0;        //Lowers the adhesion limit to 20% of its full
            }
            else if (MotiveForceN < -max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = -max1;
                else
                    MotiveForceN = -Adhesion1 * max0;       //Lowers the adhesion limit to 20% of its full
            }

            //This doesn't help at all, the force is already limited!!! The "AntiSlip = true;" statement is much better.
            // overrule wheelslip for AI trains
            if (Train.TrainType == Train.TRAINTYPE.AI)
            {
                WheelSlip = false;
            }
        }

        public override bool GetSanderOn()
        {
            return Sander;
        }

        public void SetDirection(Direction direction)
        {
            // Direction Control
            if (Direction != direction && ThrottlePercent < 1)
            {
                Direction = direction;
                switch (direction)
                {
                    case Direction.Reverse: SignalEvent(Event.ReverserToForwardBackward); break;
                    case Direction.N: SignalEvent(Event.ReverserToNeutral); break;
                    case Direction.Forward: SignalEvent(Event.ReverserToForwardBackward); break;
                }
                SignalEvent(Event.ReverserChange);
                if (direction == Direction.Forward)
                    Train.MUReverserPercent = 100;
                else
                    Train.MUReverserPercent = -100;
            }

#if !NEW_SIGNALLING
            if (direction == Direction.N)
            {
                Program.Simulator.AI.Dispatcher.ReleasePlayerAuthorization();
            }
            else
            {
                Program.Simulator.AI.Dispatcher.ExtendPlayerAuthorization(false);
            }
#endif
        }

        public virtual void StartReverseIncrease(float? target)
        {
            AlerterReset();
            if (this.IsLeadLocomotive())
            {
                {
                    switch (Direction)
                    {
                        case Direction.Reverse: SetDirection(Direction.N); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Neutral); break;
                        case Direction.N: SetDirection(Direction.Forward); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.On); break;
                        case Direction.Forward: SetDirection(Direction.Forward); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.On); break;
                    }
                }
            }
        }

        public virtual void StartReverseDecrease(float? target)
        {
            AlerterReset();
            if (this.IsLeadLocomotive())
            {
                {
                    switch (Direction)
                    {
                        case Direction.Reverse: SetDirection(Direction.Reverse); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Off); break;
                        case Direction.N: SetDirection(Direction.Reverse); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Off); break;
                        case Direction.Forward: SetDirection(Direction.N); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Neutral); break;
                    }
                }
            }
        }

        public void StartThrottleIncrease(float? target)
        {
            AlerterReset();
            ThrottleController.StartIncrease(target);
            //Not needed, Update() handles it:
            // Simulator.Confirmer.ConfirmWithPerCent( CabControl.Regulator, CabSetting.Increase, ThrottleController.CurrentValue * 100 );
            SignalEvent(Event.ThrottleChange);
        }

        public bool StartThrottleIncrease()
        {
            bool notchedThrottleCommandNeeded = false;
            AlerterReset();

            CommandStartTime = Simulator.ClockTime;

            if (!HasCombCtrl && DynamicBrakePercent >= 0
                || !(DynamicBrakePercent == -1 && !DynamicBrake || DynamicBrakePercent >= 0 && DynamicBrake))
                // signal sound
                return notchedThrottleCommandNeeded;

            float? smoothMax = ThrottleController.SmoothMax();

            if (HasCombCtrl && !HasCombThrottleTrainBrake && DynamicBrake)
            {
                StartDynamicBrakeDecrease(null);
                if (!HasSmoothStruc)
                    StopDynamicBrakeDecrease();
            }
            else if (smoothMax == null)
            {
                notchedThrottleCommandNeeded = true;
                SignalEvent(Event.ThrottleChange);
            }
            else
            {
                StartThrottleIncrease(smoothMax);
            }
            return notchedThrottleCommandNeeded;
        }

        public bool StopThrottleIncrease()
        {
            bool continuousThrottleCommandNeeded = false;

            AlerterReset();
            if (!HasCombCtrl && DynamicBrakePercent >= 0)
                // signal sound
                return continuousThrottleCommandNeeded;
            ThrottleController.StopIncrease();

            if (ThrottleController.SmoothMax() != null)
            {
                continuousThrottleCommandNeeded = true;
            }

            if (HasCombCtrl && !HasCombThrottleTrainBrake)
            {
                if (ThrottlePercent == 0)
                    StopDynamicBrakeDecrease();
            }
            return continuousThrottleCommandNeeded;
        }

        public void StartThrottleDecrease(float? target)
        {
            AlerterReset();
            CommandStartTime = Simulator.ClockTime;
            ThrottleController.StartDecrease(target);
            //Not needed, Update() handles it:
            //Simulator.Confirmer.ConfirmWithPerCent( CabControl.Regulator, CabSetting.Decrease, ThrottleController.CurrentValue * 100 );
            SignalEvent(Event.ThrottleChange);
        }

        public bool StartThrottleDecrease()
        {
            bool notchedThrottleCommandNeeded = false;
            AlerterReset();

            CommandStartTime = Simulator.ClockTime;

            if (!HasCombCtrl && DynamicBrakePercent >= 0
                || !(DynamicBrakePercent == -1 && !DynamicBrake || DynamicBrakePercent >= 0 && DynamicBrake))
                // signal sound
                return notchedThrottleCommandNeeded;

            float? smoothMin = ThrottleController.SmoothMin();

            if (HasCombCtrl && !HasCombThrottleTrainBrake && ThrottlePercent <= 0)
            {
                StartDynamicBrakeIncrease(null);
                if (!HasSmoothStruc)
                    StopDynamicBrakeIncrease();
            }
            else if (smoothMin == null)
            {
                notchedThrottleCommandNeeded = true;
                SignalEvent(Event.ThrottleChange);
            }
            else
            {
                StartThrottleDecrease(smoothMin);
            }
            return notchedThrottleCommandNeeded;
        }

        public bool StopThrottleDecrease()
        {
            bool continuousThrottleCommandNeeded = false;
            AlerterReset();

            if (!HasCombCtrl && DynamicBrakePercent >= 0)
                // signal sound
                return continuousThrottleCommandNeeded;

            ThrottleController.StopDecrease();

            if (ThrottleController.SmoothMin() != null)
            {
                continuousThrottleCommandNeeded = true;
            }

            if (HasCombCtrl && !HasCombThrottleTrainBrake)
            {
                if (ThrottlePercent == 0)
                    StopDynamicBrakeIncrease();
            }
            return continuousThrottleCommandNeeded;
        }

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        /// <param name="increase"></param>
        /// <param name="target"></param>
        public void ThrottleChangeTo(bool increase, float? target)
        {
            if (increase)
            {
                if (target > ThrottleController.CurrentValue)
                {
                    StartThrottleIncrease(target);
                }
            }
            else
            {
                if (target < ThrottleController.CurrentValue)
                {
                    StartThrottleDecrease(target);
                }
            }
        }

        /// <summary>
        /// Used by commands to make a single adjustment.
        /// </summary>
        /// <param name="increase"></param>
        /// <param name="target"></param>
        public void AdjustNotchedThrottle(bool increase)
        {
            if (increase)
            {
                ThrottleController.StartIncrease();
                ThrottleController.StopIncrease();
            }
            else
            {
                ThrottleController.StartDecrease();
                ThrottleController.StopDecrease();
            }
            Simulator.Confirmer.ConfirmWithPerCent(CabControl.Throttle, ThrottleController.CurrentValue * 100);
        }

        public void SetThrottlePercent(float percent)
        {
            ThrottlePercent = ThrottleController.SetRDPercent(percent);
        }

        public virtual void StartGearBoxIncrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StartIncrease();
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Increase, GearBoxController.CurrentNotch);
                AlerterReset();
            }

            var mstsDieselLocomotive = this as MSTSDieselLocomotive;
            if (mstsDieselLocomotive != null)
            {
                if (mstsDieselLocomotive.DieselEngines[0].GearBox != null)
                {
                    if (mstsDieselLocomotive.DieselEngines[0].GearBox.GearBoxOperation == GearBoxOperation.Semiautomatic)
                    {
                        mstsDieselLocomotive.DieselEngines[0].GearBox.AutoGearUp();
                        GearBoxController.SetValue((float)mstsDieselLocomotive.DieselEngines[0].GearBox.NextGearIndex);
                    }
                }
            }
        }

        public virtual void StopGearBoxIncrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StopIncrease();
            }
        }

        public virtual void StartGearBoxDecrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StartDecrease();
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Decrease, GearBoxController.CurrentNotch);
                AlerterReset();
            }

            var mstsDieselLocomotive = this as MSTSDieselLocomotive;
            if (mstsDieselLocomotive != null)
            {
                if (mstsDieselLocomotive.DieselEngines[0].GearBox != null)
                {
                    if (mstsDieselLocomotive.DieselEngines[0].GearBox.GearBoxOperation == GearBoxOperation.Semiautomatic)
                    {
                        mstsDieselLocomotive.DieselEngines[0].GearBox.AutoGearDown();
                        GearBoxController.SetValue((float)mstsDieselLocomotive.DieselEngines[0].GearBox.NextGearIndex);
                    }
                }
            }
        }

        public virtual void StopGearBoxDecrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StopDecrease();
            }
        }

        public void StartTrainBrakeIncrease(float? target)
        {
            AlerterReset();
            TrainBrakeController.StartIncrease(target);
            Simulator.Confirmer.Confirm(CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatus());
            SignalEvent(Event.TrainBrakeChange);
        }

        public void StopTrainBrakeIncrease()
        {
            AlerterReset();
            TrainBrakeController.StopIncrease();
        }

        public void StartTrainBrakeDecrease(float? target)
        {
            AlerterReset();
            TrainBrakeController.StartDecrease(target);
            Simulator.Confirmer.Confirm(CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatus());
            SignalEvent(Event.TrainBrakeChange);
        }

        public void StopTrainBrakeDecrease()
        {
            AlerterReset();
            TrainBrakeController.StopDecrease();
        }

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        /// <param name="increase"></param>
        /// <param name="target"></param>
        public void TrainBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number?
            if (increase)
            {
                if (target > TrainBrakeController.CurrentValue)
                {
                    StartTrainBrakeIncrease(target);
                }
            }
            else
            {
                if (target < TrainBrakeController.CurrentValue)
                {
                    StartTrainBrakeDecrease(target);
                }
            }
        }

        public void EngineBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (increase)
            {
                if (target > EngineBrakeController.CurrentValue)
                {
                    StartEngineBrakeIncrease(target);
                }
            }
            else
            {
                if (target < EngineBrakeController.CurrentValue)
                {
                    StartEngineBrakeDecrease(target);
                }
            }
        }

        public void DynamicBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (increase)
            {
                if (target > DynamicBrakeController.CurrentValue)
                {
                    StartDynamicBrakeIncrease(target);
                }
            }
            else
            {
                if (target < DynamicBrakeController.CurrentValue)
                {
                    StartDynamicBrakeDecrease(target);
                }
            }
        }

        public void SetTrainBrakePercent(float percent)
        {
            // Insure we have TrainBrakeController ; some vehicles do not
            // such as Hy-rail truck
            // if (HasTrainBrake)
            if (TrainBrakeController.IsValid())
                TrainBrakeController.SetRDPercent(percent);
        }

        public void SetEmergency()
        {
            if (this.Train != null && this.Train.TrainType == Train.TRAINTYPE.REMOTE) return; //not apply emergency for remote trains.
            TrainControlSystem.SetEmergency();
        }

        public override string GetTrainBrakeStatus()
        {
            string s = TrainBrakeController.GetStatus();
            TrainCar lastCar = Train.Cars[Train.Cars.Count - 1];
            if (lastCar == this)
                lastCar = Train.Cars[0];
            s += BrakeSystem.GetFullStatus(lastCar.BrakeSystem);
            return s;
        }

        public void StartEngineBrakeIncrease(float? target)
        {
            AlerterReset();
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StartIncrease(target);
            Simulator.Confirmer.Confirm(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
            SignalEvent(Event.EngineBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        /// <returns>true if action is completed</returns>
        public bool StopEngineBrakeIncrease()
        {
            bool engineBrakeCommandNeeded = false;

            AlerterReset();
            if (EngineBrakeController != null)
            {
                EngineBrakeController.StopIncrease();
                engineBrakeCommandNeeded = true;
            }
            return engineBrakeCommandNeeded;
        }

        public void StartEngineBrakeDecrease(float? target)
        {
            AlerterReset();
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StartDecrease(target);
            EngineBrakeController.CommandStartTime = Simulator.ClockTime; // Remember when the command was issued
            Simulator.Confirmer.Confirm(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
            SignalEvent(Event.EngineBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        /// <returns>true if action is completed</returns>
        public bool StopEngineBrakeDecrease()
        {
            bool engineBrakeCommandNeeded = false;

            AlerterReset();
            if (EngineBrakeController != null)
            {
                EngineBrakeController.StopDecrease();
                engineBrakeCommandNeeded = true;
            }
            return engineBrakeCommandNeeded;
        }

        public void SetEngineBrakePercent(float percent)
        {
            if (EngineBrakeController == null)
                return;
            EngineBrakeController.SetRDPercent(percent);
        }

        public override string GetEngineBrakeStatus()
        {
            if (EngineBrakeController == null)
                return null;
            return string.Format("{0}{1}", EngineBrakeController.GetStatus(), BailOff ? " BailOff" : "");
        }

        public void SetBailOff(bool bailOff)
        {
            BailOff = bailOff;
            Simulator.Confirmer.Confirm(CabControl.BailOff, bailOff ? CabSetting.On : CabSetting.Off);
        }

        private bool CanUseDynamicBrake()
        {
            return (DynamicBrakeController != null
                && ThrottlePercent == 0 && !HasDefectiveComboDynamicBreak);
        }

        public void StartDynamicBrakeIncrease(float? target)
        {
            AlerterReset();
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent < 0 && !DynamicBrake) // Activate
            {
                DynamicBrakePercent = 0;
                DynamicBrakeController.CommandStartTime = Simulator.ClockTime;
                StopDynamicBrakeIncrease();
            }
            else if (DynamicBrakePercent >= 0 && DynamicBrake)
            {
                SignalEvent(Event.DynamicBrakeChange);
                DynamicBrakeController.StartIncrease(target);
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeIncrease();
                    Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public bool StopDynamicBrakeIncrease()
        {
            bool dynamicBrakeCommandNeeded = false;

            AlerterReset();
            if (CanUseDynamicBrake())
            {
                DynamicBrakeController.StopIncrease();
                dynamicBrakeCommandNeeded = true;
            }
            return dynamicBrakeCommandNeeded;
        }

        public void StartDynamicBrakeDecrease(float? target)
        {
            AlerterReset();
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent <= 0 && DynamicBrake) // Deactivate
            {
                SignalEvent(Event.DynamicBrakeOff);
                DynamicBrakePercent = -1;
                DynamicBrakeController.CommandStartTime = Simulator.ClockTime;
                StopDynamicBrakeDecrease();
            }
            else if (DynamicBrakePercent >= 0 && DynamicBrake)
            {
                SignalEvent(Event.DynamicBrakeChange);
                DynamicBrakeController.StartDecrease(target);
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeDecrease();
                    Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public bool StopDynamicBrakeDecrease()
        {
            bool dynamicBrakeCommandNeeded = false;

            AlerterReset();
            if (CanUseDynamicBrake())
            {
                DynamicBrakeController.StopDecrease();
                dynamicBrakeCommandNeeded = true;
            }
            return dynamicBrakeCommandNeeded;
        }

        public void SetDynamicBrakePercent(float percent)
        {
            if (!CanUseDynamicBrake())
                return;
            DynamicBrakePercent = DynamicBrakeController.SetRDPercent(percent);
            if (percent < 0)
                DynamicBrakePercent = percent;
        }

        public override string GetDynamicBrakeStatus()
        {
            if (DynamicBrakeController == null)
                return null;
            if (DynamicBrakePercent < 0)
                return string.Empty;
            return string.Format("{0}", DynamicBrakeController.GetStatus());
        }

        public virtual void SetPower(bool ToState)
        {

        }

        internal void ToggleMUCommand(bool ToState)
        {
            AcceptMUSignals = ToState;
        }

        public void SetTrainHandbrake(bool apply)
        {
            if (apply)
            {
                Train.SetHandbrakePercent(100);
                Simulator.Confirmer.Confirm(CabControl.Handbrake, CabSetting.On);
            }
            else
            {
                Train.SetHandbrakePercent(0);
                Simulator.Confirmer.Confirm(CabControl.Handbrake, CabSetting.Off);
            }
        }

        public void SetTrainRetainers(bool apply)
        {
            Train.SetRetainers(apply);
            Simulator.Confirmer.ConfirmWithPerCent(CabControl.Retainers, CabSetting.Increase, Train.RetainerPercent, (int)CabSetting.Range1 + (int)Train.RetainerSetting);
        }

        public void BrakeHoseConnect(bool apply)
        {
            if (apply)
            {
                Train.ConnectBrakeHoses();
                Simulator.Confirmer.Confirm(CabControl.BrakeHose, CabSetting.On);
            }
            else
            {
                Train.DisconnectBrakes();
                Simulator.Confirmer.Confirm(CabControl.BrakeHose, CabSetting.Off);
            }
        }

        public void ToggleCabLight()
        {
            CabLightOn = !CabLightOn;
            SignalEvent(Event.LightSwitchToggle);
            Simulator.Confirmer.Confirm(CabControl.CabLight, CabLightOn ? CabSetting.On : CabSetting.Off);
        }

        public void ToggleWipers()
        {
            SignalEvent(Wiper ? Event.WiperOff : Event.WiperOn);
        }

        public virtual void Refuel()
        {
            // Electric locos do nothing. Diesel and steam override this.
        }
#if NEW_SIGNALLING
        public override bool GetCabFlipped()
        {
            return UsingRearCab;
        }
#endif

        public ScriptedTrainControlSystem TrainControlSystem;

        public void AlerterReset()
        {
            TrainControlSystem.AlerterReset();
        }

        public void AlerterPressed(bool pressed)
        {
            TrainControlSystem.AlerterPressed(pressed);
        }

        public override void SignalEvent(Event evt)
        {
            switch (evt)
            {
                case Event.VigilanceAlarmOn: { AlerterSnd = true; if (Simulator.Settings.Alerter) Simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.On); break; }
                case Event.VigilanceAlarmOff: { AlerterSnd = false; if (Simulator.Settings.Alerter) Simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.Off); break; }
                case Event.BellOn: { Bell = true; if (Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Bell, CabSetting.On); break; }
                case Event.BellOff: { Bell = false; Simulator.Confirmer.Confirm(CabControl.Bell, CabSetting.Off); break; }
                case Event.HornOn:
                case Event.HornOff:
                    Horn = evt == Event.HornOn;
                    if (DoesHornTriggerBell && Horn)
                        SignalEvent(Event.BellOn);
                    if (this == Program.Simulator.PlayerLocomotive)
                        Simulator.Confirmer.Confirm(this is MSTSSteamLocomotive ? CabControl.Whistle : CabControl.Horn, Horn ? CabSetting.On : CabSetting.Off);
                    break;
                case Event.SanderOn: { Sander = true; if (this.IsLeadLocomotive() && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Sander, CabSetting.On); break; }
                case Event.SanderOff: { Sander = false; if (this.IsLeadLocomotive()) Simulator.Confirmer.Confirm(CabControl.Sander, CabSetting.Off); break; }
                case Event.WiperOn: { Wiper = true; if (this == Program.Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Wipers, CabSetting.On); break; }
                case Event.WiperOff: { Wiper = false; if (this == Program.Simulator.PlayerLocomotive)  Simulator.Confirmer.Confirm(CabControl.Wipers, CabSetting.Off); break; }

                // <CJComment> The "H" key doesn't call these SignalEvents yet. </CJComment>
                case Event._HeadlightOff: { Headlight = 0; break; }
                case Event._HeadlightDim: { Headlight = 1; break; }
                case Event._HeadlightOn: { Headlight = 2; break; }

                case Event.CompressorOn: { CompressorIsOn = true; break; }
                case Event.CompressorOff: { CompressorIsOn = false; break; }
                case Event._ResetWheelSlip: { LocomotiveAxle.Reset(SpeedMpS); ThrottleController.SetValue(0.0f); break; }
            }

            base.SignalEvent(evt);
        }

        public virtual float GetDataOf(CabViewControl cvc)
        {
            float data = 0;
            switch (cvc.ControlType)
            {
                case CABViewControlTypes.SPEEDOMETER:
                    {
                        //data = SpeedMpS;
                        if (Simulator.UseAdvancedAdhesion && (!AntiSlip))
                            data = WheelSpeedMpS;
                        else
                            data = SpeedMpS;

                        if (cvc.Units == CABViewControlUnits.KM_PER_HOUR)
                            data *= 3.6f;
                        else // MPH
                            data *= 2.2369f;
                        data = Math.Abs(data);
                        break;
                    }
                case CABViewControlTypes.ACCELEROMETER:
                    {
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.METRES_SEC_SEC:
                                data = this.AccelerationMpSS;
                                break;

                            case CABViewControlUnits.METRES_SEC_HOUR:
                                data = this.AccelerationMpSS * 3600.0f;
                                break;

                            case CABViewControlUnits.KM_HOUR_SEC:
                                data = this.AccelerationMpSS * 3.6f;
                                break;

                            case CABViewControlUnits.KM_HOUR_HOUR:
                                data = this.AccelerationMpSS * 3.6f * 3600.0f;
                                break;

                            case CABViewControlUnits.MILES_HOUR_MIN:
                                data = this.AccelerationMpSS * 2.236936f * 60.0f;
                                break;

                            case CABViewControlUnits.MILES_HOUR_HOUR:
                                // 
                                data = this.AccelerationMpSS * 2.236936f * 3600.0f;
                                break;

                            default:
                                data = this.AccelerationMpSS;
                                break;

                        }
                        break;
                    }
                case CABViewControlTypes.AMMETER: // Current not modelled yet to ammeter shows tractive effort until then.
                case CABViewControlTypes.AMMETER_ABS:
                case CABViewControlTypes.LOAD_METER:
                case CABViewControlTypes.TRACTION_BRAKING:
                    {
                        if (LocomotiveAxle != null)
                        {
                            data = 0.0f;
                            if (ThrottlePercent > 0)
                            {
                                if (FilteredMotiveForceN != 0)
                                    data = this.FilteredMotiveForceN / MaxForceN * (float)(cvc.MaxValue);
                                else
                                    data = this.LocomotiveAxle.AxleForceN / MaxForceN * (float)(cvc.MaxValue);
                                data = Math.Abs(data);
                            }
                            if (DynamicBrakePercent > 0 && MaxDynamicBrakeForceN > 0)
                            {
                                float dynCurrRangeFactor = (float)(cvc.MinValue);
                                if (FilteredMotiveForceN != 0)
                                    data = this.FilteredMotiveForceN / MaxDynamicBrakeForceN * dynCurrRangeFactor;
                                else
                                    data = this.LocomotiveAxle.AxleForceN / MaxDynamicBrakeForceN * dynCurrRangeFactor;
                                data = -Math.Abs(data);
                            }
                            break;
                        }
                        data = this.MotiveForceN / MaxForceN * (float)cvc.MaxValue;
                        break;
                    }
                case CABViewControlTypes.MAIN_RES:
                    {
                        data = ConvertFromPSI(cvc, MainResPressurePSI);
                        break;
                    }
                case CABViewControlTypes.BRAKE_PIPE:
                    {
                        data = ConvertFromPSI(cvc, this.BrakeSystem.BrakeLine1PressurePSI);
                        break;
                    }
                case CABViewControlTypes.EQ_RES:
                    {
                        data = ConvertFromPSI(cvc, this.Train.BrakeLine1PressurePSIorInHg);
                        break;
                    }
                case CABViewControlTypes.BRAKE_CYL:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.GetCylPressurePSI());
                        break;
                    }
                case CABViewControlTypes.VACUUM_RESERVOIR_PRESSURE:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.GetVacResPressurePSI());
                        break;
                    }
                case CABViewControlTypes.RPM:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = mstsDieselLocomotive.DieselEngines[0].RealRPM;
                        break;
                    }
                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                case CABViewControlTypes.CPH_DISPLAY:
                    {
                        data = ThrottlePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.ENGINE_BRAKE:
                    {
                        data = (EngineBrakeController == null) ? 0.0f : EngineBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.FRICTION_BRAKING:
                case CABViewControlTypes.TRAIN_BRAKE:
                    {
                        data = (TrainBrakeController == null) ? 0.0f : TrainBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.DYNAMIC_BRAKE:
                case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                    //case CABViewControlTypes.CP_HANDLE:
                    {
                        data = DynamicBrakePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.WIPERS:
                    {
                        data = Wiper ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.HORN:
                    {
                        data = Horn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.BELL:
                    {
                        data = Bell ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.SMALL_EJECTOR:
                    {
                        data = CompressorIsOn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.RESET:
                    {
                        if (TrainControlSystem.AlerterButtonPressed)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }

                case CABViewControlTypes.ALERTER_DISPLAY:
                    {
                        if (Simulator.Settings.Alerter)
                        {
                            if (TrainControlSystem.VigilanceEmergency)
                                data = 2;
                            else if (TrainControlSystem.VigilanceAlarm)
                                data = 1;
                            else
                                data = 0;
                        }
                        break;
                    }
                case CABViewControlTypes.OVERSPEED:
                    {
                        data = TrainControlSystem.OverspeedWarning ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.PENALTY_APP:
                    {
                        data = TrainControlSystem.PenaltyApplication ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.EMERGENCY_BRAKE:
                    {
                        data = EmergencyButtonPressed ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.DOORS_DISPLAY:
                    {
                        data = DoorLeftOpen | DoorRightOpen ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.SANDERS:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                // MultStateDisplay entry in CVF file had Type SANDING. W/O the below entry and another entry at line 3625
                // the independant sanding light found in some cabs would not work.
                case CABViewControlTypes.SANDING:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.CLOCK:
                    {
                        data = 0;
                        break;
                    }

                case CABViewControlTypes.FRONT_HLIGHT:
                    {
                        data = Headlight;
                        break;
                    }
                case CABViewControlTypes.WHEELSLIP:
                    {
                        if (Simulator.UseAdvancedAdhesion)
                            data = LocomotiveAxle.IsWheelSlipWarning ? 1 : 0;
                        else
                            data = WheelSlip ? 1 : 0;
                        break;
                    }

                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                    {
                        if (Direction == Direction.Forward)
                            data = 2;
                        else if (Direction == Direction.Reverse)
                            data = 0;
                        else
                            data = 1;
                        break;
                    }
                case CABViewControlTypes.ASPECT_DISPLAY:
                    {
                        switch (TrainControlSystem.CabSignalAspect)
                        {
                            case TrackMonitorSignalAspect.Stop:
                                {
                                    data = 0;
                                    break;
                                }
                            case TrackMonitorSignalAspect.StopAndProceed:
                                {
                                    data = 1;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Restricted:
                                {
                                    data = 2;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach_1:
                                {
                                    data = 3;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach_2:
                                {
                                    data = 4;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach_3:
                                {
                                    data = 5;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Clear_1:
                                {
                                    data = 6;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Clear_2:
                                {
                                    data = 7;
                                    break;
                                }
                            default:
                                {
                                    data = 7;
                                    break;
                                }
                        }
                        break;
                    }
                case CABViewControlTypes.SPEEDLIMIT:
                    {
                        // Displays current allowable speed
                        bool metric = cvc.Units == CABViewControlUnits.KM_PER_HOUR;
                        data = MpS.FromMpS(TrainControlSystem.CurrentSpeedLimitMpS, metric);
                        break;
                    }
                case CABViewControlTypes.SPEEDLIM_DISPLAY:
                    {
                        // Displays allowable speed shown on next signal
                        bool metric = cvc.Units == CABViewControlUnits.KM_PER_HOUR;
                        data = MpS.FromMpS(TrainControlSystem.NextSpeedLimitMpS, metric);
                        break;
                    }
                default:
                    {
                        data = 0;
                        break;
                    }
            }
            return data;
        }

        protected static float ConvertFromPSI(CabViewControl cvc, float data)
        {
            if (cvc.Units == CABViewControlUnits.BAR)
                data *= 68.948e-3f;
            else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                data *= 6.89476f;
            else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                data *= 70.307e-3f;
            else if (cvc.Units == CABViewControlUnits.INCHES_OF_MERCURY)
                data *= 2.04177f;
            return data;
        }
        
        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual void RefillImmediately()
        {
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual MSTSNotchController GetRefillController(uint type)
        {
            return null;
        }

        // Make the vehicle num wheels available to other classes
        public override float GetLocoNumWheels()
        {

            float LocoNumDrvWheels = NumWheelsAdhesionFactor;

        //    Trace.TraceInformation("Trace Locom {0}", LocoNumDrvWheels);

            return LocoNumDrvWheels;
        }
        
        // Pass the string wagon type to other classes
        public override string GetEngineType()
        {
          EngineType ="";  // set default
          
          if (IsSteam)
          {
          EngineType ="Steam";  // set as steam locomotive
          }
          
          if (IsElectric)
          {
          EngineType ="Electric";  // set as Electric locomotive
          }
          
          if (IsDiesel)
          {
          EngineType ="Diesel";  // set as diesel locomotive
          }

          return EngineType;
        }
        
        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual float GetFilledFraction(uint pickupType)
        {
            return 0f;
        }

        /// <summary>
        /// Starts a continuous increase in controlled value.
        /// </summary>
        /// <param name="type">Pickup point</param>
        public void StartRefilling(uint type)
        {
            var controller = GetRefillController(type);
            controller.CommandStartTime = Simulator.ClockTime;  // for Replay to use 
            controller.StartIncrease(controller.MaximumValue);
        }

        /// <summary>
        /// Ends a continuous increase in controlled value.
        /// </summary>
        public void StopRefilling(uint type, CommandLog log)
        {
            var controller = GetRefillController(type);
            new RefillCommand(log, controller.CurrentValue, controller.CommandStartTime);  // for Replay to use
            controller.StopIncrease();
        }
    } // End Class MSTSLocomotive

    public class CabView
    {
        public CVFFile CVFFile;
        public List<ViewPoint> ViewPointList;
        public ExtendedCVF ExtendedCVF;

        public CabView(CVFFile cvfFile, List<ViewPoint> viewPointList, ExtendedCVF extendedCVF)
        {
            CVFFile = cvfFile;
            ViewPointList = viewPointList;
            ExtendedCVF = extendedCVF;
        }
    }

    /// <summary>
    /// Extended CVF data, currently used for CAB light
    /// By GeorgeS
    /// </summary>
    [ORTSPhysicsFile("lit", "ORTSExtendedCVF")]
    public class ExtendedCVF
    {
        /// <summary>
        /// Translate to current screen resolution
        /// </summary>
        /// <param name="displaySize">Current screen resolution</param>
        /// <returns>Translated vectors</returns>
        public static Vector4 TranslatedPosition(Vector4 Position, Point displaySize)
        {
            return new Vector4(Position.X / 640 * displaySize.X,
                Position.Y / 480 * displaySize.Y,
                Position.Z / 640 * displaySize.X,
                Position.W);
        }

        /// <summary>
        /// Used by the shader
        /// </summary>
        public static Vector3 TranslatedColor(Color Color)
        {
            return new Vector3((float)Color.R / 255, (float)Color.G / 255, (float)Color.B / 255);
        }

        [ORTSPhysics("First light Position", "Light1Position", "The position and aspect of the first cab light", "320 360 155 2")]
        public Vector4 Light1Position;

        [ORTSPhysics("First light ARGB", "Light1ColorARGB", "The color of the first cab light", "255 216 178 255")]
        public Color Light1Color;

        [ORTSPhysics("Second light Position", "Light2Position", "The position and aspect of the first cab light", "0 0 0 0")]
        public Vector4 Light2Position;

        [ORTSPhysics("Second light ARGB", "Light2ColorARGB", "The color of the second cab light", "0 0 0")]
        public Color Light2Color;

    } // End Class ExtendedCVF
}
