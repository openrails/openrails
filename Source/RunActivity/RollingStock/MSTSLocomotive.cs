/* LOCOMOTIVE CLASSES
 * 
 * Used a a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  LocomotiveSimulator - defines the behaviour, ie physics, motion, power generated etc
 *  LocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCarSimulator - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */
/// COPYRIGHT 2009 by the Open Rails project.
/// This code is provided to enable you to contribute improvements to the open rails program.  
/// Use of the code for any other purpose or distribution of the code to anyone else
/// is prohibited without specific written permission from admin@openrails.org.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MSTS;



namespace ORTS
{

    ///////////////////////////////////////////////////
    ///   SIMULATION BEHAVIOUR
    ///////////////////////////////////////////////////


    /// <summary>
    /// Adds Throttle, Direction, Horn, Sander and Wiper control
    /// to the basic TrainCar.
    /// Use as a base for Electric, Diesel or Steam locomotives.
    /// </summary>
    public class MSTSLocomotive: MSTSWagon
    {
        // simulation parameters
        public bool Horn = false;
        public bool Bell = false;
        public bool Sander = false;  
        public bool Wiper = false;
        public bool BailOff = false;
        public float MaxPowerW;
        public float MaxForceN;
        public float MaxSpeedMpS = 1e3f;
        public float MainResPressurePSI = 130;
        public bool CompressorOn = false;
        public float AverageForceN = 0;
        // by GeorgeS
        public bool CabLightOn = false;
        public bool ShowCab = true;

        // wag file data
        public string CabSoundFileName = null;
        public string CVFFileName = null;
        public float MaxMainResPressurePSI = 130;
        public float MainResVolumeFT3 = 10;
        public float CompressorRestartPressurePSI = 110;
        public float MainResChargingRatePSIpS = .4f;
        public float EngineBrakeReleaseRatePSIpS = 12.5f;
        public float EngineBrakeApplyRatePSIpS = 12.5f;
        public float BrakePipeTimeFactorS = .003f;
        public float BrakeServiceTimeFactorS = 1.009f;
        public float BrakeEmergencyTimeFactorS = .1f;
        public float BrakePipeChargingRatePSIpS = Program.BrakePipeChargingRatePSIpS;
        public Interpolator2D TractiveForceCurves = null;
        public Interpolator2D DynamicBrakeForceCurves = null;
        public float DynamicBrakeSpeed1 = 3;
        public float DynamicBrakeSpeed2 = 18;
        public float DynamicBrakeSpeed3 = 23;
        public float DynamicBrakeSpeed4 = 35;
        public float MaxDynamicBrakeForceN = 0;
        public bool DynamicBrakeAutoBailOff = false;
        public float MaxContinuousForceN;
        public float ContinuousForceTimeFactor = 1800;

        public CVFFile CVFFile = null;

        public MSTSNotchController  ThrottleController;
        public MSTSBrakeController  TrainBrakeController;
        public MSTSBrakeController  EngineBrakeController;
        public AirSinglePipe.ValveState EngineBrakeState = AirSinglePipe.ValveState.Lap;
        public MSTSNotchController  DynamicBrakeController;

        public MSTSLocomotive(string wagPath, TrainCar previousCar)
            : base(wagPath, previousCar)
        {
            //Console.WriteLine("loco {0} {1} {2}", MaxPowerW, MaxForceN, MaxSpeedMpS);
        }

        /// <summary>
        /// This initializer is called when we haven't loaded this type of car before
        /// and must read it new from the wag file.
        /// </summary>
        public override void InitializeFromWagFile(string wagFilePath)
        {
            TrainBrakeController = new MSTSBrakeController();
            EngineBrakeController = new MSTSBrakeController();
            DynamicBrakeController = new MSTSNotchController();
            base.InitializeFromWagFile(wagFilePath);

            if (ThrottleController == null)
            {
                //If no controller so far, we create a default one
                ThrottleController = new MSTSNotchController();
                ThrottleController.StepSize = 0.1f;
            }

            if (CVFFileName != null)
            {
                string CVFFilePath = Path.GetDirectoryName(WagFilePath) + @"\CABVIEW\" + CVFFileName;
                CVFFile = new CVFFile(CVFFilePath);

                // Set up camera locations for the cab views
                for( int i = 0; i < CVFFile.Locations.Count; ++i )
                {
                    if (i >= CVFFile.Locations.Count || i >= CVFFile.Directions.Count)
                    {
                        Trace.TraceError("Position or Direction missing in " + CVFFilePath);
                        break;
                    }
                    ViewPoint viewPoint = new ViewPoint();
                    viewPoint.Location = CVFFile.Locations[i];
                    viewPoint.StartDirection = CVFFile.Directions[i];
                    viewPoint.RotationLimit = new Vector3( 0,0,0 );  // cab views have a fixed head position
                    FrontCabViewpoints.Add(viewPoint);
                }
            }

            IsDriveable = true;
            if (!TrainBrakeController.IsValid())
                TrainBrakeController = new MSTSBrakeController(); //create a blank one
            if (!EngineBrakeController.IsValid())
                EngineBrakeController = null;
            if (!DynamicBrakeController.IsValid())
                DynamicBrakeController = null;
            if (DynamicBrakeForceCurves == null && MaxDynamicBrakeForceN > 0)
            {
                DynamicBrakeForceCurves = new Interpolator2D(2);
                Interpolator interp = new Interpolator(2);
                interp[0] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[0] = interp;
                interp = new Interpolator(4);
                interp[DynamicBrakeSpeed1] = 0;
                interp[DynamicBrakeSpeed2] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed3] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4] = 0;
                DynamicBrakeForceCurves[1] = interp;
            }
        }

        /// <summary>
        /// Parse the wag file parameters required for the simulator and viewer classes
        /// </summary>
        public override void Parse(string lowercasetoken, STFReader f)
        {
            if (lowercasetoken.StartsWith("engine(trainbrakescontroller"))
                TrainBrakeController.ParseBrakeValue(lowercasetoken.Substring(28), f);
            if (lowercasetoken.StartsWith("engine(enginebrakescontroller"))
                EngineBrakeController.ParseBrakeValue(lowercasetoken.Substring(29), f);
            switch (lowercasetoken)
            {
                case "engine(sound": CabSoundFileName = f.ReadStringBlock(); break;
                case "engine(cabview": CVFFileName = f.ReadStringBlock(); break;
                case "engine(maxpower": MaxPowerW = ParseW(f.ReadStringBlock(),f); break;
                case "engine(maxforce": MaxForceN = ParseN(f.ReadStringBlock(),f); break;
                case "engine(maxcontinuousforce": MaxContinuousForceN = ParseN(f.ReadStringBlock(), f); break;
                case "engine(maxvelocity": MaxSpeedMpS = ParseMpS(f.ReadStringBlock(),f); break;
                case "engine(enginecontrollers(throttle": ThrottleController = new MSTSNotchController(f); break;
                case "engine(enginecontrollers(regulator": ThrottleController = new MSTSNotchController(f); break;
                case "engine(enginecontrollers(brake_train": TrainBrakeController.Parse(f); break;
                case "engine(enginecontrollers(brake_engine": EngineBrakeController.Parse(f); break;
                case "engine(enginecontrollers(brake_dynamic": DynamicBrakeController.Parse(f); break;
                case "engine(airbrakesmainresvolume": MainResVolumeFT3 = f.ReadFloatBlock(); break;
                case "engine(airbrakesmainmaxairpressure": MainResPressurePSI = MaxMainResPressurePSI = f.ReadFloatBlock(); break;
                case "engine(airbrakescompressorrestartpressure": CompressorRestartPressurePSI = f.ReadFloatBlock(); break;
                case "engine(mainreschargingrate": MainResChargingRatePSIpS = f.ReadFloatBlock(); break;
                case "engine(enginebrakereleaserate": EngineBrakeReleaseRatePSIpS = f.ReadFloatBlock(); break;
                case "engine(enginebrakeapplicationrate": EngineBrakeApplyRatePSIpS = f.ReadFloatBlock(); break;
                case "engine(brakepipetimefactor": BrakePipeTimeFactorS = f.ReadFloatBlock(); break;
                case "engine(brakeservicetimefactor": BrakeServiceTimeFactorS = f.ReadFloatBlock(); break;
                case "engine(brakeemergencytimefactor": BrakeEmergencyTimeFactorS = f.ReadFloatBlock(); break;
                case "engine(brakepipechargingrate": BrakePipeChargingRatePSIpS = f.ReadFloatBlock(); break;
                case "engine(maxtractiveforcecurves": TractiveForceCurves = new Interpolator2D(f); break;
                case "engine(dynamicbrakeforcecurves": DynamicBrakeForceCurves = new Interpolator2D(f); break;
                case "engine(dynamicbrakesminusablespeed": DynamicBrakeSpeed1 = f.ReadFloatBlock(); break;
                case "engine(dynamicbrakesfadingspeed": DynamicBrakeSpeed2 = f.ReadFloatBlock(); break;
                case "engine(dynamicbrakesmaximumeffectivespeed": DynamicBrakeSpeed3 = f.ReadFloatBlock(); break;
                case "engine(dynamicbrakesmaximumspeedforfadeout": DynamicBrakeSpeed4 = f.ReadFloatBlock(); break;
                case "engine(dynamicbrakesmaximumforce": MaxDynamicBrakeForceN = f.ReadFloatBlock(); break;
                case "engine(dynamicbrakeshasautobailoff": DynamicBrakeAutoBailOff = f.ReadBoolBlock(); break;
                case "engine(continuousforcetimefactor": ContinuousForceTimeFactor = f.ReadFloatBlock(); break;
                default: base.Parse(lowercasetoken, f); break;
            }
        }

        /// <summary>
        /// This initializer is called when we are making a new copy of a car already
        /// loaded in memory.  We use this one to speed up loading by eliminating the
        /// need to parse the wag file multiple times.
        /// </summary>
        public override void InitializeFromCopy(MSTSWagon copy)
        {
            MSTSLocomotive locoCopy = (MSTSLocomotive)copy;
            CabSoundFileName = locoCopy.CabSoundFileName;
            CVFFileName = locoCopy.CVFFileName;
            CVFFile = locoCopy.CVFFile;
            MaxPowerW = locoCopy.MaxPowerW;
            MaxForceN = locoCopy.MaxForceN;
            MaxSpeedMpS = locoCopy.MaxSpeedMpS;
            TractiveForceCurves = locoCopy.TractiveForceCurves;
            MaxContinuousForceN = locoCopy.MaxContinuousForceN;
            ContinuousForceTimeFactor = locoCopy.ContinuousForceTimeFactor;
            DynamicBrakeForceCurves = locoCopy.DynamicBrakeForceCurves;
            DynamicBrakeAutoBailOff = locoCopy.DynamicBrakeAutoBailOff;

            IsDriveable = copy.IsDriveable;
            //ThrottleController = MSTSEngineController.Copy(locoCopy.ThrottleController);
            ThrottleController = (MSTSNotchController)locoCopy.ThrottleController.Clone();
            TrainBrakeController = (MSTSBrakeController)locoCopy.TrainBrakeController.Clone();
            EngineBrakeController = locoCopy.EngineBrakeController != null ? (MSTSBrakeController)locoCopy.EngineBrakeController.Clone() : null;
            DynamicBrakeController = locoCopy.DynamicBrakeController != null ? (MSTSNotchController)locoCopy.DynamicBrakeController.Clone() : null;

            base.InitializeFromCopy(copy);  // each derived level initializes its own variables
        }

        /// <summary>
        /// We are saving the game.  Save anything that we'll need to restore the 
        /// status later.
        /// </summary>
        public override void Save(BinaryWriter outf)
        {
            // we won't save the horn state
            outf.Write(Bell);
            outf.Write(Sander);
            outf.Write(Wiper);
            outf.Write(MainResPressurePSI);
            outf.Write(CompressorOn);
            outf.Write(AverageForceN);
            ControllerFactory.Save(ThrottleController, outf);
            ControllerFactory.Save(TrainBrakeController, outf);
            ControllerFactory.Save(EngineBrakeController, outf);
            ControllerFactory.Save(DynamicBrakeController, outf);            
            base.Save(outf);
        }

        /// <summary>
        /// We are restoring a saved game.  The TrainCar class has already
        /// been initialized.   Restore the game state.
        /// </summary>
        public override void Restore(BinaryReader inf)
        {
            if (inf.ReadBoolean()) SignalEvent(EventID.BellOn);
            if (inf.ReadBoolean()) SignalEvent(EventID.SanderOn);
            if (inf.ReadBoolean()) SignalEvent(EventID.WiperOn);
            MainResPressurePSI = inf.ReadSingle();
            CompressorOn = inf.ReadBoolean();
            AverageForceN = inf.ReadSingle();
            ThrottleController = (MSTSNotchController)ControllerFactory.Restore(inf);
            TrainBrakeController = (MSTSBrakeController)ControllerFactory.Restore(inf);
            EngineBrakeController = (MSTSBrakeController)ControllerFactory.Restore(inf);
            DynamicBrakeController = (MSTSNotchController)ControllerFactory.Restore(inf);
            base.Restore(inf);
        }

        public bool IsLeadLocomotive()
        {
            return Train.LeadLocomotive == this;
        }


        /// <summary>
        /// Create a viewer for this locomotive.   Viewers are only attached
        /// while the locomotive is in viewing range.
        /// </summary>
        public override TrainCarViewer GetViewer(Viewer3D viewer)
        {
            return new MSTSLocomotiveViewer(viewer, this);
        }

        /// <summary>
        /// This is a periodic update to calculate physics 
        /// parameters and update the base class's MotiveForceN 
        /// and FrictionForceN values based on throttle settings
        /// etc for the locomotive.
        /// </summary>
        public override void Update(float elapsedClockSeconds)
        {
            TrainBrakeController.Update(elapsedClockSeconds);
            if (EngineBrakeController != null)
                EngineBrakeController.Update(elapsedClockSeconds);

            if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0))
            {
                if (this.IsLeadLocomotive())
                    DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
                else
                    DynamicBrakeController.Update(elapsedClockSeconds);
            }

            //Currently the ThrottlePercent is global to the entire train
            //So only the lead locomotive updates it, the others only updates the controller (actually useless)
            if (this.IsLeadLocomotive())
                ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
            else
                ThrottleController.Update(elapsedClockSeconds);

            // TODO  this is a wild simplification for electric and diesel electric
            float t = ThrottlePercent / 100f;
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            if (TractiveForceCurves == null)
            {
                float maxForceN = MaxForceN * t;
                float maxPowerW = MaxPowerW * t * t;
                if (maxForceN * currentSpeedMpS > maxPowerW)
                    maxForceN = maxPowerW / currentSpeedMpS;
                if (currentSpeedMpS > MaxSpeedMpS)
                    maxForceN= 0;
                MotiveForceN = maxForceN;
            }
            else
            {
                MotiveForceN = TractiveForceCurves.Get(t, currentSpeedMpS);
                if (MotiveForceN < 0)
                    MotiveForceN = 0;
            }

            MotiveForceN *= 1 - (MaxForceN - MaxContinuousForceN) / (MaxForceN * MaxContinuousForceN) * AverageForceN;
            float w = (ContinuousForceTimeFactor - elapsedClockSeconds) / ContinuousForceTimeFactor;
            if (w < 0)
                w = 0;
            AverageForceN = w * AverageForceN + (1 - w) * MotiveForceN;
            MotiveForceN *= (Direction == Direction.Forward ? 1 : -1);

            // Variable1 is wheel rotation in m/sec for steam locomotives
            //Variable2 = Math.Abs(MotiveForceN) / MaxForceN;   // force generated
            Variable1 = ThrottlePercent / 100f;   // throttle setting

            if (DynamicBrakePercent > 0 && DynamicBrakeForceCurves != null)
            {
                float f= DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, currentSpeedMpS);
                if (f > 0)
                    MotiveForceN -= (SpeedMpS > 0 ? 1 : -1) * f;
            }

            if (MainResPressurePSI < CompressorRestartPressurePSI && !CompressorOn)
                SignalEvent(EventID.CompressorOn);
            else if (MainResPressurePSI > MaxMainResPressurePSI && CompressorOn)
                SignalEvent(EventID.CompressorOff);
            if (CompressorOn)
                MainResPressurePSI += elapsedClockSeconds * MainResChargingRatePSIpS;

            base.Update(elapsedClockSeconds);
        }

        public void SetDirection( Direction direction )
        {
            // Direction Control
            if ( Direction != direction && ThrottlePercent < 1)
            {
                Direction = direction;
                if (direction == Direction.Forward)
                {
                    SignalEvent(EventID.Forward);
                    Train.MUReverserPercent = 100;
                }
                else
                {
                    SignalEvent(EventID.Reverse);
                    Train.MUReverserPercent = -100;
                }
            }
        }        

        public void StartThrottleIncrease()
        {
            if (DynamicBrakePercent >= 0)
            {
                // signal sound
                return;
            }
            ThrottleController.StartIncrease();

            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.PowerHandler);
        }

        public void StopThrottleIncrease()
        {
            if (DynamicBrakePercent >= 0)
            {
                // signal sound
                return;
            }

            ThrottleController.StopIncrease();
        }

        public void StartThrottleDecrease()
        {
            if (DynamicBrakePercent >= 0)
            {
                // signal sound
                return;
            }
            ThrottleController.StartDecrease();

            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.PowerHandler);
        }

        public void StopThrottleDecrease()
        {
            if (DynamicBrakePercent >= 0)
            {
                // signal sound
                return;
            }

            ThrottleController.StopDecrease();
        }

        public void StartTrainBrakeIncrease()
        {
            TrainBrakeController.StartIncrease();
            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.TrainBrakeSet);
        }

        public void StopTrainBrakeIncrease()
        {
            TrainBrakeController.StopIncrease();
        }

        public void StartTrainBrakeDecrease()
        {
            TrainBrakeController.StartDecrease();
            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.TrainBrakeSet);
        }

        public void StopTrainBrakeDecrease()
        {
            TrainBrakeController.StopDecrease();
        }        

        public void SetEmergency()
        {           
            TrainBrakeController.SetEmergency();
            SignalEvent(EventID.TrainBrakeEmergency);
        }
        public override string GetTrainBrakeStatus()
        {            
            string s = TrainBrakeController.GetStatus();
            if (BrakeSystem.GetType() == typeof(AirSinglePipe))
                s += string.Format(" EQ {0:F0} ", Train.BrakeLine1PressurePSI);
            else
                s += string.Format(" {0:F0} ", Train.BrakeLine1PressurePSI);
            s += BrakeSystem.GetStatus(1);
            TrainCar lastCar = Train.Cars[Train.Cars.Count - 1];
            if (lastCar == this)
                lastCar = Train.Cars[0];
            if (lastCar != this)
                s = s + " " + lastCar.BrakeSystem.GetStatus(0);
            return s;
        }

        public void StartEngineBrakeIncrease()
        {
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StartIncrease();
        }

        public void StopEngineBrakeIncrease()
        {
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StopIncrease();
        }

        public void StartEngineBrakeDecrease()
        {
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StartDecrease();
        }

        public void StopEngineBrakeDecrease()
        {
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StopDecrease();
        }
  
        public override string GetEngineBrakeStatus()
        {
            if (EngineBrakeController == null)
                return null;
            return string.Format("{0}{1}", EngineBrakeController.GetStatus(), BailOff ? " BailOff" : "");
        }

        public void ToggleBailOff()
        {
            BailOff = !BailOff;
        }

        private bool CanUseDynamicBrake()
        {
            return (DynamicBrakeController != null && DynamicBrakeForceCurves != null && ThrottlePercent == 0);
        }

        public void StartDynamicBrakeIncrease()
        {
            if(!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent < 0)
            {
                //activate it
                DynamicBrakePercent = 0;
                return;
            }
            else
                DynamicBrakeController.StartIncrease();
        }

        public void StopDynamicBrakeIncrease()
        {
            if (!CanUseDynamicBrake())
                return;

            DynamicBrakeController.StopIncrease();
        }

        public void StartDynamicBrakeDecrease()
        {
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent <= 0)
                DynamicBrakePercent = -1;
            else
            {
                DynamicBrakeController.StartDecrease();
            }
        }

        public void StopDynamicBrakeDecrease()
        {
            if (!CanUseDynamicBrake())
                return;

            DynamicBrakeController.StopDecrease();
        }

        public override string GetDynamicBrakeStatus()
        {
            if (DynamicBrakeController == null || DynamicBrakePercent < 0)
                return null;
            return string.Format("{0}", DynamicBrakeController.GetStatus());
        }
        
        /// <summary>
        /// Used when someone want to notify us of an event
        /// </summary>
        public override void SignalEvent(EventID eventID)
        {
            // Modified according to replacable IDs - by GeorgeS
            //switch (eventID)
            do
            {
                if (eventID == EventID.BellOn) { Bell = true; break; }
                if (eventID == EventID.BellOff) {  Bell = false; break; }
                if (eventID == EventID.HornOn) { Horn = true; break; }
                if (eventID == EventID.HornOff) { Horn = false; break; }
                if (eventID == EventID.SanderOn) { Sander = true; break; }
                if (eventID == EventID.SanderOff) { Sander = false; break; }
                if (eventID == EventID.WiperOn) { Wiper = true; break; }
                if (eventID == EventID.WiperOff) { Wiper = false; break; }
                if (eventID == EventID.HeadlightOff) { Headlight = 0; break; }
                if (eventID == EventID.HeadlightDim) { Headlight = 1; break; }
                if (eventID == EventID.HeadlightOn) {  Headlight = 2; break; }
                if (eventID == EventID.CompressorOn) { CompressorOn = true; break; }
                if (eventID == EventID.CompressorOff) { CompressorOn = false; break; }
                if (eventID == EventID.LightSwitchToggle) { CabLightOn = !CabLightOn; break; }
            } while (false);

            base.SignalEvent(eventID );
        }

        /// <summary>
        /// Gets the Locomotive data needed by the Cav View Control
        /// </summary>
        /// <param name="cvc">The Cab View Control</param>
        /// <returns>The data converted to the requested unit</returns>
        public virtual float GetDataOf(CabViewControl cvc)
        {
            float data;
            switch (cvc.ControlType)
            {
                case CABViewControlTypes.SPEEDOMETER:
                    {
                        data = SpeedMpS;
                        if (cvc.Units == CABViewControlUnits.KM_PER_HOUR)
                            data *= 3.6f;
                        else
                            data *= 2.2369f;

                        break;
                    }
                case CABViewControlTypes.AMMETER:
                    {
                        data = this.MotiveForceN / MaxForceN * (float)cvc.MaxValue;
                        break;
                    }
                case CABViewControlTypes.MAIN_RES:
                    {
                        data = this.MainResPressurePSI;
                        if (cvc.Units == CABViewControlUnits.BAR)
                            data *= 68.948e-3f;
                        else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                            data *= 6.89476f;
                        else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                            data *= 70.307e-3f;
                        break;
                    }
                case CABViewControlTypes.BRAKE_PIPE:
                case CABViewControlTypes.EQ_RES:
                    {
                        data = this.BrakeSystem.BrakeLine1PressurePSI;
                        if (cvc.Units == CABViewControlUnits.BAR)
                            data *= 68.948e-3f;
                        else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                            data *= 6.89476f;
                        else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                            data *= 70.307e-3f;
                        break;
                    }
                case CABViewControlTypes.BRAKE_CYL:
                    {
                        AirSinglePipe asp = BrakeSystem as AirSinglePipe;
                        if (asp != null)
                        {
                            data = asp.CylPSIPressure;
                            if (cvc.Units == CABViewControlUnits.BAR)
                                data *= 68.948e-3f;
                            else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                                data *= 6.89476f;
                            else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                                data *= 70.307e-3f;
                        }
                        else
                        {
                            data = 0;
                        }
                        break;
                    }
                default:
                    {
                        data = 0;
                        break;
                    }
            }
            return data;
        }

    } // LocomotiveSimulator

    ///////////////////////////////////////////////////
    ///   3D VIEW
    ///////////////////////////////////////////////////

    /// <summary>
    /// Adds animation for wipers to the basic TrainCar
    /// </summary>
    public class MSTSLocomotiveViewer : MSTSWagonViewer
    {
        MSTSLocomotive Locomotive;

        List<int> WiperPartIndexes = new List<int>();

        float WiperAnimationKey = 0;

        protected MSTSLocomotive MSTSLocomotive { get { return (MSTSLocomotive)Car; } }

        private CabRenderer _CabRenderer = null;

        public MSTSLocomotiveViewer(Viewer3D viewer, MSTSLocomotive car)
            : base(viewer, car)
        {
            Locomotive = car;

            if (car.CVFFile != null && car.CVFFile.TwoDViews.Count > 0)
                _CabRenderer = new CabRenderer(viewer, Locomotive);

            // Find the animated parts
            if (TrainCarShape.SharedShape.Animations != null)
            {
				for (int iMatrix = 0; iMatrix < TrainCarShape.SharedShape.MatrixNames.Count; ++iMatrix)
                {
                    string matrixName = TrainCarShape.SharedShape.MatrixNames[iMatrix].ToUpper();
                    switch (matrixName)
                    {
                        case "WIPERARMLEFT1":
                        case "WIPERBLADELEFT1":
                        case "WIPERARMRIGHT1":
                        case "WIPERBLADERIGHT1":
                            if (TrainCarShape.SharedShape.Animations[0].FrameCount > 1)  // ensure shape file is properly animated for wipers
                                WiperPartIndexes.Add(iMatrix);
                            break;
                        case "MIRRORARMLEFT1":
                        case "MIRRORLEFT1":
                        case "MIRRORARMRIGHT1":
                        case "MIRRORRIGHT1":
                            // TODO
                            break;
                    }
                }
            }

            string wagonFolderSlash = Path.GetDirectoryName(Locomotive.WagFilePath) + "\\";
            if (Locomotive.CabSoundFileName != null) LoadCarSound(wagonFolderSlash, Locomotive.CabSoundFileName);

        }

        /// <summary>
        /// A keyboard or mouse click has occurred. Read the UserInput
        /// structure to determine what was pressed.
        /// </summary>
        public override void HandleUserInput(ElapsedTime elapsedTime)
        {
            if (UserInput.IsPressed(UserCommands.ControlForwards)) Locomotive.SetDirection(Direction.Forward);
			if (UserInput.IsPressed(UserCommands.ControlBackwards)) Locomotive.SetDirection(Direction.Reverse);

			if (UserInput.IsPressed(UserCommands.ControlThrottleIncrease)) Locomotive.StartThrottleIncrease();
			if (UserInput.IsReleased(UserCommands.ControlThrottleIncrease)) Locomotive.StopThrottleIncrease();
			if (UserInput.IsPressed(UserCommands.ControlThrottleDecrease)) Locomotive.StartThrottleDecrease();
			if (UserInput.IsReleased(UserCommands.ControlThrottleDecrease)) Locomotive.StopThrottleDecrease();

			if (UserInput.IsPressed(UserCommands.ControlTrainBrakeIncrease)) Locomotive.StartTrainBrakeIncrease();
			if (UserInput.IsReleased(UserCommands.ControlTrainBrakeIncrease)) Locomotive.StopTrainBrakeIncrease();
			if (UserInput.IsPressed(UserCommands.ControlTrainBrakeDecrease)) Locomotive.StartTrainBrakeDecrease();
			if (UserInput.IsReleased(UserCommands.ControlTrainBrakeDecrease)) Locomotive.StopTrainBrakeDecrease();

			if (UserInput.IsPressed(UserCommands.ControlEngineBrakeIncrease)) Locomotive.StartEngineBrakeIncrease();
			if (UserInput.IsReleased(UserCommands.ControlEngineBrakeIncrease)) Locomotive.StopEngineBrakeIncrease();
			if (UserInput.IsPressed(UserCommands.ControlEngineBrakeDecrease)) Locomotive.StartEngineBrakeDecrease();
			if (UserInput.IsReleased(UserCommands.ControlEngineBrakeDecrease)) Locomotive.StopEngineBrakeDecrease();

			if (UserInput.IsPressed(UserCommands.ControlDynamicBrakeIncrease)) Locomotive.StartDynamicBrakeIncrease();
			if (UserInput.IsReleased(UserCommands.ControlDynamicBrakeIncrease)) Locomotive.StopDynamicBrakeIncrease();
			if (UserInput.IsPressed(UserCommands.ControlDynamicBrakeDecrease)) Locomotive.StartDynamicBrakeDecrease();
			if (UserInput.IsReleased(UserCommands.ControlDynamicBrakeDecrease)) Locomotive.StopDynamicBrakeDecrease();

			if (UserInput.IsPressed(UserCommands.ControlBailOff)) Locomotive.ToggleBailOff();
			if (UserInput.IsPressed(UserCommands.ControlInitializeBrakes)) Locomotive.Train.InitializeBrakes();
			if (UserInput.IsPressed(UserCommands.ControlHandbrakeNone)) Locomotive.Train.SetHandbrakePercent(0);
			if (UserInput.IsPressed(UserCommands.ControlHandbrakeFull)) Locomotive.Train.SetHandbrakePercent(100);
			if (UserInput.IsPressed(UserCommands.ControlRetainersOff)) Locomotive.Train.SetRetainers(false);
			if (UserInput.IsPressed(UserCommands.ControlRetainersOn)) Locomotive.Train.SetRetainers(true);
			if (UserInput.IsPressed(UserCommands.ControlBrakeHoseConnect)) Locomotive.Train.ConnectBrakeHoses();
			if (UserInput.IsPressed(UserCommands.ControlBrakeHoseDisconnect)) Locomotive.Train.DisconnectBrakes();
			if (UserInput.IsPressed(UserCommands.ControlEmergency)) Locomotive.SetEmergency();
			if (UserInput.IsPressed(UserCommands.ControlSander)) Locomotive.Train.SignalEvent(Locomotive.Sander ? EventID.SanderOff : EventID.SanderOn);
			if (UserInput.IsPressed(UserCommands.ControlWiper)) Locomotive.SignalEvent(Locomotive.Wiper ? EventID.WiperOff : EventID.WiperOn);
			if (UserInput.IsPressed(UserCommands.ControlHorn)) Locomotive.SignalEvent(EventID.HornOn);
			if (UserInput.IsReleased(UserCommands.ControlHorn)) Locomotive.SignalEvent(EventID.HornOff);
			if (UserInput.IsPressed(UserCommands.ControlBell)) Locomotive.SignalEvent(EventID.BellOn);
			if (UserInput.IsReleased(UserCommands.ControlBell)) Locomotive.SignalEvent(EventID.BellOff);
			if (UserInput.IsPressed(UserCommands.ControlHeadlightDecrease))
            {
                switch ((Locomotive.Headlight))
                {
                    case 1: Locomotive.Headlight = 0; break;
                    case 2: Locomotive.Headlight = 1; break;
                }
                // By GeorgeS
                if (EventID.IsMSTSBin)
                    Locomotive.SignalEvent(EventID.LightSwitchToggle);
            }
			else if (UserInput.IsPressed(UserCommands.ControlHeadlightIncrease))
            {
                switch ((Locomotive.Headlight))
                {
                    case 0: Locomotive.Headlight = 1; break;
                    case 1: Locomotive.Headlight = 2; break;
                }
                // By GeorgeS
                if (EventID.IsMSTSBin)
                    Locomotive.SignalEvent(EventID.LightSwitchToggle);
            }
			if (UserInput.IsPressed(UserCommands.ControlDispatcherExtend))
                Program.Simulator.AI.Dispatcher.ExtendPlayerAuthorization();
			if (UserInput.IsPressed(UserCommands.ControlDispatcherRelease))
                Program.Simulator.AI.Dispatcher.ReleasePlayerAuthorization();

            // By GeorgeS
			if (UserInput.IsPressed(UserCommands.ControlLight)) Locomotive.SignalEvent(EventID.LightSwitchToggle);
            if (UserInput.IsPressed(UserCommands.CameraShowCab)) Locomotive.ShowCab = !Locomotive.ShowCab;
			base.HandleUserInput(elapsedTime);
        }

        /// <summary>
        /// We are about to display a video frame.  Calculate positions for 
        /// animated objects, and add their primitives to the RenderFrame list.
        /// </summary>
        public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
        {
            float elapsedClockSeconds = elapsedTime.ClockSeconds;
            // Wiper animation
            if (WiperPartIndexes.Count > 0)  // skip this if there are no wipers
            {
                if (Locomotive.Wiper) // on
                {
                    // Wiper Animation
                    // Compute the animation key based on framerate etc
                    // ie, with 8 frames of animation, the key will advance from 0 to 8 at the specified speed.
                    WiperAnimationKey += ((float)TrainCarShape.SharedShape.Animations[0].FrameRate / 10f) * elapsedClockSeconds;
                    while (WiperAnimationKey >= TrainCarShape.SharedShape.Animations[0].FrameCount) WiperAnimationKey -= TrainCarShape.SharedShape.Animations[0].FrameCount;
                    while (WiperAnimationKey < -0.00001) WiperAnimationKey += TrainCarShape.SharedShape.Animations[0].FrameCount;
                    foreach (int iMatrix in WiperPartIndexes)
                        TrainCarShape.AnimateMatrix(iMatrix, WiperAnimationKey);
                }
                else // off
                {
                    if (WiperAnimationKey > 0.001)  // park the blades
                    {
                        WiperAnimationKey += ((float)TrainCarShape.SharedShape.Animations[0].FrameRate / 10f) * elapsedClockSeconds;
                        if (WiperAnimationKey >= TrainCarShape.SharedShape.Animations[0].FrameCount) WiperAnimationKey = 0;
                        foreach (int iMatrix in WiperPartIndexes)
                            TrainCarShape.AnimateMatrix(iMatrix, WiperAnimationKey);
                    }
                }
            }

            // Draw 2D CAB View - by GeorgeS
            if (Viewer.Camera.AttachedCar == this.MSTSWagon &&
                Viewer.Camera.Style == Camera.Styles.Cab &&
                _CabRenderer != null)
                _CabRenderer.PrepareFrame(frame);
            
            base.PrepareFrame( frame, elapsedTime );
        }


        /// <summary>
        /// This doesn't function yet.
        /// </summary>
        public override void Unload()
        {
            base.Unload();
        }

    } // Class LocomotiveViewer

    // By GeorgeS
    /// <summary>
    /// Manages all CAB View textures - light conditions and texture parts
    /// </summary>
    public static class CABTextureManager
    {
        private static Dictionary<string, Texture2D> DayTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D> NightTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D> LightTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D[]> PDayTextures = new Dictionary<string, Texture2D[]>();
        private static Dictionary<string, Texture2D[]> PNightTextures = new Dictionary<string, Texture2D[]>();
        private static Dictionary<string, Texture2D[]> PLightTextures = new Dictionary<string, Texture2D[]>();

        /// <summary>
        /// Loads a texture, day night and cablight
        /// </summary>
        /// <param name="viewer">Viver3D</param>
        /// <param name="FileName">Name of the Texture</param>
        public static void LoadTextures(Viewer3D viewer, string FileName)
        {
            if (string.IsNullOrEmpty(FileName))
                return;

            if (DayTextures.Keys.Contains(FileName))
                return;

            Texture2D tex;

            if (File.Exists(FileName))
            {
                tex = SharedTextureManager.Get(viewer.GraphicsDevice, FileName);
                DayTextures.Add(FileName, tex);
            }
            else
                DayTextures.Add(FileName, Materials.MissingTexture);

            string nightpath = FileName.Substring(0, FileName.LastIndexOf('\\')) + "\\night" + FileName.Substring(FileName.LastIndexOf('\\'));
            if (File.Exists(nightpath))
            {
                tex = SharedTextureManager.Get(viewer.GraphicsDevice, nightpath);
                NightTextures.Add(FileName, tex);
            }
            else
                NightTextures.Add(FileName, Materials.MissingTexture);

            string lightpath = FileName.Substring(0, FileName.LastIndexOf('\\')) + "\\cablight" + FileName.Substring(FileName.LastIndexOf('\\'));
            if (File.Exists(lightpath))
            {
                tex = SharedTextureManager.Get(viewer.GraphicsDevice, nightpath);
                LightTextures.Add(FileName, tex);
            }
            else
                LightTextures.Add(FileName, Materials.MissingTexture);
        }

        /// <summary>
        /// Disassembles a compund Texture into parts
        /// </summary>
        /// <param name="graphicsDevice">The GraphicsDevice</param>
        /// <param name="tex">Texture to be disassembled</param>
        /// <param name="width">Width of the Cab View Control</param>
        /// <param name="height">Height of the Cab View Control</param>
        /// <returns>Array with Textures disassembled</returns>
        private static Texture2D[] Disassemble(GraphicsDevice graphicsDevice, Texture2D tex, int width, int height)
        {
            Texture2D dtex;
            Color[] arr = new Color[width * height];

            int wcou = tex.Width / width;
            int hcou = tex.Height / height;

            Texture2D[] dest = new Texture2D[wcou * hcou];
            int indx = 0;

            for (int j = 0; j < hcou; j++)
            {
                for (int i = 0; i < wcou; i++)
                {
                    tex.GetData<Color>(0, new Rectangle(i * width, j * height, width, height),
                        arr, 0, width * height);

                    dtex = new Texture2D(graphicsDevice, width, height);
                    dtex.SetData<Color>(arr);
                    dest[indx] = dtex;
                    indx++;
                }
            }
            return dest;
        }
        
        /// <summary>
        /// Disassembles all compund textures into parts
        /// </summary>
        /// <param name="graphicsDevice">The GraphicsDevice</param>
        /// <param name="FileName">Name of the Texture to be disassembled</param>
        /// <param name="width">Width of the Cab View Control</param>
        /// <param name="height">Height of the Cab View Control</param>
        public static void DisassembleTexture(GraphicsDevice graphicsDevice, string FileName, int width, int height)
        {
            PDayTextures[FileName] = null;
            if (DayTextures.ContainsKey(FileName))
            {
                var tex = DayTextures[FileName];
                if (tex != Materials.MissingTexture)
                {
                    PDayTextures[FileName] = Disassemble(graphicsDevice, tex, width, height);
                }
            }

            PNightTextures[FileName] = null;
            if (NightTextures.ContainsKey(FileName))
            {
                var tex = NightTextures[FileName];
                if (tex != Materials.MissingTexture)
                {
                    PNightTextures[FileName] = Disassemble(graphicsDevice, tex, width, height);
                }
            }

            PLightTextures[FileName] = null;
            if (LightTextures.ContainsKey(FileName))
            {
                var tex = LightTextures[FileName];
                if (tex != Materials.MissingTexture)
                {
                    PLightTextures[FileName] = Disassemble(graphicsDevice, tex, width, height);
                }
            }
        }

        /// <summary>
        /// Returns the compound part of a Texture previously disassembled
        /// </summary>
        /// <param name="FileName">Name of the disassembled Texture</param>
        /// <param name="indx">Index of the part</param>
        /// <param name="isDark">Is dark out there?</param>
        /// <param name="isLight">Is Cab Light on?</param>
        /// <returns>The Texture represented by its index</returns>
        public static Texture2D GetTextureByIndexes(string FileName, int indx, bool isDark, bool isLight)
        {
            Texture2D retval = Materials.MissingTexture;
            Texture2D[] tmp = null;

            if (string.IsNullOrEmpty(FileName) || !PDayTextures.Keys.Contains(FileName))
                return Materials.MissingTexture;

            if (isDark)
            {
                if (isLight)
                {
                    tmp = PLightTextures[FileName];
                    if (tmp != null)
                    {
                        indx = (int)MathHelper.Clamp(indx, 0, tmp.Length);
                        retval = tmp[indx];
                    }
                }

                if (retval == Materials.MissingTexture)
                {
                    tmp = PNightTextures[FileName];
                    if (tmp != null)
                    {
                        indx = (int)MathHelper.Clamp(indx, 0, tmp.Length);
                        retval = tmp[indx];
                    }
                }
            }

            if (retval == Materials.MissingTexture)
            {
                tmp = PDayTextures[FileName];
                if (tmp != null)
                {
                    indx = (int)MathHelper.Clamp(indx, 0, tmp.Length);
                    retval = tmp[indx];
                }
            }
            return retval;
        }

        /// <summary>
        /// Returns a Texture by its name
        /// </summary>
        /// <param name="FileName">Name of the Texture</param>
        /// <param name="isDark">Is dark out there?</param>
        /// <param name="isLight">Is Cab Light on?</param>
        /// <returns>The Texture</returns>
        public static Texture2D GetTexture(string FileName, bool isDark, bool isLight)
        {
            Texture2D retval = Materials.MissingTexture;

            if (string.IsNullOrEmpty(FileName) || !DayTextures.Keys.Contains(FileName))
                return retval;

            if (isDark)
            {
                if (isLight)
                {
                    retval = LightTextures[FileName];
                }

                if (retval == Materials.MissingTexture)
                {
                    retval = NightTextures[FileName];
                }
            }

            if (retval == Materials.MissingTexture)
            {
                retval = DayTextures[FileName];
            }

            return retval;
        }
    }

    public class CabRenderer : RenderPrimitive
    {
        private SpriteBatchMaterial _Sprite2DCabView;
        private Rectangle _CabRect;
        private Matrix _Scale = Matrix.Identity;
        private Texture2D _CabTexture;

        private CabViewControls CabViewControls;
        private List<CabViewControlRenderer> CabViewControlRenderers = new List<CabViewControlRenderer>();

        private Viewer3D _Viewer;
        private MSTSLocomotive _Locomotive;
        private int _Location;

        public CabRenderer(Viewer3D viewer, MSTSLocomotive car)
        {
			//Sequence = RenderPrimitiveSequence.CabView;
            _Sprite2DCabView = new SpriteBatchMaterial(viewer.RenderProcess);

            // Loading ACE files, skip displaying ERROR messages
            foreach (string cabfile in car.CVFFile.TwoDViews)
            {
                CABTextureManager.LoadTextures(viewer, cabfile);
            }

            CabViewControls = car.CVFFile.CabViewControls;
            if (CabViewControls != null)
            {
                foreach (CabViewControl cvc in CabViewControls)
                {
                    CVCDial dial = cvc as CVCDial;
                    if (dial != null)
                    {
                        CabViewDialRenderer cvcr = new CabViewDialRenderer(dial, viewer, car);
                        CabViewControlRenderers.Add(cvcr);
                        continue;
                    }
                    CVCGauge gauge = cvc as CVCGauge;
                    if (gauge != null)
                    {
                        CabViewGaugeRenderer cvgr = new CabViewGaugeRenderer(gauge, viewer, car);
                        CabViewControlRenderers.Add(cvgr);
                        continue;
                    }
                    CVCSignal asp = cvc as CVCSignal;
                    if (asp != null)
                    {
                        CabViewDiscreteRenderer aspr = new CabViewDiscreteRenderer(asp, viewer, car);
                        CabViewControlRenderers.Add(aspr);
                        continue;
                    }
                    CVCMultiStateDisplay multi = cvc as CVCMultiStateDisplay;
                    if (multi != null)
                    {
                        CabViewDiscreteRenderer mspr = new CabViewDiscreteRenderer(multi, viewer, car);
                        CabViewControlRenderers.Add(mspr);
                        continue;
                    }
                    CVCDiscrete disc = cvc as CVCDiscrete;
                    if (disc != null)
                    {
                        CabViewDiscreteRenderer cvdr = new CabViewDiscreteRenderer(disc, viewer, car);
                        CabViewControlRenderers.Add(cvdr);
                        continue;
                    }
                    CVCDigital digital = cvc as CVCDigital;
                    if (digital != null)
                    {
                        CabViewDigitalRenderer cvdr = new CabViewDigitalRenderer(digital, viewer, car);
                        CabViewControlRenderers.Add(cvdr);
                        continue;
                    }
                }
            }

            _Viewer = viewer;
            _Locomotive = car;
        }

        public void PrepareFrame(RenderFrame frame)
        {
            if (!_Locomotive.ShowCab)
                return;

            bool Dark = Materials.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            CabCamera cbc = _Viewer.Camera as CabCamera;
            if (cbc != null)
            {
                _Location = cbc.SideLocation;
            }
            else
            {
                _Location = 0;
            }

            _CabTexture = CABTextureManager.GetTexture(_Locomotive.CVFFile.TwoDViews[_Location], Dark, CabLight);

            if (_CabTexture == Materials.MissingTexture)
                return;

            _CabRect = new Rectangle(0, 0, (int)_Viewer.DisplaySize.X, (int)_Viewer.DisplaySize.Y);
            frame.AddPrimitive(_Sprite2DCabView, this, RenderPrimitiveGroup.Cab, ref _Scale);

            if (_Location == 0)
            {
                foreach (CabViewControlRenderer cvcr in CabViewControlRenderers)
                {
                    cvcr.PrepareFrame(frame);
                }
            }
        }
        
        public override void Draw(GraphicsDevice graphicsDevice)
        {
            _Sprite2DCabView.SpriteBatch.Draw(_CabTexture, _CabRect, Color.White);
        }
    }

    /// <summary>
    /// Base class for rendering Cab Controls
    /// </summary>
    public class CabViewControlRenderer : RenderPrimitive
    {
        protected CabViewControl _CabViewControl;
        protected SpriteBatchMaterial _Sprite2DCtlView;
        protected Matrix _Matrix = Matrix.Identity;
        protected Texture2D _Texture;
        protected Viewer3D _Viewer;
        protected MSTSLocomotive _Locomotive;

        protected Vector2 _Position;

        public CabViewControlRenderer(CabViewControl cvc, Viewer3D viewer, MSTSLocomotive car)
        {
            _CabViewControl = cvc;
            _Sprite2DCtlView = new SpriteBatchMaterial(viewer.RenderProcess);

            CABTextureManager.LoadTextures(viewer, _CabViewControl.ACEFile);

            _Viewer = viewer;
            _Locomotive = car;
        }

        /// <summary>
        /// Gets the requested Locomotive data and translates it into percents by Min and Max values
        /// </summary>
        /// <param name="cvc">Cab View Control</param>
        /// <returns>Percent of real data by Min and Max values</returns>
        public float TranslateToPercent()
        {
            float data = _Locomotive.GetDataOf(_CabViewControl);
            if (data < _CabViewControl.MinValue)
                return 0;
            if (data > _CabViewControl.MaxValue)
                return 1;

            return (float)((data - _CabViewControl.MinValue) / (_CabViewControl.MaxValue - _CabViewControl.MinValue));
        }

        public virtual void PrepareFrame(RenderFrame frame)
        {
            frame.AddPrimitive(_Sprite2DCtlView, this, RenderPrimitiveGroup.Cab, ref _Matrix);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
        }
    }

    /// <summary>
    /// Dial Cab Control Renderer
    /// Problems with aspect ratio
    /// </summary>
    public class CabViewDialRenderer : CabViewControlRenderer
    {
        private float _Rotation = 0f;
        private float _ScaleToScreen = 1f;
        private Vector2 _Origin;
        private CVCDial _Dial;
        protected float _Scale = 1f;

        public CabViewDialRenderer(CVCDial dial, Viewer3D viewer, MSTSLocomotive car)
            : base (dial, viewer, car)
        {
            _Dial = dial;
            _Origin = new Vector2((float)(_Dial.Width / 2), _Dial.Center);

            _Texture = CABTextureManager.GetTexture(_CabViewControl.ACEFile, false, false);
            _Scale = (float)(_Dial.Height / _Texture.Height);
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            bool Dark = Materials.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            _Texture = CABTextureManager.GetTexture(_CabViewControl.ACEFile, Dark, CabLight);

            if (_Texture == Materials.MissingTexture)
                return;

            base.PrepareFrame(frame);

            _Position = new Vector2((float)(_Viewer.DisplaySize.X / 640 * (_CabViewControl.PositionX + _Origin.X)),
                (float)(_Viewer.DisplaySize.Y / 480 * (_CabViewControl.PositionY + _Origin.Y)));

            _ScaleToScreen = _Viewer.DisplaySize.Y / 480 * _Scale;

            float percent = TranslateToPercent();
            float range;

            if ((_Dial.FromDegree > _Dial.ToDegree && _Dial.Direction == 0) ||
                (_Dial.ToDegree > _Dial.FromDegree && _Dial.Direction != 0))
            {
                range = 360 - _Dial.FromDegree + _Dial.ToDegree;
            }
            else
            {
                range = _Dial.ToDegree - _Dial.FromDegree;
            }

            float degree = range * percent;

            if (_Dial.Direction == 0)
                degree = _Dial.FromDegree + degree;
            else
                degree = _Dial.ToDegree - degree;

            _Rotation = MathHelper.ToRadians(degree);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            _Sprite2DCtlView.SpriteBatch.Draw(_Texture, _Position, null, Color.White, _Rotation, _Origin, _ScaleToScreen, SpriteEffects.None, 0);
        }
    }

    /// <summary>
    /// Gauge type renderer
    /// Supports pointer, liquid, solid
    /// Supports Orientation and Direction
    /// </summary>
    public class CabViewGaugeRenderer : CabViewControlRenderer
    {
        private CVCGauge _Gauge;
        protected Rectangle _SourceRectangle;
        protected Rectangle _DestRectangle;

        public CabViewGaugeRenderer(CVCGauge gauge, Viewer3D viewer, MSTSLocomotive car)
            : base(gauge, viewer, car)
        {
            _Gauge = gauge;
            _SourceRectangle = _Gauge.Area;
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            bool Dark = Materials.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            _Texture = CABTextureManager.GetTexture(_CabViewControl.ACEFile, Dark, CabLight);

            if (_Texture == Materials.MissingTexture)
                return;

            base.PrepareFrame(frame);

            float xratio = (float)(_Viewer.DisplaySize.X / 640);
            float yratio = (float)(_Viewer.DisplaySize.Y / 480);

            float percent = TranslateToPercent();

            float xpos;
            float ypos;

            if (_Gauge.Orientation == 0)
            {
                ypos = (int)_Gauge.Height;
                if (_Gauge.Direction == 0)
                {
                    xpos = ((float)_Gauge.Width * percent);
                }
                else
                {
                    xpos = ((float)_Gauge.Width - (float)_Gauge.Width * percent);
                }
            }
            else
            {
                xpos = (int)_Gauge.Width;
                if (_Gauge.Direction == 0)
                {
                    ypos = ((float)_Gauge.Height * percent);
                }
                else
                {
                    ypos = ((float)_Gauge.Height - (float)_Gauge.Height * percent);
                }
            }

            if (_Gauge.ControlStyle == CABViewControlStyles.SOLID || _Gauge.ControlStyle == CABViewControlStyles.LIQUID)
            {
                _DestRectangle = new Rectangle((int)(xratio * _CabViewControl.PositionX),
                    (int)(yratio * _CabViewControl.PositionY),
                    (int)(xratio * xpos), (int)(yratio * ypos));
            }
            else
            {
                _DestRectangle = new Rectangle((int)(xratio * (_CabViewControl.PositionX + xpos)),
                    (int)(yratio * (_CabViewControl.PositionY + ypos)),
                    (int)(xratio * _Gauge.Area.Width), (int)(yratio * _Gauge.Area.Height));
            }
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            _Sprite2DCtlView.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.White);
        }
    }

    /// <summary>
    /// Discrete renderer for Lever, Twostate, Tristate, Multistate, Signal
    /// </summary>
    public class CabViewDiscreteRenderer : CabViewControlRenderer
    {
        protected CVCWithFrames _CVCWithFrames;
        protected Rectangle _SourceRectangle;
        protected Rectangle _DestRectangle;
        
        public CabViewDiscreteRenderer(CVCWithFrames cvc, Viewer3D viewer, MSTSLocomotive car)
            : base(cvc, viewer, car)
        {
            _CVCWithFrames = cvc;
            CABTextureManager.DisassembleTexture(viewer.GraphicsDevice, _CabViewControl.ACEFile,
                (int)_CabViewControl.Width, (int)_CabViewControl.Height);
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            bool Dark = Materials.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            int indx = GetDrawIndex();

            indx = (int)MathHelper.Clamp(indx, 0, _CVCWithFrames.FramesCount - 1);

            _Texture = CABTextureManager.GetTextureByIndexes(_CabViewControl.ACEFile, indx, Dark, CabLight);

            if (_Texture == Materials.MissingTexture)
                return;

            base.PrepareFrame(frame);

            float xratio = (float)(_Viewer.DisplaySize.X / 640);
            float yratio = (float)(_Viewer.DisplaySize.Y / 480);

            _DestRectangle = new Rectangle((int)(xratio * _CabViewControl.PositionX * 1.0001),
                (int)(yratio * _CabViewControl.PositionY * 1.0001), (int)(xratio * _CabViewControl.Width), (int)(yratio * _CabViewControl.Height));

            _SourceRectangle = new Rectangle(0, 0, (int)_CVCWithFrames.Width, (int)_CVCWithFrames.Height);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            //graphicsDevice.SamplerStates[0].MagFilter = TextureFilter.Linear;
            _Sprite2DCtlView.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.White);
        }

        /// <summary>
        /// Determines the index of the Texture to be drawn
        /// Check here for Signal display
        /// </summary>
        /// <returns>index of the Texture</returns>
        public int GetDrawIndex()
        {
            int indx = 0;
            switch (_CVCWithFrames.ControlType)
            {
                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                //case CABViewControlTypes.CPH_DISPLAY:
                    {
                        indx = FromPercent(_Locomotive.ThrottlePercent);
                        break;
                    }
                case CABViewControlTypes.ENGINE_BRAKE:
                    {
                        indx = FromPercent(_Locomotive.EngineBrakeController.CurrentValue);
                        break;
                    }
                case CABViewControlTypes.TRAIN_BRAKE:
                    {
                        indx = FromPercent(_Locomotive.TrainBrakeController.CurrentValue);
                        break;
                    }
                case CABViewControlTypes.WIPERS:
                    {
                        indx = _Locomotive.Wiper ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.HORN:
                    {
                        indx = _Locomotive.Horn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.BELL:
                    {
                        indx = _Locomotive.Bell ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.SANDERS:
                    {
                        indx = _Locomotive.Sander ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.FRONT_HLIGHT:
                    {
                        indx = _Locomotive.Headlight;
                        break;
                    }
                case CABViewControlTypes.PANTOGRAPH:
                case CABViewControlTypes.PANTO_DISPLAY:
                    {
                        MSTSElectricLocomotive el = _Locomotive as MSTSElectricLocomotive;
                        indx = el.Pan ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                    {
                        if (_Locomotive.Direction == Direction.Forward)
                            indx = 2;
                        else if (_Locomotive.Direction == Direction.Reverse)
                            indx = 0;
                        else
                            indx = 1;
                        break;
                    }
                case CABViewControlTypes.ASPECT_DISPLAY:
                    {
                        switch (_Locomotive.Train.CABAspect)
                        {
                            case SignalHead.SIGASP.STOP:
                                {
                                    indx = 0;
                                    break;
                                }
                            case SignalHead.SIGASP.STOP_AND_PROCEED:
                                {
                                    indx = 1;
                                    break;
                                }
                            case SignalHead.SIGASP.RESTRICTING:
                                {
                                    indx = 2;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_1:
                                {
                                    indx = 3;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_2:
                                {
                                    indx = 4;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_3:
                            case SignalHead.SIGASP.APPROACH_4:
                                {
                                    indx = 5;
                                    break;
                                }
                            case SignalHead.SIGASP.CLEAR_1:
                            case SignalHead.SIGASP.CLEAR_2:
                            case SignalHead.SIGASP.CLEAR_3:
                            case SignalHead.SIGASP.CLEAR_4:
                                {
                                    indx = 6;
                                    break;
                                }
                            default:
                                {
                                    indx = 7;
                                    break;
                                }
                        }
                        break;
                    }
            }

            return indx;
        }

        /// <summary>
        /// Translates a percent value to a display index
        /// </summary>
        /// <param name="percent">Percent to be translated</param>
        /// <returns>The calculated display index by the Control's Values</returns>
        public int FromPercent(float percent)
        {
            int indx;
            if (percent > 1) percent /= 100f;
            if (_CVCWithFrames.Values.Count > 1)
            {
                double val = _CVCWithFrames.Values.Where(v => v <= percent).Last();
                indx = _CVCWithFrames.Values.IndexOf(val);
            }
            else
            {
                indx = (int)(percent / (_CVCWithFrames.MaxValue - _CVCWithFrames.MinValue) * _CVCWithFrames.FramesCount);
            }

            return indx;
        }
    }

    /// <summary>
    /// Digital Cab Control renderer
    /// Uses fonts instead of graphic
    /// Do not supports Justification
    /// </summary>
    public class CabViewDigitalRenderer : CabViewControlRenderer
    {
        private string _Text;
        SpriteFont _Font;
        private float _ScaleToScreen = 1f;
        private int _Digits = 1;

        public CabViewDigitalRenderer (CVCDigital digital, Viewer3D viewer, MSTSLocomotive car)
            : base (digital, viewer, car)
        {
            _Font = _Viewer.RenderProcess.Content.Load<SpriteFont>("Arial");
            _Digits = (int)Math.Log10(_CabViewControl.MaxValue) + 1;
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            float fontratio = (float)_CabViewControl.Height / 16;
            float fpos = ((float)_CabViewControl.Width) - 6 * _Digits * fontratio;

            _Position = new Vector2((float)(_Viewer.DisplaySize.X / 640 * (_CabViewControl.PositionX + fpos)),
                (float)(_Viewer.DisplaySize.Y / 480 * _CabViewControl.PositionY));

            base.PrepareFrame(frame);

            _ScaleToScreen = _Viewer.DisplaySize.Y / 480 * (fontratio);

            float num = _Locomotive.GetDataOf(_CabViewControl);
            _Text = num.ToString("00");
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            _Sprite2DCtlView.SpriteBatch.DrawString(_Font, _Text, _Position, Color.White, 0f, new Vector2(), _ScaleToScreen, SpriteEffects.None, 0);
        }
    }
}
