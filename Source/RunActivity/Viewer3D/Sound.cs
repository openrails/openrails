// COPYRIGHT 2009, 2010, 2011, 2012, 2013, 2014, 2015 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

//#define DEBUGSCR

using Orts.Common;
using Orts.Formats.Msts;
using Orts.Simulation;
using Orts.Simulation.AIs;
using Orts.Simulation.Physics;
using Orts.Simulation.RollingStocks;
using Orts.Simulation.Signalling;
using ORTS.Common;
using ORTS.Settings;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Event = Orts.Common.Event;
using Events = Orts.Common.Events;

namespace Orts.Viewer3D
{

    /////////////////////////////////////////////////////////
    // SOUND SOURCE
    /////////////////////////////////////////////////////////

    /// <summary>
    /// Represents an sms file,
    /// may have a physical location in the world,
    /// may be attached to a railcar in which case it moves with the car,
    /// owns one or more SoundStreams
    /// </summary>
    public abstract class SoundSourceBase : IDisposable
    {
        public abstract void InitInitials();
        public abstract void Uninitialize();
        public abstract bool Update();

        /// <summary>
        /// The sound may be from a train car
        /// </summary>
        public MSTSWagon Car;
        /// <summary>
        /// The listener is connected to this viewer
        /// </summary>
        public Viewer Viewer;
        /// <summary>
        /// Volume of the ScalabiltyGroup
        /// </summary>
        public float Volume = 1;
        /// <summary>
        /// If needs active management or can be left to OpenAL to deal with sound properties
        /// </summary>
        public bool NeedsFrequentUpdate;
        public bool TrackSound = false;

        public abstract void Dispose();
    }

    public class TrackSoundSource : SoundSourceBase
    {
        private int _prevTType = -1;
        private int _curTType = -1;
        private SoundSource _activeInSource;
        private SoundSource _activeOutSource;
        private List<SoundSource> _inSources;
        private List<SoundSource> _outSources;

        // data to evaluate if ttype selection is needed or not
        private float nextDist = -1; // initial distance to sound region forward
        private float prevDist = -1; // initial distance to sond region backward
        private float initDist = -1; // initial distance run when last ttype selected
        private int initTrackSection = -1; // track section when last ttype selected
        private MSTSWagon initCar = null; // initial leading car (to accommodate in case of change of direction)
        private bool CarOnSwitch = false;
        private bool CarOnCurve = false;


        public TrackSoundSource(MSTSWagon car, Viewer viewer)
        {
            TrackSound = true;
            Car = car;
            Viewer = viewer;
            _inSources = new List<SoundSource>();
            _outSources = new List<SoundSource>();

            foreach (Orts.Formats.Msts.TrackTypesFile.TrackType ttdf in viewer.TrackTypes)
            {
                MSTSLocomotive loco = Car as MSTSLocomotive;

                //if (!string.IsNullOrEmpty(Car.InteriorSoundFileName) || (loco != null && !string.IsNullOrEmpty(loco.CabSoundFileName)))
                if (!string.IsNullOrEmpty(Car.InteriorShapeFileName) || (loco != null && (loco.HasFrontCab || loco.HasRearCab || loco.HasFront3DCab || loco.HasRear3DCab)))
                    LoadTrackSound(ttdf.InsideSound, true);

                LoadTrackSound(ttdf.OutsideSound, false);
            }

        }

        private void LoadTrackSound(string filename, bool isInside)
        {
            if (filename == null)
                return;

            string[] pathArray = {Viewer.Simulator.RoutePath, Viewer.Simulator.BasePath};            
            var fullPath = ORTSPaths.GetFileFromFolders(pathArray, @"SOUND\" + filename);
            if (fullPath == null)
            {
                Trace.TraceWarning("Skipped missing track sound {0}", filename);
                return;
            }
            if (isInside)
            {
                _inSources.Add(new SoundSource(Viewer, Car, fullPath));
                _inSources.Last().IsInternalTrackSound = true;
            }
            else
                _outSources.Add(new SoundSource(Viewer, Car, fullPath));
        }

        public override void Uninitialize()
        {
            //Trace.TraceInformation("TrackSoundSource Uninitialize");
            if (_activeInSource != null)
                _activeInSource.Uninitialize();
            if (_activeOutSource !=null)
                _activeOutSource.Uninitialize();
        }

        public override void InitInitials()
        {
            if (_inSources != null && _inSources.Count > 0)
                _activeInSource = _inSources[0];

            if (_outSources != null && _outSources.Count > 0)
                _activeOutSource = _outSources[0];

            _curTType = 0;
            _prevTType = 0;
        }

        public void UpdateTType(bool stateChange)
        {
            if (_prevTType == -1)
            {
                InitInitials();
            }

            if (Car != null && Car.Train != null)
            {
                int CarIncr = 0;
                int CarLeading = 0;
                if (Car.Train.SpeedMpS > 0.1f)
                {
                    CarIncr = 1;
                    CarLeading = 0;
                }
                else
                    if (Car.Train.SpeedMpS < -0.1f)
                    {
                        CarIncr = -1;
                        CarLeading = Car.Train.Cars.Count - 1;
                    }
                    else
                        return;

                var CarNo = Car.Train.Cars.IndexOf(Car);
                float trackSoundDistSquared = 0;

                if (CarNo == CarLeading)
                {
                    bool reSelect = stateChange;
                    if (!reSelect)
                    {
                        if (nextDist == -1 || initCar != Car.Train.Cars[CarLeading])
                        {
                            reSelect = true;
                        }
                        else if ((CarLeading == 0 && Car.Train.PresentPosition[0].TCSectionIndex != initTrackSection) || (CarLeading != 0 && Car.Train.PresentPosition[1].TCSectionIndex != initTrackSection))
                        {
                            reSelect = true;
                        }
                        else if (CarLeading == 0 && (Car.Train.DistanceTravelledM - initDist > nextDist || initDist - Car.Train.DistanceTravelledM > prevDist))
                        {
                            reSelect = true;
                        }
                        else if (CarLeading != 0 && (Car.Train.DistanceTravelledM - Car.Train.Length - initDist > nextDist || initDist - Car.Train.DistanceTravelledM + Car.Train.Length > prevDist))
                        {
                            reSelect = true;
                        }
                    }
                    if (reSelect)
                    {
                        //_curTType = Viewer.WorldSounds.GetTType(_tdbObjs);
                        initCar = Car;
                        initTrackSection = CarLeading == 0 ? Car.Train.PresentPosition[0].TCSectionIndex : Car.Train.PresentPosition[1].TCSectionIndex;
                        initDist = CarLeading == 0 ? Car.Train.DistanceTravelledM : Car.Train.DistanceTravelledM - Car.Train.Length;
                        Car.TrackSoundType = Viewer.World.Sounds.GetTType(Car.Train, out prevDist, out nextDist);
                        if (Car.TrackSoundType != int.MaxValue)
                            if (Car.TrackSoundType < Viewer.TrackTypes.Count)
                                _curTType = Car.TrackSoundType;
                            else
                            {
                                // Track type out of range
                                _curTType = 0;
                                Trace.TraceWarning("Sound region {0} out of range in tile {1} {2}", Car.TrackSoundType,
                                    Car.WorldPosition.WorldLocation.TileX, Car.WorldPosition.WorldLocation.TileZ);
                                Car.TrackSoundType = 0;
                            }
                        else
                            if (!SharedSMSFileManager.AutoTrackSound || (
                                _curTType != SharedSMSFileManager.SwitchSMSNumber &&
                                _curTType != SharedSMSFileManager.CurveSMSNumber &&
                                _curTType != SharedSMSFileManager.CurveSwitchSMSNumber))
                                Car.TrackSoundType = _curTType;
                            else
                            {
                                Car.TrackSoundType = 0;
                                _curTType = 0;
                            }
                     }
                    else Car.TrackSoundType = _curTType;
                }
                else
                {
                    var CarAhead = Car.Train.Cars[CarNo - CarIncr];
                    if (CarAhead.TrackSoundLocation != WorldLocation.None)
                    {
//                        if (stateChange)
//                            Trace.TraceInformation("Time {4} TrainName {6} carNo {0} IsOnSwitch {1} IsOnCurve {7} TracksoundType {2} _CurTType {3} AheadTrackSoundType {5}",
//                                Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, CarAhead.TrackSoundType, Car.Train.Name, CarOnCurve);
                        if ((_curTType == Car.TrackSoundType || stateChange ) && Car.TrackSoundType != CarAhead.TrackSoundType)
                        {
                            Car.TrackSoundType = CarAhead.TrackSoundType;
                            Car.TrackSoundLocation = new WorldLocation(CarAhead.TrackSoundLocation);
                            Car.TrackSoundDistSquared = WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, Car.TrackSoundLocation);
//                            Trace.TraceInformation("Time {4} TrainName {5} carNo {0} IsOnSwitch {1} IsOnCurve {6} TracksoundType {2} _CurTType {3} to standard",
//                              Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, CarOnCurve);
                            if (stateChange)
                            {
                                _curTType = Car.TrackSoundType;
                            }
                        }

                        if (Car.TrackSoundLocation != WorldLocation.None)
                        {
                            trackSoundDistSquared = WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, Car.TrackSoundLocation);
                            if (trackSoundDistSquared > 9 && (trackSoundDistSquared - 2) <= Car.TrackSoundDistSquared)
                                Car.TrackSoundDistSquared = trackSoundDistSquared;
                            else
                            {
//                                if (_curTType != Car.TrackSoundType) Trace.TraceInformation("Time {4} TrainName {5} carNo {0} IsOnSwitch {1} IsOnCurve {6} TracksoundType {2} _CurTType {3} standard",
//                                  Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, CarOnCurve);
                                _curTType = Car.TrackSoundType;
                            }
                        }
                    }
                }

                //if (_curTType != _prevTType && _curTType != int.MaxValue)
                if (_curTType != _prevTType)
                {
                    if (_activeInSource != null)
                    {
                        _activeInSource.Uninitialize();
                        //_activeInSource.Car = null;
                        if (0 <= _curTType && _curTType < _inSources.Count)
                            _activeInSource = _inSources[_curTType];
                        else
                            Trace.TraceWarning("Could not change inside sound region to {0}", _curTType);
                        //_activeInSource.Car = Car;
                    }

                    if (_activeOutSource != null)
                    {
                        _activeOutSource.Uninitialize();
                        //_activeOutSource.Car = null;
                        if (0 <= _curTType && _curTType < _outSources.Count)
                            _activeOutSource = _outSources[_curTType];
                        else
                            Trace.TraceWarning("Could not change outside sound region to {0}", _curTType);
                        //_activeOutSource.Car = Car;
                    }
#if DEBUGSCR
                    Trace.TraceInformation("Sound region changed from {0} to {1}.", _prevTType, _curTType);
#endif
//                    if (!stateChange) Trace.TraceInformation("StandardChange Time {4} TrainName {5} carNo {0} IsOnSwitch {1} TracksoundType {2} _CurTType {3} _PrevTType {6}",
//                        Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, _prevTType);
//                           Trace.TraceInformation("Train {0} Speed {1}, Car {2}: Sound Region {3} changed to {4} at distance {5}", Car.Train.Number, Car.Train.SpeedMpS, CarNo, _prevTType, _curTType, Math.Sqrt(trackSoundDistSquared));
                    if (CarNo == CarLeading)
                        Car.TrackSoundLocation = new WorldLocation(Car.WorldPosition.WorldLocation);
                    _prevTType = _curTType;
                }
            }
        }

        public override bool Update()
        {
            bool stateChange = false;
            if (SharedSMSFileManager.AutoTrackSound) stateChange = UpdateCarOnSwitchAndCurve();
//            if (stateChange) Trace.TraceInformation("Time {4} TrainName {5} carNo {0} IsOnSwitch {1} IsOnCurve {6} TracksoundType {2} _CurTType {3} Radius {7} Before",
//                Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, CarOnCurve, Car.CurrentCurveRadius);
            if ((!CarOnSwitch && !CarOnCurve) || !SharedSMSFileManager.AutoTrackSound)
                UpdateTType(stateChange);
//            if (stateChange) Trace.TraceInformation("Time {4} TrainName {5} carNo {0} IsOnSwitch {1} IsOnCurve {6} TracksoundType {2} _CurTType {3} Radius {7} After",
//                Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, CarOnCurve, Car.CurrentCurveRadius);
            bool retval = true;
            NeedsFrequentUpdate = false;

            if (_activeInSource != null)
            {
                retval &= _activeInSource.Update();
                NeedsFrequentUpdate |= _activeInSource.NeedsFrequentUpdate;
            }

            if (_activeOutSource != null)
            {
                retval &= _activeOutSource.Update();
                NeedsFrequentUpdate |= _activeOutSource.NeedsFrequentUpdate;
            }

            return retval;
        }

        public override void Dispose()
        {
            if (_inSources != null)
            {
                foreach (SoundSource s in _inSources)
                    s.Dispose();
                _inSources.Clear();
            }
            if (_outSources != null)
            {
                foreach (SoundSource s in _outSources)
                    s.Dispose();
                _outSources.Clear();
            }
            Car = null;
        }

        //Checks whether car on switch or on curve or both and selects related .sms file;
        // returns true if state has changed

        public bool UpdateCarOnSwitchAndCurve()
        {
            var stateChange = false;
            if (Car != null && Car.Train != null)
            {
                if (Car.Train.SpeedMpS > 0.1f || Car.Train.SpeedMpS < -0.1f)
                {
                    var CarNo = Car.Train.Cars.IndexOf(Car);
                    var CarIncr = 0;
                    if (Car.Train.SpeedMpS > 0.1f && CarNo != Car.Train.Cars.Count - 1) CarIncr = 1;
                    if (Car.Train.SpeedMpS < 0.1f && CarNo != 0) CarIncr = -1;

                    var CarBehind = Car.Train.Cars[CarNo + CarIncr];
                    var carPreviouslyOnSwitch = CarOnSwitch;
                    CarOnSwitch = false;
                    if (Car.Train.PresentPosition[0].TCSectionIndex != Car.Train.PresentPosition[1].TCSectionIndex)
                    {
                        try
                        {
                            var copyOccupiedTrack = Car.Train.OccupiedTrack.ToArray();
                            foreach (var thisSection in copyOccupiedTrack)
                            {
                                if (thisSection.CircuitType == TrackCircuitSection.TrackCircuitType.Junction || thisSection.CircuitType == TrackCircuitSection.TrackCircuitType.Crossover)
                                {
                                    // train is on a switch; let's see if car is on a switch too
                                    WorldLocation switchLocation = UidLocation(Viewer.Simulator.TDB.TrackDB.TrackNodes[thisSection.OriginalIndex].UiD);
                                    var distanceFromSwitch = WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, switchLocation);
                                    if (distanceFromSwitch < Car.CarLengthM * Car.CarLengthM + Math.Min(Car.SpeedMpS * 3, 150))
                                    {
                                        CarOnSwitch = true;
                                        break;
                                    }
                                }
                            }
                        }
                        catch
                        {

                        }
                    }
                    // here check for curve
                    var carPreviouslyOnCurve = CarOnCurve;
                    CarOnCurve = false;
                    if ((Car.CurrentCurveRadiusM > 0 && (Car.CurrentCurveRadiusM < 301
                         || (Car.CurrentCurveRadiusM < 350 && Car.WagonType == TrainCar.WagonTypes.Freight))) ||
                        (CarBehind.CurrentCurveRadiusM > 0 && (CarBehind.CurrentCurveRadiusM < 301
                         || (CarBehind.CurrentCurveRadiusM < 350 && Car.WagonType == TrainCar.WagonTypes.Freight))))
                    {
                        CarOnCurve = true;
                    }

                    // resume results and select sound if change
                    if (carPreviouslyOnSwitch ^ CarOnSwitch || carPreviouslyOnCurve ^ CarOnCurve)
                    { 
                        stateChange = true;
                    }
                    if (stateChange && (CarOnSwitch || CarOnCurve))
                    {
                        Car.TrackSoundLocation = new WorldLocation(Car.WorldPosition.WorldLocation);
                        if (CarOnSwitch && CarOnCurve && SharedSMSFileManager.CurveSwitchSMSNumber != -1)
                        {
                            _curTType = SharedSMSFileManager.CurveSwitchSMSNumber;
                        }
                        else if (CarOnCurve && SharedSMSFileManager.CurveSMSNumber != -1)
                        {
                            _curTType = SharedSMSFileManager.CurveSMSNumber;
                        }
                        else if (CarOnSwitch && SharedSMSFileManager.SwitchSMSNumber != -1)
                        // car on switch
                        {
                            _curTType = SharedSMSFileManager.SwitchSMSNumber;
                        }
                        else stateChange = false;
                    }
                }
                else
                    return stateChange;

                //if (_curTType != _prevTType && _curTType != int.MaxValue)
                if (_curTType != _prevTType)
                {
                    if (_activeInSource != null)
                    {
                        _activeInSource.Uninitialize();
                        //_activeInSource.Car = null;
                        if (0 <= _curTType && _curTType < _inSources.Count)
                            _activeInSource = _inSources[_curTType];
                        else
                            Trace.TraceWarning("Could not change inside sound region to {0}", _curTType);
                        //_activeInSource.Car = Car;
                    }

                    if (_activeOutSource != null)
                    {
                        _activeOutSource.Uninitialize();
                        //_activeOutSource.Car = null;
                        if (0 <= _curTType && _curTType < _outSources.Count)
                            _activeOutSource = _outSources[_curTType];
                        else
                            Trace.TraceWarning("Could not change outside sound region to {0}", _curTType);
                        //_activeOutSource.Car = Car;
                    }
#if DEBUGSCR
                    Trace.TraceInformation("Sound region changed from {0} to {1}.", _prevTType, _curTType);
#endif

                    //Trace.TraceInformation("Train {0} Speed {1}, Car {2}: Sound Region {3} changed to {4} at distance {5}", Car.Train.Number, Car.Train.SpeedMpS, CarNo, _prevTType, _curTType, Math.Sqrt(trackSoundDistSquared));
                    _prevTType = _curTType;
                }
            }
            return stateChange;
        }

        public static WorldLocation UidLocation(UiD uid)
        {
            return new WorldLocation(uid.TileX, uid.TileZ, uid.X, uid.Y, uid.Z);
        }
    }


    
    /// <summary>
    /// Represents an sms file
    /// </summary>
    public class SoundSource : SoundSourceBase
    {
        /// <summary>
        /// Squared cutoff distance. No sound is audible above that, except for the actual player train,
        /// where cutoff occurs at a distance wich is higher than the train length plus offset to 
        /// approximately take into account distance from camera to car
        /// </summary>
        private int CutOffDistanceM2
        {
            get
            {
                const int staticDistanceM2 = 4000000;
                var isPlayer = Car?.Train?.IsActualPlayerTrain ?? false;
                var correctedLength = isPlayer ? Car.Train.Length + 50 : 0; 
                return (int)Math.Max(staticDistanceM2, correctedLength * correctedLength);
            }
        }
        /// <summary>
        /// Max distance for OpenAL inverse distance model. Equals to Math.Sqrt(CUTOFFDISTANCE)
        /// </summary>
        public const float MaxDistanceM = 2000f;
        /// <summary>
        /// Desired max gain at max distance for OpenAL inverse distance model
        /// </summary>
        public const float GainAtMaxDistance = 0.025f;
        /// <summary>
        /// Below this distance there is no attenuation. Used by OpenAL inverse distance model
        /// </summary>
        public const float ReferenceDistanceM = 8f;
        /// <summary>
        /// Sound attenuation factor. Calculated to achieve goal set by <see cref="GainAtMaxDistance"/>
        /// </summary>
        public float RolloffFactor;
        /// <summary>
        /// Used for InGame sounds and activity sounds of type "Overall"
        /// </summary>
        public bool IsUnattenuated = false;

        /// <summary>
        /// Construct a SoundSource attached to a train car.
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, MSTSWagon car, string smsFilePath)
        {
            Car = car;
            Initialize(viewer, car.WorldPosition.WorldLocation, Events.Source.MSTSCar, smsFilePath);
        }

        /// <summary>
        /// Initializes a SoundSource which has no specific location - like ingame.sms
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, Events.Source eventSource, string smsFilePath, bool isUnattenuated)
        {
            IsUnattenuated = isUnattenuated;
            Initialize(viewer, WorldLocation.None, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, WorldLocation worldLocation, Events.Source eventSource, string smsFilePath)
        {
            IsEnvSound = true;
            Initialize(viewer, worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="slowRolloff"></param>
        public SoundSource(Viewer viewer, WorldLocation worldLocation, Events.Source eventSource, string smsFilePath, bool slowRolloff)
        {
            IsEnvSound = true;
            SlowRolloff = slowRolloff;
            Initialize(viewer, worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource attached to a train car, with predefined parameters (activity sound).
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, MSTSWagon car, string wavFilePath, ORTSActSoundFileTypes ORTSActSoundFileType,  bool preCompiled)
        {
            Car = car;
            Initialize(viewer, car.WorldPosition.WorldLocation, Events.Source.MSTSCar, wavFilePath, ORTSActSoundFileType, preCompiled);
        }

        /// <summary>
        /// Construct a SoundSource which has no specific location - like ingame.sms, with predefined parameters (activity sound)
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, Events.Source eventSource, string wavFilePath, ORTSActSoundFileTypes ORTSActSoundFileType, bool isUnattenuated, bool preCompiled)
        {
            IsUnattenuated = isUnattenuated;
            Initialize(viewer, WorldLocation.None, eventSource, wavFilePath, ORTSActSoundFileType, preCompiled);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation, with predefined parameters (activity sound)
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="slowRolloff"></param>
        public SoundSource(Viewer viewer, WorldLocation worldLocation, Events.Source eventSource, string wavFilePath, bool slowRolloff, ORTSActSoundFileTypes ORTSActSoundFileType, bool preCompiled)
        {
            IsEnvSound = true;
            SlowRolloff = slowRolloff;
            Initialize(viewer, worldLocation, eventSource, wavFilePath, ORTSActSoundFileType, preCompiled);
        }

        /// <summary>
        /// Construct a SoundSource that has no specific location and a set of programmatically defined <see cref="SoundStream"/>s.
        /// </summary>
        /// <param name="viewer">The <see cref="Viewer"/> to attach this SoundSource to.</param>
        /// <param name="makeStreams">A generator function to create the attached SoundStreams.</param>
        public SoundSource(Viewer viewer, Func<SoundSource, IEnumerable<SoundStream>> makeStreams)
        {
            IsUnattenuated = true;
            Initialize(viewer);
            SoundStreams.AddRange(makeStreams(this));
        }

        /// <summary>
        /// Stop the streams, free up OpenAL sound source IDs and try to unload wave data from memory
        /// </summary>
        public override void Uninitialize()
        {
            foreach (SoundStream ss in SoundStreams)
            {
                ss.Stop();
                ss.HardDeactivate();
                WasOutOfDistance = true;
                NeedsFrequentUpdate = false;
            }
        }
        
        /// <summary>
        /// Current location of the sound source
        /// </summary>
        public WorldLocation WorldLocation;

        /// <summary>
        /// The wave files will be relative to this folder
        /// </summary>
        public string SMSFolder;
        public string SMSFileName;
        public string WavFolder;
        public string WavFileName;
        public bool Active;
        private Orts.Formats.Msts.Activation ActivationConditions;
        private Orts.Formats.Msts.Deactivation DeactivationConditions;
        public bool IsEnvSound;
        public bool IsExternal = true;
        public bool IsInternalTrackSound = false;
        public bool Ignore3D;
        /// <summary>
        /// MSTS treats Stereo() tagged mono wav files specially. This is a flag
        /// indicating if this treatment should be applied here
        /// </summary>
        public bool MstsMonoTreatment;

        /// <summary>
        /// Current distance to camera, squared meter. Is used for comparision to <see cref="CutOffDistanceM2"/>, to determine if is out-of-scope
        /// </summary>
        public float DistanceSquared = float.MaxValue;
        /// <summary>
        /// Out-of-scope state in previous <see cref="Update"/> loop
        /// </summary>
        private bool WasOutOfDistance = true;
        /// <summary>
        /// Different rolloff factor is used for track sounds not to attenuate so fast. As a bargain they are not silenced at cutoff distance
        /// </summary>
        private bool SlowRolloff;

        /// <summary>
        /// List of Streams in sms
        /// </summary>
        public List<SoundStream> SoundStreams = new List<SoundStream>();

        /// <summary>
        /// Set properties of this SoundSource based on parsing the sms file, and generate SoundStreams
        /// </summary>
        /// <param name="viewer">Current <see cref="Viewer3D"/></param>
        /// <param name="worldLocation">World location of <see cref="SoundSource"/></param>
        /// <param name="eventSource">Type of game part sms belongs to, to determine how to interpret discrete trigger numbers</param>
        /// <param name="smsFilePath">Full path for sms file</param>
        public void Initialize(Viewer viewer, WorldLocation worldLocation, Events.Source eventSource, string smsFilePath)
        {
            Viewer = viewer;
            WorldLocation = worldLocation;

            if (smsFilePath == null)
                return;

            SMSFolder = Path.GetDirectoryName(smsFilePath);
            SMSFileName = Path.GetFileName(smsFilePath);
            Orts.Formats.Msts.SoundManagmentFile smsFile = Orts.Formats.Msts.SharedSMSFileManager.Get(smsFilePath);


            // find correct ScalabiltyGroup
            int iSG = 0;
            while ( iSG < smsFile.Tr_SMS.ScalabiltyGroups.Count)
            {
                if (smsFile.Tr_SMS.ScalabiltyGroups[iSG].DetailLevel <= Viewer.Settings.SoundDetailLevel)
                    break;
                ++iSG;
            }
            if (iSG < smsFile.Tr_SMS.ScalabiltyGroups.Count && smsFile.Tr_SMS.ScalabiltyGroups[iSG].Streams != null)  // else we want less sound so don't provide any
            {
                Orts.Formats.Msts.ScalabiltyGroup mstsScalabiltyGroup = smsFile.Tr_SMS.ScalabiltyGroups[iSG];

                ActivationConditions = mstsScalabiltyGroup.Activation;
                DeactivationConditions = mstsScalabiltyGroup.Deactivation;
                Volume = mstsScalabiltyGroup.Volume;
                Ignore3D = mstsScalabiltyGroup.Ignore3D | mstsScalabiltyGroup.Stereo;
                MstsMonoTreatment = mstsScalabiltyGroup.Stereo;
                IsExternal = ActivationConditions.ExternalCam;

                SetRolloffFactor();

                foreach (Orts.Formats.Msts.SMSStream mstsStream in mstsScalabiltyGroup.Streams)
                {
                    SoundStreams.Add(new SoundStream(mstsStream, eventSource, this, Viewer.Settings));
                }
            }
        }

                /// <summary>
        /// Set properties of this SoundSource with default precompiled parameters, and generate SoundStreams
        /// </summary>
        /// <param name="viewer">Current <see cref="Viewer3D"/></param>
        /// <param name="worldLocation">World location of <see cref="SoundSource"/></param>
        /// <param name="eventSource">Type of game part sound source belongs to, to determine how to interpret discrete trigger numbers</param>
        /// <param name="smsFilePath">Full path for sms file</param>
        public void Initialize(Viewer viewer, WorldLocation worldLocation, Events.Source eventSource, string wavFilePath, ORTSActSoundFileTypes ORTSActSoundFileType, bool preCompiled)
        {
            Viewer = viewer;
            WorldLocation = worldLocation;

            if (wavFilePath == null)
                return;

            WavFolder = Path.GetDirectoryName(wavFilePath);
            WavFileName = Path.GetFileName(wavFilePath);
            SMSFolder = WavFolder;
            SMSFileName = WavFileName;

            if (Viewer.Settings.SoundDetailLevel >= 3)
            {
                // base initializations
                ActivationConditions = new Orts.Formats.Msts.Activation();
                DeactivationConditions = new Orts.Formats.Msts.Deactivation();
                ActivationConditions.TrackType = -1;
                DeactivationConditions.TrackType = -1;
                ActivationConditions.Distance = 1000;
                DeactivationConditions.Distance = 1000;
                switch (ORTSActSoundFileType)
                {
                    case ORTSActSoundFileTypes.Everywhere:
                        ActivationConditions.CabCam = true;
                        ActivationConditions.ExternalCam = true;
                        ActivationConditions.PassengerCam = true;
                        DeactivationConditions.CabCam = false;
                        DeactivationConditions.ExternalCam = false;
                        DeactivationConditions.PassengerCam = false;
                        Ignore3D = true;
                        IsExternal = true;
                        break;
                    default:
                    case ORTSActSoundFileTypes.Cab:
                        ActivationConditions.CabCam = true;
                        ActivationConditions.ExternalCam = false;
                        ActivationConditions.PassengerCam = false;
                        DeactivationConditions.CabCam = false;
                        DeactivationConditions.ExternalCam = true;
                        DeactivationConditions.PassengerCam = true;
                        Ignore3D = true;
                        IsExternal = false;
                        break;
                    case ORTSActSoundFileTypes.Pass:
                        ActivationConditions.CabCam = false;
                        ActivationConditions.ExternalCam = false;
                        ActivationConditions.PassengerCam = true;
                        DeactivationConditions.CabCam = true;
                        DeactivationConditions.ExternalCam = true;
                        DeactivationConditions.PassengerCam = false;
                        Ignore3D = true;
                        IsExternal = false;
                        break;
                    case ORTSActSoundFileTypes.Ground:
                        ActivationConditions.CabCam = true;
                        ActivationConditions.ExternalCam = true;
                        ActivationConditions.PassengerCam = true;
                        DeactivationConditions.CabCam = false;
                        DeactivationConditions.ExternalCam = false;
                        DeactivationConditions.PassengerCam = false;
                        Ignore3D = false;
                        IsExternal = true;
                        break;
                    case ORTSActSoundFileTypes.Location:
                        ActivationConditions.CabCam = true;
                        ActivationConditions.ExternalCam = true;
                        ActivationConditions.PassengerCam = true;
                        DeactivationConditions.CabCam = false;
                        DeactivationConditions.ExternalCam = false;
                        DeactivationConditions.PassengerCam = false;
                        Ignore3D = false;
                        IsExternal = true;
                        break;
                }
                Volume = 1.0f;
                SetRolloffFactor();

                // initialization of the only one sound stream
                SoundStreams.Add(new SoundStream(WavFileName, eventSource, this)); 
            }
        }

        private void Initialize(Viewer viewer)
        {
            Viewer = viewer;
            WorldLocation = WorldLocation.None;

            ActivationConditions = new Activation()
            {
                TrackType = -1,
                Distance = 1000,
                CabCam = true,
                ExternalCam = true,
                PassengerCam = true,
            };
            DeactivationConditions = new Deactivation()
            {
                TrackType = -1,
                Distance = 1000,
                CabCam = false,
                ExternalCam = false,
                PassengerCam = false,
            };

            Volume = 1.0f;
            SetRolloffFactor();
        }

        private void SetRolloffFactor()
        {
            var deactivationDistance = DeactivationConditions != null && DeactivationConditions.Distance != 0 ? DeactivationConditions.Distance : MaxDistanceM;
            var maxDistanceM = Math.Min(MaxDistanceM, deactivationDistance);

            // OpenAL inverse distance model is based on formula
            // Gain = AL_REFERENCE_DISTANCE / ( AL_REFERENCE_DISTANCE + AL_ROLLOFF_FACTOR * ( Distance - AL_REFERENCE_DISTANCE ) )
            RolloffFactor = SlowRolloff ? 0.4f : ReferenceDistanceM * (1f / GainAtMaxDistance - 1f) / (maxDistanceM - ReferenceDistanceM);
        }

        /// <summary>
        /// Check if an event needs action from one of discrete triggers
        /// </summary>
        /// <param name="eventID">Occured event</param>
        public void HandleEvent(Event eventID)
        {
            foreach (var ss in SoundStreams)
            {
                foreach (var trg in ss.Triggers)
                {
                    var dt = trg as ORTSDiscreteTrigger;
                    if (dt != null)
                        dt.HandleEvent(eventID);
                }
            }
        }

        public override void InitInitials()
        {
            if (Car != null)
            {
                WorldLocation = Car.WorldPosition.WorldLocation;
            }

            if (isOutOfDistance())
            {
                if (!WasOutOfDistance)
                {
                    if (!Viewer.Simulator.updaterWorking)
                    {
                        foreach (SoundStream stream in SoundStreams)
                            stream.HardDeactivate();
                        WasOutOfDistance = true;
                    }
                }
                NeedsFrequentUpdate = false;
            }
            else
            {
                if (WasOutOfDistance)
                {
                    var ignore3D = WorldLocation == WorldLocation.None | Ignore3D | !IsExternal;
                    foreach (SoundStream stream in SoundStreams)
                    {
                        stream.HardActivate(ignore3D);

                        bool released = false;
                        // run the initial triggers
                        foreach (ORTSTrigger trigger in stream.Triggers)
                        {
                            trigger.Initialize();
                            trigger.TryTrigger();

                            released |= trigger.Signaled &&
                                (trigger.SoundCommand is ORTSReleaseLoopRelease || trigger.SoundCommand is ORTSReleaseLoopReleaseWithJump);
                            if (trigger is ORTSDiscreteTrigger) trigger.Signaled = false;
                        }

                        if (!released && !stream.ALSoundSource.isPlaying)
                        {
                            foreach (ORTSTrigger trigger in stream.Triggers)
                            {
                                if (trigger.Signaled && trigger.Enabled && (trigger.SoundCommand is ORTSStartLoop || trigger.SoundCommand is ORTSStartLoopRelease))
                                    trigger.SoundCommand.Run();
                            }
                        }
                    }
                }
                WasOutOfDistance = false;
            }
        }
        
        public override bool Update()
        {
            if (Car != null && !Car.IsPartOfActiveTrain)
                return false;

            InitInitials();

            if (WasOutOfDistance)
            {
                // It is still needed to try out-of-distance variable triggers, to handle their start and release events, so they will be in
                // correct state when get into scope again. Discrete triggers have their HandleEvent() function to achieve this,
                // but there is no such thing for variable triggers.
                foreach (var stream in SoundStreams)
                    foreach (var trigger in stream.VariableTriggers)
                        trigger.TryTrigger();

                return true;
            }

            if (!Active)
            {
                if (Activate())
                {
                    Active = true;

                    // restore any looping sounds
                    foreach(SoundStream stream in SoundStreams)
                        stream.Activate();
                }
            }
            else
            {
                if (DeActivate())
                {
                    foreach (SoundStream stream in SoundStreams)
                        stream.Deactivate();

                    Active = false;
                }
            }

            bool needsFrequentUpdate = false;

            if (Car == null && WorldLocation != WorldLocation.None && !Ignore3D && IsExternal)
            {
                WorldLocation.NormalizeTo(Camera.SoundBaseTile.X, Camera.SoundBaseTile.Y);
                float[] position = new float[] {
                    WorldLocation.Location.X,
                    WorldLocation.Location.Y,
                    WorldLocation.Location.Z};

                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update(position);
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            else
            {
                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update();
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            NeedsFrequentUpdate = needsFrequentUpdate;

            return true;
        } // Update

        /// <summary>
        /// Calculate current distance to camera, and compare it to <see cref="CutOffDistanceM2"/>
        /// </summary>
        /// <returns>True, if is now out-of-scope</returns>
        public bool isOutOfDistance()
        {
            if (WorldLocation == WorldLocation.None)
            {
                DistanceSquared = 0;
                return false;
            }

            if (float.IsNaN(WorldLocation.Location.X) ||
                float.IsNaN(WorldLocation.Location.Y) ||
                float.IsNaN(WorldLocation.Location.Z))
            {
                DistanceSquared = float.MaxValue;
                return true;
            }

            DistanceSquared = WorldLocation.GetDistanceSquared(WorldLocation, Viewer.Camera.CameraWorldLocation);

            return DistanceSquared > CutOffDistanceM2;
        }

        /// <summary>
        /// Check if activation conditions are met,
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool Activate()
        {
            if (ActivationConditions == null)
                return false;

            if (ConditionsMet(ActivationConditions))
            {
                if (WorldLocation != WorldLocation.None)
                {
                    // (ActivationConditions.Distance == 0) means distance checking disabled
                    if ((ActivationConditions.Distance == 0 || DistanceSquared < ActivationConditions.Distance * ActivationConditions.Distance) &&
                        DistanceSquared < CutOffDistanceM2)
                        return true;
                }
                else
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Check if deactivation conditions are met
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool DeActivate()
        {
            if (DeactivationConditions == null)
                return false;
         
            if (ConditionsMet(DeactivationConditions))
                return true;

            if (WorldLocation != WorldLocation.None)
            {
                if (DeactivationConditions.Distance != 0 && DistanceSquared > DeactivationConditions.Distance * DeactivationConditions.Distance ||
                    DistanceSquared > CutOffDistanceM2)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns true if SoundSource belongs to a cabview of a vehicle not currently watched. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool IsntThisCabView
        {
            get
            {
                return (Viewer.Camera.Style == Camera.Styles.Cab || Viewer.Camera.Style == Camera.Styles.ThreeDimCab || Viewer.Camera.Style == Camera.Styles.Passenger) && (Viewer.Camera.AttachedCar != Car);
            }
        }

        /// <summary>
        /// Returns true if SoundSource is a weather sound. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool WeatherSound { get { return Viewer.World.WeatherControl.WeatherSounds.Contains(this); } }

        /// <summary>
        /// Hack for enabling additional cab sounds (like radio sounds) of an attached (maybe invisible) car. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        /// <returns></returns>
        private bool IsInvisibleSoundCar
        {
            get
            {
                return (!IsEnvSound && !IsExternal && (Viewer.Camera.Style == Camera.Styles.Cab || Viewer.Camera.Style == Camera.Styles.ThreeDimCab)
                    && Car != null && Viewer.Camera.AttachedCar != null && !(Car is MSTSLocomotive) && !Car.HasInsideView && Car.PassengerViewpoints.Count == 0
                    && (Car.Train == Viewer.Camera.AttachedCar.Train || Car.Train.TrainType == Train.TRAINTYPE.STATIC || Car.Train.TrainType == Train.TRAINTYPE.AI_NOTSTARTED));
            }
        }

        /// <summary>
        /// Return true of the ViewPoint matches any of the ones specified in the conditions
        /// for activation or deactivation.
        /// </summary>
        /// <param name="conditions"></param>
        /// <returns></returns>
        private bool ConditionsMet(Orts.Formats.Msts.Activation conditions)
        {
            if (conditions == null)
                return false;

            Camera.Styles viewpoint = Viewer.Camera.Style;

            if (IsEnvSound || !IsEnvSound && IsntThisCabView && !IsInvisibleSoundCar && !WeatherSound)
            {
                viewpoint = Camera.Styles.External;
            }

            if (conditions.CabCam && (viewpoint == Camera.Styles.Cab || viewpoint == Camera.Styles.ThreeDimCab))
                return true;
            if (conditions.PassengerCam && viewpoint == Camera.Styles.Passenger)
                return true;
            if (conditions.ExternalCam && viewpoint == Camera.Styles.External)
                return true;

            return false;
        }

        public override void Dispose()
        {
            if (SoundStreams != null)
            {
                foreach (SoundStream s in SoundStreams)
                    s.Dispose();
                SoundStreams.Clear();
            }
            Car = null;
        }
    }

/////////////////////////////////////////////////////////
// SOUND STREAM
/////////////////////////////////////////////////////////
        
    /// <summary>
    /// Owned by a <see cref="SoundSource"/>,
    /// can play only one sound at a time,
    /// the sound played is controlled by the various triggers
    /// </summary>
    public class SoundStream : IDisposable
    {
        /// <summary>
        /// Owner SoundSource
        /// </summary>
        public SoundSource SoundSource;
        /// <summary>
        /// Stream's volume can be controlled independently of the SoundSource's
        /// </summary>
        public float Volume;
        /// <summary>
        /// List of triggers controlling this stream
        /// </summary>
        public List<ORTSTrigger> Triggers = new List<ORTSTrigger>();
        /// <summary>
        /// OpenAL compatible representation of SoundStream.
        /// By OpenAL terminilogy our SoundStream is called as "SoundSource"
        /// </summary>
        public ALSoundSource ALSoundSource { get; private set; }
        /// <summary>
        /// A stream as is represented in sms file
        /// </summary>
        protected Orts.Formats.Msts.SMSStream MSTSStream;
        /// <summary>
        /// Each stream can contain only one initial trigger, which should be audible
        /// in case the SoundSource is in scope, and no other variable trigger is active
        /// </summary>
        private ORTSInitialTrigger _InitialTrigger;
        /// <summary>
        /// If soundstream needs active management by sound process, or can be left to OpenAL
        /// </summary>
        public bool NeedsFrequentUpdate;
        /// <summary>
        /// If stream contains a release trigger with jump, looping cannot be handled fully by OpenAL.
        /// Sound process needs to watch carefully for jump command
        /// </summary>
        public bool IsReleasedWithJump;
        /// <summary>
        /// Store trigger used last time for being able to check if trigger got repeated
        /// </summary>
        public ORTSTrigger LastTriggered = new ORTSTrigger();
        /// <summary>
        /// True if the same trigger was used repeatedly.
        /// Needs for avoiding to queue same sound multiple times
        /// in case the player keeps hitting the keyboard
        /// </summary>
        public bool RepeatedTrigger;
        /// <summary>
        /// List of owned variable triggers. Used at determining if initial trigger is to be audible
        /// </summary>
        public List<ORTSTrigger> VariableTriggers = new List<ORTSTrigger>();
        /// <summary>
        /// Helper object for determining if initial trigger is to be audible
        /// </summary>
        IEnumerable<ORTSTrigger> TriggersList;

        public SoundStream(Orts.Formats.Msts.SMSStream mstsStream, Events.Source eventSource, SoundSource soundSource, UserSettings settings)
        {
            SoundSource = soundSource;
            MSTSStream = mstsStream;
            Volume = MSTSStream.Volume;

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, soundSource.RolloffFactor);

            if (mstsStream.Triggers != null)
                foreach (Orts.Formats.Msts.Trigger trigger in mstsStream.Triggers)
                {
                    if (trigger.SoundCommand == null) // ignore improperly formed SMS files
                    {
                        Triggers.Add(new ORTSTrigger()); // null trigger
                    }
                    else if (trigger.GetType() == typeof(Orts.Formats.Msts.Dist_Travelled_Trigger) && soundSource.Car != null)
                    {
                        Triggers.Add(new ORTSDistanceTravelledTrigger(this, (Orts.Formats.Msts.Dist_Travelled_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(Orts.Formats.Msts.Initial_Trigger))
                    {
                        _InitialTrigger = new ORTSInitialTrigger(this, (Orts.Formats.Msts.Initial_Trigger)trigger);
                        Triggers.Add(_InitialTrigger);
                    }
                    else if (trigger.GetType() == typeof(Orts.Formats.Msts.Random_Trigger))
                    {
                        Triggers.Add(new ORTSRandomTrigger(this, (Orts.Formats.Msts.Random_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(Orts.Formats.Msts.Variable_Trigger) && (soundSource.Car != null || soundSource.IsEnvSound))
                    {
                        Triggers.Add(new ORTSVariableTrigger(this, (Orts.Formats.Msts.Variable_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(Orts.Formats.Msts.Discrete_Trigger) && soundSource.Car != null)
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, eventSource, (Orts.Formats.Msts.Discrete_Trigger)trigger, settings);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable
                        try
                        {
                            SoundSource.Car.EventHandlers.Add(ortsTrigger);  // tell the simulator to call us when the event occurs
                        }
                        catch (Exception error)
                        {
                            Trace.TraceInformation("Sound event skipped due to thread safety problem " + error.Message);
                        }
                    }
                    else if (trigger.GetType() == typeof(Orts.Formats.Msts.Discrete_Trigger))
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, eventSource, (Orts.Formats.Msts.Discrete_Trigger)trigger, settings);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable 
                    }
                        // unapplicable trigger type
                    else
                    {
                        Triggers.Add(new ORTSTrigger()); // null trigger
                        if (SoundSource.SMSFileName != "ingame.sms") Trace.TraceWarning("Trigger type of trigger number {2} in stream number {1} in file {0} is not existent or not applicable",
                            SoundSource.SMSFileName, SoundSource.SoundStreams.Count, Triggers.Count-1);
                    }
                    IsReleasedWithJump |= (Triggers.Last().SoundCommand is ORTSReleaseLoopReleaseWithJump);
                }  // for each mstsStream.Trigger

            VariableTriggers = (from t in Triggers 
                                where t is ORTSVariableTrigger
                                select t).ToList();
        }

        public SoundStream(string wavFileName, Events.Source eventSource, SoundSource soundSource)
        {
            SoundSource = soundSource;
            Volume = 1.0f;

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, soundSource.RolloffFactor);

            _InitialTrigger = new ORTSInitialTrigger(this, wavFileName);
            Triggers.Add(_InitialTrigger);

        }

        /// <summary>
        /// Create a sound stream with an arbitrary set of triggers.
        /// </summary>
        /// <param name="soundSource">The parent sound source.</param>
        /// <param name="makeTriggers">A generator function to create the triggers.</param>
        public SoundStream(SoundSource soundSource, Func<SoundStream, IEnumerable<ORTSTrigger>> makeTriggers)
        {
            SoundSource = soundSource;
            Volume = 1.0f;

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, soundSource.RolloffFactor);
            Triggers.AddRange(makeTriggers(this));
        }

        /// <summary>
        /// Update OpenAL sound source position, then calls the main <see cref="Update()"/> function
        /// Position is relative to camera tile's center
        /// </summary>
        /// <param name="position"></param>
        public void Update(float[] position)
        {
            OpenAL.alSourcefv(ALSoundSource.SoundSourceID, OpenAL.AL_POSITION, position);
            Update();
        }

        /// <summary>
        /// Try triggers, update frequency and volume according to curves, call queue management
        /// </summary>
        public void Update()
        {
            if (ALSoundSource == null)
            {
                return;
            }

            foreach (ORTSTrigger trigger in Triggers)
                trigger.TryTrigger();
            
            if (_InitialTrigger != null)
            {
                // If no triggers active, Initialize the Initial
                if (!ALSoundSource.isPlaying)
                {
                    if (VariableTriggers.Count > 0 || Triggers.Count == 1)
                    {
                        TriggersList = from ORTSVariableTrigger t in VariableTriggers
                                                where t.IsBellow
                                                select t as ORTSTrigger;
                        if (TriggersList.Count() == VariableTriggers.Count && _InitialTrigger.SoundCommand is ORTSSoundPlayCommand
                            && !(_InitialTrigger.SoundCommand is ORTSPlayOneShot && _InitialTrigger.Signaled))
                        {
                            _InitialTrigger.Initialize();
                        }
                    }
                }
                // If triggers are active, reset the Initial
                else
                {
                    TriggersList = from t in Triggers
                             where t.Signaled &&
                             (t.SoundCommand is ORTSStartLoop || t.SoundCommand is ORTSStartLoopRelease)
                             select t;
                    if (TriggersList.Count() > 1 && _InitialTrigger.Signaled)
                        _InitialTrigger.Signaled = false;
                }
            }

            SetFreqAndVolume();

            ALSoundSource.Update();
            NeedsFrequentUpdate |= ALSoundSource.NeedsFrequentUpdate;
        }

        /// <summary>
        /// Calculate frequency and volume according to curves defined in sms file
        /// </summary>
        private void SetFreqAndVolume()
        {
            if (ALSoundSource == null)
                return;

            if (MSTSStream != null && MSTSStream.FrequencyCurve != null) 
            {
                if (SoundSource.Car != null || SoundSource.Viewer.Camera.AttachedCar != null)
                {
                    float x = 0;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Control, SoundSource.Car);
                    else if (SoundSource.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Control, (MSTSWagon)SoundSource.Viewer.Camera.AttachedCar);
                    float y = Interpolate(x, MSTSStream.FrequencyCurve);
                    if (SoundSource.MstsMonoTreatment && ALSoundSource.MstsMonoTreatment)
                        y *= 2;

                    ALSoundSource.PlaybackSpeed = y / ALSoundSource.SampleRate;
                    NeedsFrequentUpdate = x != 0;
                }
            }

            float volume = SoundSource.Volume * Volume;

            if (MSTSStream != null && MSTSStream.VolumeCurves.Count > 0)
                for (int i = 0; i < MSTSStream.VolumeCurves.Count; i++)
                {
                    float x;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Control, SoundSource.Car);
                    else if (SoundSource.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Control, (MSTSWagon)SoundSource.Viewer.Camera.AttachedCar);
                    else
                        x = SoundSource.DistanceSquared;

                    volume *= Interpolate(x, MSTSStream.VolumeCurves[i]);
                }

            if (SoundSource.Viewer.Camera.Style != Camera.Styles.External)
            {
                var wag = (MSTSWagon)SoundSource.Viewer.Camera.AttachedCar;
                var soundHeardInternallyCorrection = Math.Min(wag.SoundHeardInternallyCorrection[0] + wag.SoundHeardInternallyCorrection[1], 1);
                if (SoundSource.IsExternal && !SoundSource.IsUnattenuated)
                {
                    if (wag == null || wag.ExternalSoundPassThruPercent == -1)
                        volume *= Program.Viewer.Settings.ExternalSoundPassThruPercent * 0.01f + (1 - Program.Viewer.Settings.ExternalSoundPassThruPercent * 0.01f) * soundHeardInternallyCorrection;
                    else volume *= wag.ExternalSoundPassThruPercent * 0.01f + (1 - wag.ExternalSoundPassThruPercent * 0.01f) * soundHeardInternallyCorrection;
                }

                if (SoundSource.IsInternalTrackSound)
                {
                    if (wag?.TrackSoundPassThruPercent != -1)
                        volume *= wag.TrackSoundPassThruPercent * 0.01f + (1 - wag.TrackSoundPassThruPercent * 0.01f) * soundHeardInternallyCorrection;
                }
            }

            if (SoundSource.IsInternalTrackSound && SoundSource.Viewer.Camera.Style != Camera.Styles.External)
            {
                if (((MSTSWagon)SoundSource.Viewer.Camera.AttachedCar)?.TrackSoundPassThruPercent != -1)
                    volume *= ((MSTSWagon)SoundSource.Viewer.Camera.AttachedCar).TrackSoundPassThruPercent * 0.01f;
            }

            // check if time of day, season and weather enable the sound; if not, set volume to zero
            if (MSTSStream?.TimeIntervals != null)
            {
                var outOfInterval = true;
                foreach (var timeInterval in MSTSStream.TimeIntervals)
                {
                    int hourOfDay = (int)SoundSource.Viewer.Simulator.ClockTime / 3600;
                    if (hourOfDay >= timeInterval[0] && hourOfDay < timeInterval[1])
                    {
                        outOfInterval = false;
                        break;
                    }
                }
                if (outOfInterval)
                    volume = 0;
            }
            if (MSTSStream?.Season != null )
            {
                if (!MSTSStream.Season[(int)(SoundSource.Viewer.Simulator.Season)])
                    volume = 0;
            }
            if (MSTSStream?.Weather != null )
            {
                if (!MSTSStream.Weather[(int)(SoundSource.Viewer.Simulator.WeatherType)])
                    volume = 0;
            }
            ALSoundSource.Volume = volume;
        }

        /// <summary>
        /// There must be at least two points in the curve
        /// // TODO do we need to implement support for Granularity()
        /// </summary>
        /// <param name="x"></param>
        /// <param name="Curve"></param>
        /// <returns></returns>
        static float Interpolate(float x, Orts.Formats.Msts.VolumeCurve Curve)
        {
            if (Curve.CurvePoints.Count() < 2)
                return Curve.CurvePoints[0].Y;

            Orts.Formats.Msts.CurvePoint[] curvePoints = Curve.CurvePoints;

            if (x < curvePoints[0].X)
                return curvePoints[0].Y;
            if (x > curvePoints[curvePoints.Length - 1].X)
                return curvePoints[curvePoints.Length - 1].Y;

            int i = 1;
            while (i < curvePoints.Length - 1
                && curvePoints[i].X < x) ++i;
            // i points to the point equal to or above x, or to the last point in the table

            x -= curvePoints[i - 1].X;
            float rx = x / (curvePoints[i].X - curvePoints[i - 1].X);

            float dy = curvePoints[i].Y - curvePoints[i - 1].Y;

            float y = curvePoints[i - 1].Y + rx * dy;

            return y;
        }

        /// <summary>
        /// Read a variable from the attached TrainCar data
        /// </summary>
        /// <param name="control"></param>
        /// <param name="car"></param>
        /// <returns></returns>
        private float ReadValue(Orts.Formats.Msts.VolumeCurve.Controls control, MSTSWagon car)
        {
            switch (control)
            {
                case Orts.Formats.Msts.VolumeCurve.Controls.DistanceControlled: return SoundSource.DistanceSquared;
                case Orts.Formats.Msts.VolumeCurve.Controls.SpeedControlled: return car.AbsSpeedMpS;
                case Orts.Formats.Msts.VolumeCurve.Controls.Variable1Controlled: return car.Variable1;
                case Orts.Formats.Msts.VolumeCurve.Controls.Variable1_2Controlled: return car.Variable1_2;
                case Orts.Formats.Msts.VolumeCurve.Controls.Variable1_3Controlled: return car.Variable1_3;
                case Orts.Formats.Msts.VolumeCurve.Controls.Variable1_4Controlled: return car.Variable1_4;
                case Orts.Formats.Msts.VolumeCurve.Controls.Variable2BoosterControlled: return car.Variable2_Booster;
                case Orts.Formats.Msts.VolumeCurve.Controls.Variable2Controlled: return car.Variable2;
                case Orts.Formats.Msts.VolumeCurve.Controls.Variable3Controlled: return car.Variable3;
                case Orts.Formats.Msts.VolumeCurve.Controls.BrakeCylControlled: return car.BrakeSystem.GetCylPressurePSI();
                case Orts.Formats.Msts.VolumeCurve.Controls.CurveForceControlled: return car.CurveForceNFiltered;
                default: return 0;
            }
        }

        /// <summary>
        /// Stop OpenAL playing this stream, and flush buffers
        /// </summary>
        public void Stop()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Stop();
            }
        }

        /// <summary>
        /// Restore any previously playing sounds
        /// </summary>
        public void Activate()
        {
            if (ALSoundSource != null)
            {
                // Precalc volume to avoid glitches
                SetFreqAndVolume();
                ALSoundSource.Active = true;
            }
        }

        /// <summary>
        /// Deactivates a previously active sound
        /// </summary>
        public void Deactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Active = false;
                ALSoundSource.HardDeactivate();
            }
        }

        /// <summary>
        /// Allocates a new sound source ID in OpenAL, if one is not allocated yet.
        /// </summary>
        /// <param name="ignore3D">Whether the stream's world position should be ignored</param>
        public void HardActivate(bool ignore3D)
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardActivate(ignore3D, SoundSource.Car);
            }
        }

        /// <summary>
        /// Frees up the allocated sound source ID, and tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        public void HardDeactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardDeactivate();
            }
            Sweep();
        }

        public void Dispose()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardDeactivate();
                ALSoundSource.Dispose();
                ALSoundSource = null;
            }
            Sweep();
        }

        /// <summary>
        /// Tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        private void Sweep()
        {
            foreach (var trigger in Triggers)
                if (trigger.SoundCommand is ORTSSoundPlayCommand)
                    foreach (var name in (trigger.SoundCommand as ORTSSoundPlayCommand).Files)
                        SoundItem.Sweep(name, SoundSource.IsExternal, IsReleasedWithJump);
        }

    } // class ORTSStream

/////////////////////////////////////////////////////////
// SOUND TRIGGERS
/////////////////////////////////////////////////////////

    /// <summary>
    /// Trigger is defined in the SMS file as members of a SoundStream.
    /// They are activated by various events.
    /// When triggered, executes a SoundCommand
    /// </summary>
    public class ORTSTrigger
    {
        /// <summary>
        /// Set by the DisableTrigger, EnableTrigger sound commands
        /// </summary>
        public bool Enabled = true;
        /// <summary>
        /// True if trigger activation conditions are met
        /// </summary>
        public bool Signaled;
        /// <summary>
        /// Represents a sound command to be executed, when trigger is activated
        /// </summary>
        public ORTSSoundCommand SoundCommand;

        /// <summary>
        /// Check in every update loop whether to activate the trigger
        /// </summary>
        public virtual void TryTrigger() { }
        /// <summary>
        /// Executed in constructors, or when sound source gets into scope, or for InitialTrigger when other VariableTriggers stop working
        /// </summary>
        public virtual void Initialize() { }
    }


    /// <summary>
    /// Play this sound when a discrete TrainCar event occurs in the simulator
    /// </summary>
    public class ORTSDiscreteTrigger: ORTSTrigger, Orts.Common.EventHandler
    {
        /// <summary>
        /// Event this trigger listens to
        /// </summary>
        public Event TriggerID;
        /// <summary>
        /// Store the owning SoundStream
        /// </summary>
        private SoundStream SoundStream;
        /// <summary>
        /// This flag is set by Updater process, and is used by Sound process to activate the trigger
        /// </summary>
        private bool Triggered;

        public ORTSDiscreteTrigger(SoundStream soundStream, Events.Source eventSound, Orts.Formats.Msts.Discrete_Trigger smsData, UserSettings settings)
        {
            TriggerID = Events.From(eventSound, smsData.TriggerID);
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        /// <summary>
        /// Construct a discrete sound trigger with an arbitrary event trigger and sound command.
        /// </summary>
        /// <param name="soundStream">The parent sound stream.</param>
        /// <param name="triggerID">The trigger to activate this event.</param>
        /// <param name="soundCommand">The command to run when activated.</param>
        public ORTSDiscreteTrigger(SoundStream soundStream, Event triggerID, ORTSSoundCommand soundCommand)
        {
            TriggerID = triggerID;
            SoundCommand = soundCommand;
            SoundStream = soundStream;
        }

        /// <summary>
        /// Check if this trigger listens to an event
        /// </summary>
        /// <param name="eventID">Occured event</param>
        public void HandleEvent(Event eventID)
        {
            if (eventID == TriggerID)
            {
                Triggered = true;
            }
        }

        /// <summary>
        /// Check if this trigger listens to an event, and if also belongs to the object
        /// </summary>
        /// <param name="eventID">Occured event</param>
        /// <param name="viewer">Object the event belongs to</param>
        public void HandleEvent(Event eventID, object viewer)
        {
            if (eventID == TriggerID)
            {
                try
                {
                    if (Program.Viewer.SoundProcess.IsSoundSourceOwnedBy(viewer, SoundStream.SoundSource))
                    {
                        Triggered = true;
                    }
                }
                catch
                {
                    return;
                }
            }
        }

        public override void TryTrigger()
        {
            Triggered &= Enabled;
            if (Triggered)
            {
                Triggered = false;
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
                Signaled = true;
#if DEBUGSCR
                if (SoundCommand is ORTSSoundPlayCommand && !string.IsNullOrEmpty((SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]))
                    Console.WriteLine("({0})DiscreteTrigger: {1}:{2}", SoundStream.ALSoundSource.SoundSourceID, TriggerID, (SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]);
                else
                    Console.WriteLine("({0})DiscreteTrigger: {1}", SoundStream.ALSoundSource.SoundSourceID, TriggerID);
#endif
            }
            // If the SoundSource is not active, should deactivate the SoundStream also
            //   preventing the hearing when not should be audible
            if (!SoundStream.SoundSource.Active)
                SoundStream.Deactivate();
        }

    } // class ORTSDiscreteTrigger

    /// <summary>
    /// Play this sound controlled by the distance a TrainCar has travelled
    /// </summary>
    public sealed class ORTSDistanceTravelledTrigger : ORTSTrigger
    {
        Orts.Formats.Msts.Dist_Travelled_Trigger SMS;
        float triggerDistance;
        TrainCar car;
        SoundStream SoundStream;

        public ORTSDistanceTravelledTrigger(SoundStream soundStream, Orts.Formats.Msts.Dist_Travelled_Trigger smsData)
        {
            SoundStream = soundStream;
            car = soundStream.SoundSource.Car;
            SMS = smsData;
            SoundCommand = ORTSSoundCommand.FromMSTS(SMS.SoundCommand, soundStream );
            Initialize();
        }

        public override void Initialize()
        {
            UpdateTriggerDistance();
        }

        public override void TryTrigger()
        {
            if (car.DistanceM > triggerDistance)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)Viewer.Random.NextDouble() * (SMS.Volume_Max - SMS.Volume_Min) + SMS.Volume_Min;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerDistance();
#if DEBUGSCR
                Console.WriteLine("({0})DistanceTravelledTrigger: Current:{1}, Next:{2}", SoundStream.ALSoundSource.SoundSourceID, car.DistanceM, triggerDistance);
#endif

            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate a new random distance to travel till the next trigger action
        /// </summary>
        private void UpdateTriggerDistance()
        {
            if (SMS.Dist_Max != SMS.Dist_Min)
            {
                triggerDistance = car.DistanceM + ((float)Viewer.Random.NextDouble() * (SMS.Dist_Max - SMS.Dist_Min) + SMS.Dist_Min);
            }
            else
            {
                triggerDistance = car.DistanceM + ((float)Viewer.Random.NextDouble() * (SMS.Dist_Min) + SMS.Dist_Min);
            }
        }

    } // class ORTSDistanceTravelledTrigger

    /// <summary>
    /// Play this sound immediately when this SoundSource becomes active, or in case no other VariableTriggers are active
    /// </summary>
    public class ORTSInitialTrigger: ORTSTrigger
    {
        private SoundStream SoundStream;

        public ORTSInitialTrigger(SoundStream soundStream, Orts.Formats.Msts.Initial_Trigger smsData)
        {
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        // For pre-compiled activity sound
        public ORTSInitialTrigger(SoundStream soundStream, string wavFileName)
        {
            SoundCommand = ORTSSoundCommand.Precompiled(wavFileName, soundStream);
            SoundStream = soundStream;
        }

        public override void Initialize()
        {
            if (Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
#if DEBUGSCR
                if (SoundCommand is ORTSSoundPlayCommand && !string.IsNullOrEmpty((SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]))
                    Console.WriteLine("({0})InitialTrigger: {1}", SoundStream.ALSoundSource.SoundSourceID, (SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]);
#endif
            }

            Signaled = true;
        }

    }

    /// <summary>
    /// Play the sound at random times
    /// </summary>
    public sealed class ORTSRandomTrigger : ORTSTrigger
    {
        Simulator Simulator;
        Orts.Formats.Msts.Random_Trigger SMS;
        double triggerAtSeconds;
        SoundStream SoundStream;

        public ORTSRandomTrigger(SoundStream soundStream, Orts.Formats.Msts.Random_Trigger smsData)
        {
            SoundStream = soundStream;
            SMS = smsData;
            Simulator = soundStream.SoundSource.Viewer.Simulator;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
            UpdateTriggerAtSeconds();
        }

        public override void TryTrigger()
        {
            if (Simulator.ClockTime > triggerAtSeconds)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)Viewer.Random.NextDouble() * (SMS.Volume_Max - SMS.Volume_Min) + SMS.Volume_Min;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerAtSeconds();
            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate new random time till the next triggering action
        /// </summary>
        private void UpdateTriggerAtSeconds()
        {
            double interval = Viewer.Random.NextDouble() * (SMS.Delay_Max - SMS.Delay_Min) + SMS.Delay_Min;
            triggerAtSeconds = Simulator.ClockTime + interval;
        }

    }  // class RandomTrigger

    /// <summary>
    /// Control sounds based on TrainCar variables in the simulator 
    /// </summary>
    public sealed class ORTSVariableTrigger : ORTSTrigger
    {
        Orts.Formats.Msts.Variable_Trigger SMS;
        MSTSWagon car;
        SoundStream SoundStream;

        float StartValue;
        public bool IsBellow;

        public ORTSVariableTrigger(SoundStream soundStream, Orts.Formats.Msts.Variable_Trigger smsData)
        {
            SMS = smsData;
            car = soundStream.SoundSource.Car != null ? soundStream.SoundSource.Car : (MSTSWagon)soundStream.SoundSource.Viewer.Camera.AttachedCar;
            SoundStream = soundStream;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
            StartValue = SMS.Event == Orts.Formats.Msts.Variable_Trigger.Events.Distance_Dec_Past ? float.MaxValue : 0;

            /*if ((new Variable_Trigger.Events[] { Variable_Trigger.Events.Variable1_Dec_Past,
                Variable_Trigger.Events.Variable1_Inc_Past, Variable_Trigger.Events.Variable2_Dec_Past, 
                Variable_Trigger.Events.Variable2_Inc_Past, Variable_Trigger.Events.Variable3_Dec_Past,
                Variable_Trigger.Events.Variable3_Inc_Past}).Contains(SMS.Event) && SMS.Threshold >= 1)
            {
                SMS.Threshold /= 100f;
            }*/
            IsBellow = StartValue < SMS.Threshold;
        }

        public override void TryTrigger( )
        {
            float newValue = ReadValue();
            bool triggered = false;
            Signaled = false;

            switch (SMS.Event)
            {
                case Orts.Formats.Msts.Variable_Trigger.Events.Distance_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Speed_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_2_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_3_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_4_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable2_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable3_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.BrakeCyl_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.CurveForce_Dec_Past:
                    if (newValue < SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold <= StartValue)
                            triggered = true;
                    }
                    break;
                case Orts.Formats.Msts.Variable_Trigger.Events.Distance_Inc_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Speed_Inc_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_Inc_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_2_Inc_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_3_Inc_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_4_Inc_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable2_Inc_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable3_Inc_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.BrakeCyl_Inc_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.CurveForce_Inc_Past:
                    if (newValue > SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold >= StartValue)
                            triggered = true;
                    }
                    break;
            }

            //Signaled = triggered;

            StartValue = newValue;
            IsBellow = newValue < SMS.Threshold;

            if (triggered && Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;

#if DEBUGSCR
                ORTSStartLoop sl = SoundCommand as ORTSStartLoop;
                if (sl != null)
                {
                    Console.WriteLine("({0})StartLoop ({1} {2}): {3} ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString(), sl.Files[sl.iFile]);
                }
                ORTSStartLoopRelease slr = SoundCommand as ORTSStartLoopRelease;
                if (slr != null)
                {
                    Console.WriteLine("({0})StartLoopRelease ({1} {2}): {3} ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString(), slr.Files[slr.iFile]);
                }
                ORTSReleaseLoopRelease rlr = SoundCommand as ORTSReleaseLoopRelease;
                if (rlr != null)
                {
                    Console.WriteLine("({0})ReleaseLoopRelease ({1} {2}) ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString());
                }
                ORTSReleaseLoopReleaseWithJump rlrwj = SoundCommand as ORTSReleaseLoopReleaseWithJump;
                if (rlrwj != null)
                {
                    Console.WriteLine("({0})ReleaseLoopReleaseWithJump ({1} {2}) ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString());
                }
#endif
            }
        }

        /// <summary>
        /// Read the desired variable either from the attached TrainCar, or the distance to sound source
        /// </summary>
        /// <returns></returns>
        private float ReadValue()
        {
            switch (SMS.Event)
            {
                case Orts.Formats.Msts.Variable_Trigger.Events.Distance_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Distance_Inc_Past:
                    return SoundStream.SoundSource.DistanceSquared;
                case Orts.Formats.Msts.Variable_Trigger.Events.Speed_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Speed_Inc_Past:
                    return car.AbsSpeedMpS;
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_Inc_Past:
                    return car.Variable1;
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_2_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_2_Inc_Past:
                    return car.Variable1_2;
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_3_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_3_Inc_Past:
                    return car.Variable1_3;
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_4_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable1_4_Inc_Past:
                    return car.Variable1_4;
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable2_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable2_Inc_Past:
                    return car.Variable2;
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable3_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.Variable3_Inc_Past:
                    return car.Variable3;
                case Orts.Formats.Msts.Variable_Trigger.Events.BrakeCyl_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.BrakeCyl_Inc_Past:
                    return car.BrakeSystem.GetCylPressurePSI();
                case Orts.Formats.Msts.Variable_Trigger.Events.CurveForce_Dec_Past:
                case Orts.Formats.Msts.Variable_Trigger.Events.CurveForce_Inc_Past:
                    return car.CurveForceNFiltered;
                default:
                    return 0;
            }
        }

    }  // class VariableTrigger


/////////////////////////////////////////////////////////
// SOUND COMMANDS
/////////////////////////////////////////////////////////
    

    /// <summary>
    /// Start playing the whole sound stream once, then stop
    /// </summary>
    public class ORTSPlayOneShot : ORTSSoundPlayCommand
    {
        public ORTSPlayOneShot(SoundStream ortsStream, Orts.Formats.Msts.SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream, mstsSoundPlayCommand)
        {
        }
        // precompiled version for activity sounds
        public ORTSPlayOneShot(SoundStream ortsStream, string wavFileName)
            : base(ortsStream, wavFileName)
        {
        }

        public override void Run()
        {
            string p = GetNextFile();
            if (p != "")
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.OneShot, ORTSStream.SoundSource.IsExternal, ORTSStream.RepeatedTrigger);
            }
        }
    } 

    /// <summary>
    /// Start looping the whole stream, release it only at the end
    /// </summary>
    public class ORTSStartLoop : ORTSSoundPlayCommand
    {
        public ORTSStartLoop( SoundStream ortsStream, Orts.Formats.Msts.SoundPlayCommand mstsSoundPlayCommand )
            : base( ortsStream, mstsSoundPlayCommand )
        {
        }
        public override void  Run( )
        {
            // Support for Loop functions - by GeorgeS
            string p = GetNextFile();
            if (p != "")
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.Loop, ORTSStream.SoundSource.IsExternal, false);
            }
        }
    } 

    /// <summary>
    /// Release the sound by playing the looped sustain part till its end, then play the last part
    /// </summary>
    public class ORTSReleaseLoopRelease : ORTSSoundCommand
    {
        public ORTSReleaseLoopRelease(SoundStream ortsStream)
            : base(ortsStream)
        {
        }
        
        public override void Run()
        {
            if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                ORTSStream.ALSoundSource.Queue("", PlayMode.Release, ORTSStream.SoundSource.IsExternal, false);
        }
    }

    /// <summary>
    /// Start by playing the first part, then start looping the sustain part of the stream
    /// </summary>
    public class ORTSStartLoopRelease : ORTSSoundPlayCommand
    {
        public ORTSStartLoopRelease(SoundStream ortsStream, Orts.Formats.Msts.PlayOneShot mstsStartLoopRelease)
            : base(ortsStream, mstsStartLoopRelease)
        {
        }

        // Support for Loop functions - by GeorgeS
        public override void Run()
        {
            string p = GetNextFile();
            if (p != "")
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.LoopRelease, ORTSStream.SoundSource.IsExternal, ORTSStream.IsReleasedWithJump);
            }
        }
    }

    /// <summary>
    /// Release the sound by playing the looped sustain part till the next cue point, then jump to the last part and play that  
    /// </summary>
    public class ORTSReleaseLoopReleaseWithJump : ORTSSoundCommand
    {
        public ORTSReleaseLoopReleaseWithJump(SoundStream ortsStream)
            : base(ortsStream)
        {
        }

        public override void Run()
        {
            if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                ORTSStream.ALSoundSource.Queue("", PlayMode.ReleaseWithJump, ORTSStream.SoundSource.IsExternal, true);
        }
    }

    /// <summary>
    /// Shut down this stream trigger 
    /// </summary>
    public class ORTSDisableTrigger : ORTSSoundCommand
    {
        int TriggerIndex;  // index into the stream's trigger list 

        public ORTSDisableTrigger(SoundStream ortsStream, Orts.Formats.Msts.DisableTrigger smsData )
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerID - 1;
        }

        public override void Run()
        {
            if (TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = false;
        }
    }

    /// <summary>
    /// Re-enable this stream trigger
    /// </summary>
    public class ORTSEnableTrigger : ORTSSoundCommand
    {
        int TriggerIndex;

        public ORTSEnableTrigger(SoundStream ortsStream, Orts.Formats.Msts.DisableTrigger smsData)
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerID - 1;
        }

        public override void Run()
        {
            if ( TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = true;
        }
    }

    /// <summary>
    /// Set Volume of Stream
    /// </summary>
    public class ORTSSetStreamVolume : ORTSSoundCommand
    {
        float Volume;

        public ORTSSetStreamVolume(SoundStream ortsStream, Orts.Formats.Msts.SetStreamVolume smsData)
            : base(ortsStream)
        {
            Volume = smsData.Volume;
        }

        public override void Run()
        {
            ORTSStream.Volume = Volume;
        }
    }

    /// <summary>
    /// Used when the SMS file sound command is missing or malformed
    /// </summary>
    public class ORTSNoOp : ORTSSoundCommand
    {
        public ORTSNoOp()
            : base(null)
        {
        }
        public override void Run()
        {
        }
    }

    /// <summary>
    /// A base class for all sound commands
    /// Defines that they all have a stream and a 'Run()' function
    /// </summary>
    public abstract class ORTSSoundCommand
    {
        /// <summary>
        /// The Stream in .sms file it belongs to
        /// </summary>
        protected SoundStream ORTSStream;

        public ORTSSoundCommand(SoundStream ortsStream)
        {
            ORTSStream = ortsStream;
        }

        /// <summary>
        /// Put the command into stream's queue, or set its volume, or enable/disable other commands
        /// </summary>
        public abstract void Run();


        /// <summary>
        /// Create a sound command based on the sound command variable of a trigger in an SMS file.
        /// </summary>
        /// <param name="mstsSoundCommand"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand FromMSTS(Orts.Formats.Msts.SoundCommand mstsSoundCommand, SoundStream soundStream)
        {
            if (mstsSoundCommand == null)
            {
                return new ORTSNoOp();
            }
            else if (mstsSoundCommand.GetType() == typeof(Orts.Formats.Msts.PlayOneShot))
            {
                return new ORTSPlayOneShot(soundStream, (Orts.Formats.Msts.PlayOneShot)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(Orts.Formats.Msts.StartLoop))
            {
                return new ORTSStartLoop(soundStream, (Orts.Formats.Msts.StartLoop)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(Orts.Formats.Msts.StartLoopRelease))
            {
                return new ORTSStartLoopRelease(soundStream, (Orts.Formats.Msts.StartLoopRelease)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(Orts.Formats.Msts.ReleaseLoopRelease))
            {
                return new ORTSReleaseLoopRelease(soundStream);
            }
            else if (mstsSoundCommand.GetType() == typeof(Orts.Formats.Msts.ReleaseLoopReleaseWithJump))
            {
                return new ORTSReleaseLoopReleaseWithJump(soundStream);
            }
            else if (mstsSoundCommand.GetType() == typeof(Orts.Formats.Msts.SetStreamVolume))
            {
                return new ORTSSetStreamVolume(soundStream, (Orts.Formats.Msts.SetStreamVolume)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(Orts.Formats.Msts.DisableTrigger))
            {
                return new ORTSDisableTrigger(soundStream, (Orts.Formats.Msts.DisableTrigger)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(Orts.Formats.Msts.EnableTrigger))
            {
                return new ORTSEnableTrigger(soundStream, (Orts.Formats.Msts.EnableTrigger)mstsSoundCommand);
            }
            throw new ArgumentException("Unexpected soundCommand type " + mstsSoundCommand.GetType().ToString() + " in " + soundStream.SoundSource.SMSFolder, "mstsSoundCommand");
        }


        /// <summary>
        /// Create a pre-compiled sound command for activity files.
        /// </summary>
        /// <param name="wavFilePath"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand Precompiled(string wavFileName, SoundStream soundStream)
        {
            return new ORTSPlayOneShot(soundStream, wavFileName);        
        }

    }// ORTSSoundCommand


    /// <summary>
    /// A base class for commands that play a sound.
    /// Provides for selecting the sound from multiple files
    /// using a random or sequential selection strategy.
    /// </summary>
    public abstract class ORTSSoundPlayCommand : ORTSSoundCommand
    {
        /// <summary>
        /// File names to select from for playing
        /// </summary>
        public String[] Files;
        /// <summary>
        /// How to select from available files
        /// </summary>
        protected Orts.Formats.Msts.SoundCommand.SelectionMethods SelectionMethod;
        /// <summary>
        /// Index of the file to play inside <see cref="Files"/> vector
        /// </summary>
        public int iFile;

        public ORTSSoundPlayCommand(SoundStream ortsStream, Orts.Formats.Msts.SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream)
        {
            Files = mstsSoundPlayCommand.Files;
            SelectionMethod = mstsSoundPlayCommand.SelectionMethod;
        }

        // precompiled version for activity sounds
        public ORTSSoundPlayCommand(SoundStream ortsStream, string wavFileName)
            : base(ortsStream)
        {
            Files = new String[1];
            Files[0] = wavFileName;
            SelectionMethod = Orts.Formats.Msts.SoundCommand.SelectionMethods.SequentialSelection;
        }

        /// <summary>
        /// Select a file from the Files list using the SelectionMethod
        /// </summary>
        /// <returns>File name with full path </returns>
        protected string GetNextFile()
        {
            if (SelectionMethod == Orts.Formats.Msts.SoundCommand.SelectionMethods.SequentialSelection)
            {
                ++iFile;
                if (iFile >= Files.Length)
                    iFile = 0;
            }
            else if (SelectionMethod == Orts.Formats.Msts.SoundCommand.SelectionMethods.RandomSelection)
            {
                iFile = Viewer.Random.Next(Files.Length);
            }

            //<CJComment>SMSFolder is often same as BasePath, which means this searches the more general folder 
            // before the more specific folder. This is surely not intended.</CJComment>
            string[] pathArray = {ORTSStream.SoundSource.SMSFolder, 
                                     Program.Simulator.RoutePath + @"\SOUND", 
                                     Program.Simulator.BasePath + @"\SOUND"};
            var fullPath = ORTSPaths.GetFileFromFolders(pathArray, Files[iFile]);
            return (fullPath != null) ? fullPath : "";
        }
    }

    public class WorldSounds
    {
        Dictionary<string, List<WorldSoundRegion>> SoundRegions = new Dictionary<string, List<WorldSoundRegion>>();
        private Viewer Viewer;
        private SoundSource ss;

        public WorldSounds(Viewer viewer)
        {
            Viewer = viewer;
        }

        public int GetTType(TDBObjects tdbObjs)
        {
            int retval = 0;
            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;
            float prevDist;
            float nextDist;

            List<int> validitems = (from lwsr in SoundRegions.Values
                                    from wsr in lwsr
                                    from i in wsr.TrackNodes
                                    select i).Distinct().ToList();

            TrItem prev = tdbObjs.FindPrevItem<SoundRegionItem>(out prevDist, validitems);
            TrItem next = tdbObjs.FindNextItem<SoundRegionItem>(out nextDist, validitems);

            if (prev != null)
            {
                prevItem = (from lwsr in SoundRegions.Values
                            from wsr in lwsr
                            where wsr.TrackNodes.Contains((int)prev.TrItemId)
                            select wsr).FirstOrDefault();
            }

            if (next != null)
            {
                nextItem = (from lwsr in SoundRegions.Values
                            from wsr in lwsr
                            where wsr.TrackNodes.Contains((int)next.TrItemId)
                            select wsr).FirstOrDefault();
            }

            if (prevItem != null && nextItem != null)
            {
                if (prevItem.SoundRegionTrackType == nextItem.SoundRegionTrackType)
                {
                    retval = prevItem.SoundRegionTrackType;
                }
                else if (nextDist < 10)
                {
                    retval = int.MaxValue;
                }
            }

            return retval;
        }

        public int GetTType(Train train, out float outPrevDist, out float outNextDist)
        {
            int retval = 0;
            Traveller traveller;
            Traveller tmp;
            outPrevDist = -1;
            outNextDist = -1;

            if (train.SpeedMpS >= 0)
            {
                traveller = new Traveller(train.FrontTDBTraveller);
            }
            else
            {
                traveller = new Traveller(train.RearTDBTraveller, Traveller.TravellerDirection.Backward);
            }

            Orts.Formats.Msts.TrackDB trackDB = Viewer.Simulator.TDB.TrackDB;
            Orts.Formats.Msts.TrItem[] trItems = trackDB.TrItemTable;

            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;

            float prevDist = float.MaxValue;
            float nextDist = float.MaxValue;
            float d;

            lock (SoundRegions)
            {
                // Check every sound region's all track nodes
                foreach (List<WorldSoundRegion> lwsr in SoundRegions.Values)
                {
                    foreach (WorldSoundRegion wsr in lwsr)
                    {
                        foreach (int trNode in wsr.TrackNodes)
                        {
                            if (trItems[trNode].ItemType == Orts.Formats.Msts.TrItem.trItemType.trSOUNDREGION)
                            {
                                tmp = new Traveller(traveller);

                                // Try to find forward
                                d = tmp.DistanceTo(trItems[trNode].TileX, trItems[trNode].TileZ, trItems[trNode].X, trItems[trNode].Y, trItems[trNode].Z, 8192);
                                
                                if (d != -1)
                                {
                                    // This is nearer than previous one
                                    if (d < nextDist)
                                    {
                                        nextDist = d;
                                        nextItem = wsr;
                                    }
                                    // Or at exactly the same distance
                                    else if (d == nextDist)
                                    {
                                        if (traveller.Direction == tmp.Direction)
                                            tmp.ReverseDirection();

                                        // If faces toward us then it is applicable
                                        if (Math.Abs(tmp.RotY - wsr.ROTy) < .35)
                                        {
                                            nextDist = d;
                                            nextItem = wsr;
                                        }
                                    }
                                }
                                else
                                {
                                    // Not found forward, check backward
                                    tmp = new Traveller(traveller, Traveller.TravellerDirection.Backward);

                                    d = tmp.DistanceTo(trItems[trNode].TileX, trItems[trNode].TileZ, trItems[trNode].X, trItems[trNode].Y, trItems[trNode].Z, 8192);
                                    if (d != -1)
                                    {
                                        // It is nearer than previous
                                        if (d < prevDist)
                                        {
                                            prevDist = d;
                                            prevItem = wsr;
                                        }
                                        else if (d == prevDist)
                                        {
                                            if (traveller.Direction != tmp.Direction)
                                                tmp.ReverseDirection();

                                            // Applicable if faces with us
                                            if (Math.Abs(tmp.RotY - wsr.ROTy) < .35)
                                            {
                                                prevDist = d;
                                                prevItem = wsr;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Have before and behind us
            if (prevItem != null && nextItem != null)
            {
                // Between same type, means we are in a sound region
                if (prevItem.SoundRegionTrackType == nextItem.SoundRegionTrackType)
                {
                    // return one of those, doesn't matter which.
                    retval = prevItem.SoundRegionTrackType;
                    outPrevDist = prevDist;
                    outNextDist = nextDist;
                }
                else if (nextDist < 10)
                {
                    // We are between different regions and the next is very near
                    // This case we won't change to default, unnecessary to that short period of time
                    // int.MaxValue means do not change the current region even if we left it
                    retval = int.MaxValue;
                }
                //  they are different types and far from each other
                //  So we are in a neutral zone, retval is 0, default track type
            }
            else if (prevItem != null)
            {
                // only one, take it!
                retval = prevItem.SoundRegionTrackType;
                outPrevDist = prevDist;
            }
            else if (nextItem != null)
            {
                // only one, take it!
                retval = nextItem.SoundRegionTrackType;
                outNextDist = nextDist;
            }
            //  - Missing items before or behind us, maintain last sound
            else
            {
                retval = int.MaxValue;
            }
            return retval;
        }

        public void AddByTile(int TileX, int TileZ)
        {
            string name = Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(TileX, TileZ) + "s";
            WorldSoundFile wf = new WorldSoundFile(name, Viewer.Simulator.TDB.TrackDB.TrItemTable);
            if (wf.TR_WorldSoundFile != null)
            {
                string[] pathArray = {Viewer.Simulator.RoutePath, Viewer.Simulator.BasePath};
                
                var ls = new List<SoundSourceBase>();
                foreach (var fss in wf.TR_WorldSoundFile.SoundSources)
                {
                    WorldLocation wl = new WorldLocation(TileX, TileZ, fss.X, fss.Y, fss.Z);
                    var fullPath = ORTSPaths.GetFileFromFolders(pathArray, @"Sound\" + fss.SoundSourceFileName);
                    if (fullPath != null)
                    {
                        ss = new SoundSource(Viewer, wl, Events.Source.None, fullPath, true);
                        if (ss != null)
                            ls.Add(ss);
                    }
                }
                Viewer.SoundProcess.AddSoundSources(name, ls);

                lock (SoundRegions)
                {
                    if (!SoundRegions.ContainsKey(name))
                    {
                        SoundRegions.Add(name, wf.TR_WorldSoundFile.SoundRegions);
                    }
                }
            }
        }

        public void RemoveByTile(int TileX, int TileZ)
        {
            string name = Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(TileX, TileZ) + "s";
            Viewer.SoundProcess.RemoveSoundSources(name);
            lock (SoundRegions)
            {
                if (SoundRegions.ContainsKey(name))
                {
                    SoundRegions.Remove(name);
                }
            }
        }
    }

    public class TDBObjects
    {
        private MSTSWagon _car;
        TrackNode[] trackNodes;
        TrItem[] trItems;

        public TDBObjects(MSTSWagon Car, Viewer Viewer)
        {
            _car = Car;
            trackNodes = Viewer.Simulator.TDB.TrackDB.TrackNodes;
            trItems = Viewer.Simulator.TDB.TrackDB.TrItemTable;
        }

        private AIPathNode FindNode()
        {
            AIPathNode retval = null;
            return retval;
        }

        private AIPathNode GetNextNode(AIPathNode node)
        {
            if (node.NextMainNode == null)
                return node.NextSidingNode;
            else
                return node.NextMainNode;
        }

        private AIPathNode GetPrevNode(AIPathNode node)
        {
            AIPathNode retval = null;
            AIPathNode p = node;
            return retval;
        }

        private int GetTVNIndex(AIPathNode node)
        {
            if (node == null)
                return -1;

            if (node.NextMainNode == null)
                return node.NextSidingTVNIndex;
            else
                return node.NextMainTVNIndex;
        }

        public TrItem FindNextItem<T>(out float distance)
            where T : TrItem
        {
            Traveller traveller = _car.Train.FrontTDBTraveller;
            return FindItem<T>(traveller, GetNextNode, out distance, null);
        }

        public TrItem FindNextItem<T>(out float distance, List<int> validitems)
            where T : TrItem
        {
            Traveller traveller = _car.Train.FrontTDBTraveller;
            return FindItem<T>(traveller, GetNextNode, out distance, validitems);
        }

        public TrItem FindPrevItem<T>(out float distance)
            where T : TrItem
        {
            Traveller traveller = new Traveller(_car.Train.FrontTDBTraveller, Traveller.TravellerDirection.Backward);
            return FindItem<T>(traveller, GetPrevNode, out distance, null);
        }

        public TrItem FindPrevItem<T>(out float distance, List<int> validitems)
            where T : TrItem
        {
            Traveller traveller = new Traveller(_car.Train.FrontTDBTraveller, Traveller.TravellerDirection.Backward);
            return FindItem<T>(traveller, GetPrevNode, out distance, validitems);
        }

        private TrItem FindItem<T>(Traveller traveller, Func<AIPathNode, AIPathNode> move, out float distance, List<int> validitems)
            where T : TrItem
        {
            T Item = null;
            int currentNode;
            AIPathNode aiNode = FindNode();
            currentNode = GetTVNIndex(aiNode);
            distance = float.MaxValue;

            while (aiNode != null && currentNode != -1)
            {
                if (trackNodes[currentNode].TrVectorNode != null)
                {
                    if (trackNodes[currentNode].TrVectorNode.NoItemRefs > 0)
                    {
                        for (int i = 0; i < trackNodes[currentNode].TrVectorNode.NoItemRefs; i++)
                        {
                            //if (trItems[trackNodes[currenNode].TrVectorNode.TrItemRefs[i]].ItemType == TrItem.trItemType.trSIGNAL)
                            //{
                            T item = (trItems[trackNodes[currentNode].TrVectorNode.TrItemRefs[i]]) as T;
                            if (item != null && validitems != null && validitems.Contains((int)item.TrItemId))
                            {
                                float dist = traveller.DistanceTo(item.TileX, item.TileZ, item.X, item.Y, item.Z);
                                if (dist > 0)
                                {
                                    if (dist < distance)
                                    {
                                        distance = dist;
                                        Item = item;
                                    }
                                }
                            }
                            /*
                                }
                                     
                        }
                             */
                            //}
                        }

                        if (Item != null) return Item;
                    }

                }

                aiNode = move(aiNode);
                currentNode = GetTVNIndex(aiNode);
            }

            return null;
        }
    }
    public class ORTSActSoundSources
    {
        public ORTSActSoundSources( )
        {
        }

        public void Update()
        {
            if (Program.Simulator.ActivityRun == null || Program.Simulator.ActivityRun.triggeredEventWrapper == null || 
                (Program.Simulator.ActivityRun.triggeredEventWrapper.ParsedObject.ORTSActSoundFile == null && (Program.Simulator.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes == null
                || Program.Simulator.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes.ActivitySound == null))) 
                return;
            var localEventID = Program.Simulator.ActivityRun.triggeredEventWrapper.ParsedObject.ID;
            string ORTSActSoundFile;
            ORTSActSoundFileTypes ORTSActSoundFileType;
            ActivitySound activitySound = null;
            if (Program.Simulator.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes == null
                || Program.Simulator.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes.ActivitySound == null)
            {
                ORTSActSoundFile = Program.Simulator.ActivityRun.triggeredEventWrapper.ParsedObject.ORTSActSoundFile;
                ORTSActSoundFileType = Program.Simulator.ActivityRun.triggeredEventWrapper.ParsedObject.ORTSActSoundFileType;
            }
            else
            {
                activitySound = Program.Simulator.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes.ActivitySound;
                ORTSActSoundFile = activitySound.ORTSActSoundFile;
                ORTSActSoundFileType = activitySound.ORTSActSoundFileType;
            }
            var train = Program.Simulator.ActivityRun.triggeredEventWrapper.Train;
            Program.Simulator.ActivityRun.triggeredEventWrapper = null;
            var extension = Path.GetExtension(ORTSActSoundFile);
            SoundSource ActivitySounds;
            switch (extension)
            {
                case ".sms":
                    switch (ORTSActSoundFileType)
                    {
                        case ORTSActSoundFileTypes.Everywhere:
                            ActivitySounds = new SoundSource(Program.Viewer, Events.Source.MSTSInGame, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case ORTSActSoundFileTypes.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(Program.Viewer, playerLoco, ORTSActSoundFile);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case ORTSActSoundFileTypes.Pass:
                            if (Program.Viewer.Camera.Style == Camera.Styles.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(Program.Viewer, selectedWagon, ORTSActSoundFile);
                                Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            }
                            break;
                        case ORTSActSoundFileTypes.Ground:
                            var loco = (train == Program.Viewer.Simulator.PlayerLocomotive.Train) ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];
                            var worldLocation = loco.WorldPosition.WorldLocation;
                            worldLocation.Location.Y = worldLocation.Location.Y + 3; // Sound does not come from earth!
                            ActivitySounds = new SoundSource(Program.Viewer, worldLocation, Events.Source.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case ORTSActSoundFileTypes.Location:
                            worldLocation = WorldLocation.None;
                            worldLocation.TileX = activitySound.TileX;
                            worldLocation.TileZ = activitySound.TileZ;
                            worldLocation.Location.X = activitySound.X;
                            worldLocation.Location.Y = activitySound.Y + 3; // Sound does not come from earth!
                            worldLocation.Location.Z = activitySound.Z;
                            ActivitySounds = new SoundSource(Program.Viewer, worldLocation, Events.Source.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        default:
                            break;
                    }
                    break;
                case ".wav":
                    switch (ORTSActSoundFileType)
                    {
                        case ORTSActSoundFileTypes.Everywhere:
                            ActivitySounds = new SoundSource(Program.Viewer, Events.Source.MSTSInGame, ORTSActSoundFile, ORTSActSoundFileType, true, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case ORTSActSoundFileTypes.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(Program.Viewer, playerLoco, ORTSActSoundFile, ORTSActSoundFileType, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case ORTSActSoundFileTypes.Pass:
                            if (Program.Viewer.Camera.Style == Camera.Styles.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(Program.Viewer, selectedWagon, ORTSActSoundFile, ORTSActSoundFileType, true);
                                Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            }
                            break;
                        case ORTSActSoundFileTypes.Ground:
                            var loco = (train == Program.Viewer.Simulator.PlayerLocomotive.Train) ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];
                            var worldLocation = loco.WorldPosition.WorldLocation;
                            worldLocation.Location.Y = worldLocation.Location.Y + 3; // Sound does not come from earth!
                            ActivitySounds = new SoundSource(Program.Viewer, worldLocation, Events.Source.None, ORTSActSoundFile, true, ORTSActSoundFileType, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case ORTSActSoundFileTypes.Location:
                            worldLocation = WorldLocation.None;
                            worldLocation.TileX = activitySound.TileX;
                            worldLocation.TileZ = activitySound.TileZ;
                            worldLocation.Location.X = activitySound.X;
                            worldLocation.Location.Y = activitySound.Y + 3; // Sound does not come from earth!
                            worldLocation.Location.Z = activitySound.Z;
                            ActivitySounds = new SoundSource(Program.Viewer, worldLocation, Events.Source.None, ORTSActSoundFile, true, ORTSActSoundFileType, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            return;
        }
     }
}

