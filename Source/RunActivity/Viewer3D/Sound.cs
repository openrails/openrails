// COPYRIGHT 2009, 2010, 2011, 2012, 2013 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

//#define DEBUGSCR

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Microsoft.Xna.Framework;
using MSTS.Formats;
using ORTS.Common;

namespace ORTS.Viewer3D
{

/////////////////////////////////////////////////////////
// SOUND SOURCE
/////////////////////////////////////////////////////////

    /// <summary>
    /// Represents an sms file,
    /// may have a physical location in the world,
    /// may be attached to a railcar in which case it moves with the car,
    /// owns one or more SoundStreams
    /// </summary>
    public abstract class SoundSourceBase : IDisposable
    {
        public abstract void InitInitials();
		public abstract void Uninitialize();
		public abstract bool Update();

        /// <summary>
        /// The sound may be from a train car
        /// </summary>
        public MSTSWagon Car;
        /// <summary>
        /// The listener is connected to this viewer
        /// </summary>
        public Viewer Viewer;
        /// <summary>
        /// Volume of the ScalabiltyGroup
        /// </summary>
        public float Volume = 1;
        /// <summary>
        /// If needs active management or can be left to OpenAL to deal with sound properties
        /// </summary>
        public bool NeedsFrequentUpdate;

        public abstract void Dispose();
    }

    public class TrackSoundSource : SoundSourceBase
    {
        private int _prevTType = -1;
        private int _curTType = -1;
        private SoundSource _activeInSource;
        private SoundSource _activeOutSource;
        private List<SoundSource> _inSources;
        private List<SoundSource> _outSources;

        public TrackSoundSource(MSTSWagon car, Viewer viewer)
        {
            Car = car;
            Viewer = viewer;
            _inSources = new List<SoundSource>();
            _outSources = new List<SoundSource>();

            foreach (MSTS.Formats.TTypeDatFile.TrackType ttdf in viewer.TrackTypes)
            {
                MSTSLocomotive loco = Car as MSTSLocomotive;

                if (!string.IsNullOrEmpty(Car.InteriorSoundFileName) || (loco != null && !string.IsNullOrEmpty(loco.CabSoundFileName)) )
                    LoadTrackSound(ttdf.InsideSound, true);

                LoadTrackSound(ttdf.OutsideSound, false);
            }
        }

        private void LoadTrackSound(string filename, bool isInside)
        {
            if (filename == null)
                return;

            string[] pathArray = {Viewer.Simulator.RoutePath, Viewer.Simulator.BasePath};            
            var fullPath = ORTSPaths.GetFileFromFolders(pathArray, @"SOUND\" + filename);
            if (fullPath == null)
            {
                Trace.TraceWarning("Skipped missing track sound {0}", filename);
                return;
            }
            if (isInside)
                _inSources.Add(new SoundSource(Viewer, Car, fullPath));
            else
                _outSources.Add(new SoundSource(Viewer, Car, fullPath));
        }

		public override void Uninitialize() { }

        public override void InitInitials()
        {
            if (_inSources != null && _inSources.Count > 0)
                _activeInSource = _inSources[0];

            if (_outSources != null && _outSources.Count > 0)
                _activeOutSource = _outSources[0];

            _curTType = 0;
            _prevTType = 0;
        }

        public void UpdateTType()
        {
            if (_prevTType == -1)
                InitInitials();

            if (Car != null && Car.Train != null)
            {
                //_curTType = Viewer.WorldSounds.GetTType(_tdbObjs);
                _curTType = Viewer.World.Sounds.GetTType(Car.Train);
                if (_curTType != _prevTType && _curTType != int.MaxValue)
                {
                    if (_activeInSource != null)
                    {
                        _activeInSource.Uninitialize();
                        _activeInSource.Car = null;
                        _activeInSource = _inSources[_curTType];
                        _activeInSource.Car = Car;
                    }

                    if (_activeOutSource != null)
                    {
                        _activeOutSource.Uninitialize();
                        _activeOutSource.Car = null;
                        _activeOutSource = _outSources[_curTType];
                        _activeOutSource.Car = Car;
                    }
#if DEBUGSCR
                    Trace.TraceInformation("Sound region changed from {0} to {1}.", _prevTType, _curTType);
#endif

                    _prevTType = _curTType;
                }
            }
        }

        public override bool Update()
        {
            UpdateTType();

            bool retval = true;
            NeedsFrequentUpdate = false;

            if (_activeInSource != null)
            {
                retval &= _activeInSource.Update();
                NeedsFrequentUpdate |= _activeInSource.NeedsFrequentUpdate;
            }

            if (_activeOutSource != null)
            {
                NeedsFrequentUpdate |= _activeOutSource.NeedsFrequentUpdate;
                retval &= _activeOutSource.Update();
            }

            return retval;
        }

        public override void Dispose()
        {
            if (_inSources != null)
            {
                foreach (SoundSource s in _inSources)
                    s.Dispose();
                _inSources.Clear();
            }
            if (_outSources != null)
            {
                foreach (SoundSource s in _outSources)
                    s.Dispose();
                _outSources.Clear();
            }
            Car = null;
        }
    }
    
    /// <summary>
    /// Represents an sms file
    /// </summary>
    public class SoundSource : SoundSourceBase
    {
        /// <summary>
        /// Squeared cutoff distance. No sound is audible above that
        /// </summary>
        private const int CUTOFFDISTANCE = 250000;
        /// <summary>
        /// Max distance for OpenAL inverse distance model. Equals to Math.Sqrt(CUTOFFDISTANCE)
        /// </summary>
        public const float MaxDistanceM = 500f;
        /// <summary>
        /// Desired max gain at max distance for OpenAL inverse distance model
        /// </summary>
        public const float GainAtMaxDistance = 0.025f;
        /// <summary>
        /// Below this distance there is no attenuation. Used by OpenAL inverse distance model
        /// </summary>
        public const float ReferenceDistanceM = 8f;
        /// <summary>
        /// Sound attenuation factor. Calculated to achieve goal set by <see cref="GainAtMaxDistance"/>
        /// </summary>
        public float RolloffFactor;

        /// <summary>
        /// Construct a SoundSource attached to a train car.
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, MSTSWagon car, string smsFilePath)
        {
            Car = car;
            Initialize(viewer, car.WorldPosition.WorldLocation, Events.Source.MSTSCar, smsFilePath);
        }

        /// <summary>
        /// Initializes a SoundSource which has no specific location - like ingame.sms
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, Events.Source eventSource, string smsFilePath)
        {
            Initialize(viewer, null, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, WorldLocation worldLocation, Events.Source eventSource, string smsFilePath)
        {
            IsEnvSound = true;
            Initialize(viewer, worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="slowRolloff"></param>
        public SoundSource(Viewer viewer, WorldLocation worldLocation, Events.Source eventSource, string smsFilePath, bool slowRolloff)
        {
            IsEnvSound = true;
            SlowRolloff = slowRolloff;
            Initialize(viewer, worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Stop the streams, free up OpenAL sound source IDs and try to unload wave data from memory
        /// </summary>
        public override void Uninitialize()
        {
            foreach (SoundStream ss in SoundStreams)
            {
                ss.Stop();
                ss.HardDeactivate();
                WasOutOfDistance = true;
                NeedsFrequentUpdate = false;
            }
        }
        
        /// <summary>
        /// Current location of the sound source
        /// </summary>
        public WorldLocation WorldLocation;

        /// <summary>
        /// The wave files will be relative to this folder
        /// </summary>
        public string SMSFolder;
        public string SMSFileName;
        public bool Active;
        private MSTS.Formats.Activation ActivationConditions;
        private MSTS.Formats.Deactivation DeactivationConditions;
        public bool IsEnvSound;
        public bool IsExternal = true;
        public bool Ignore3D;

        /// <summary>
        /// Current distance to camera, squared meter. Is used for comparision to <see cref="CUTOFFDISTANCE"/>, to determine if is out-of-scope
        /// </summary>
        public float DistanceSquared = CUTOFFDISTANCE + 1;
        /// <summary>
        /// Out-of-scope state in previous <see cref="Update"/> loop
        /// </summary>
        private bool WasOutOfDistance = true;
        /// <summary>
        /// Different rolloff factor is used for track sounds not to attenuate so fast. As a bargain they are not silenced at cutoff distance
        /// </summary>
        private bool SlowRolloff;

        /// <summary>
        /// List of Streams in sms
        /// </summary>
        public List<SoundStream> SoundStreams = new List<SoundStream>();

        /// <summary>
        /// Set properties of this SoundSource based on parsing the sms file, and generate SoundStreams
        /// </summary>
        /// <param name="viewer">Current <see cref="Viewer3D"/></param>
        /// <param name="worldLocation">World location of <see cref="SoundSource"/></param>
        /// <param name="eventSource">Type of game part sms belongs to, to determine how to interpret discrete trigger numbers</param>
        /// <param name="smsFilePath">Full path for sms file</param>
        public void Initialize(Viewer viewer, WorldLocation worldLocation, Events.Source eventSource, string smsFilePath)
        {
            Viewer = viewer;
            WorldLocation = worldLocation;

            if (smsFilePath == null)
                return;

            SMSFolder = Path.GetDirectoryName(smsFilePath);
            SMSFileName = Path.GetFileName(smsFilePath);
            MSTS.Formats.SMSFile smsFile = MSTS.Formats.SharedSMSFileManager.Get(smsFilePath);


            // find correct ScalabiltyGroup
            int iSG = 0;
            while ( iSG < smsFile.Tr_SMS.ScalabiltyGroups.Count)
            {
                if (smsFile.Tr_SMS.ScalabiltyGroups[iSG].DetailLevel <= Viewer.Settings.SoundDetailLevel)
                    break;
                ++iSG;
            }
            if (iSG < smsFile.Tr_SMS.ScalabiltyGroups.Count && smsFile.Tr_SMS.ScalabiltyGroups[iSG].Streams != null)  // else we want less sound so don't provide any
            {
                MSTS.Formats.ScalabiltyGroup mstsScalabiltyGroup = smsFile.Tr_SMS.ScalabiltyGroups[iSG];

                ActivationConditions = mstsScalabiltyGroup.Activation;
                DeactivationConditions = mstsScalabiltyGroup.Deactivation;
                Volume = mstsScalabiltyGroup.Volume;
                Ignore3D = mstsScalabiltyGroup.Ignore3D | mstsScalabiltyGroup.Stereo;
                IsExternal = ActivationConditions.ExternalCam;

                var deactivationDistance = DeactivationConditions != null && DeactivationConditions.Distance != 0 ? DeactivationConditions.Distance : MaxDistanceM;
                var maxDistanceM = Math.Min(MaxDistanceM, deactivationDistance);

                // OpenAL inverse distance model is based on formula
                // Gain = AL_REFERENCE_DISTANCE / ( AL_REFERENCE_DISTANCE + AL_ROLLOFF_FACTOR * ( Distance - AL_REFERENCE_DISTANCE ) )
                RolloffFactor = SlowRolloff ? 0.4f : ReferenceDistanceM * (1f / GainAtMaxDistance - 1f) / (maxDistanceM - ReferenceDistanceM);

                foreach (MSTS.Formats.SMSStream mstsStream in mstsScalabiltyGroup.Streams)
                {
                    SoundStreams.Add(new SoundStream(mstsStream, eventSource, this));
                }
            }
        }

        /// <summary>
        /// Check if an event needs action from one of discrete triggers
        /// </summary>
        /// <param name="eventID">Occured event</param>
        public void HandleEvent(Event eventID)
        {
            foreach (var ss in SoundStreams)
            {
                foreach (var trg in ss.Triggers)
                {
                    var dt = trg as ORTSDiscreteTrigger;
                    if (dt != null)
                        dt.HandleEvent(eventID);
                }
            }
        }

        public override void InitInitials()
        {
            if (Car != null)
            {
                WorldLocation = Car.WorldPosition.WorldLocation;
            }

            if (isOutOfDistance())
            {
                if (!WasOutOfDistance)
                {
                    foreach (SoundStream stream in SoundStreams)
                        stream.HardDeactivate();
                }
                WasOutOfDistance = true;
                NeedsFrequentUpdate = false;
            }
            else
            {
                if (WasOutOfDistance)
                {
                    var ignore3D = WorldLocation == null | Ignore3D | !IsExternal;
                    foreach (SoundStream stream in SoundStreams)
                    {
                        stream.HardActivate(ignore3D);

                        bool released = false;
                        // run the initial triggers
                        foreach (ORTSTrigger trigger in stream.Triggers)
                        {
                            trigger.Initialize();
                            trigger.TryTrigger();

                            released |= trigger.Signaled &&
                                (trigger.SoundCommand is ORTSReleaseLoopRelease || trigger.SoundCommand is ORTSReleaseLoopReleaseWithJump);
                        }

                        if (!released && !stream.ALSoundSource.isPlaying)
                        {
                            foreach (ORTSTrigger trigger in stream.Triggers)
                            {
                                if (trigger.Signaled && trigger.Enabled && (trigger.SoundCommand is ORTSStartLoop || trigger.SoundCommand is ORTSStartLoopRelease))
                                    trigger.SoundCommand.Run();
                            }
                        }
                    }
                }
                WasOutOfDistance = false;
            }
        }
        
        public override bool Update()
        {
            if (Car != null && !Car.IsPartOfActiveTrain)
                return false;

            InitInitials();

            if (WasOutOfDistance)
            {
                // It is still needed to try out-of-distance variable triggers, to handle their start and release events, so they will be in
                // correct state when get into scope again. Discrete triggers have their HandleEvent() function to achieve this,
                // but there is no such thing for variable triggers.
                foreach (var stream in SoundStreams)
                    foreach (var trigger in stream.VariableTriggers)
                        trigger.TryTrigger();

                return true;
            }

            if (!Active)
            {
                if (Activate())
                {
                    Active = true;

                    // restore any looping sounds
                    foreach(SoundStream stream in SoundStreams)
                        stream.Activate();
                }
            }
            else
            {
                if (DeActivate())
                {
                    foreach (SoundStream stream in SoundStreams)
                        stream.Deactivate();

                    Active = false;
                }
            }

            bool needsFrequentUpdate = false;

            if (Car == null && WorldLocation != null && !Ignore3D && IsExternal)
            {
                WorldLocation.NormalizeTo(Camera.SoundBaseTile.X, Camera.SoundBaseTile.Y);
                float[] position = new float[] {
                    WorldLocation.Location.X,
                    WorldLocation.Location.Y,
                    WorldLocation.Location.Z};

                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update(position);
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            else
            {
                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update();
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            NeedsFrequentUpdate = needsFrequentUpdate;

            return true;
        } // Update

        /// <summary>
        /// Calculate current distance to camera, and compare it to <see cref="CUTOFFDISTANCE"/>
        /// </summary>
        /// <returns>True, if is now out-of-scope</returns>
        public bool isOutOfDistance()
        {
            if (WorldLocation == null)
            {
                DistanceSquared = 0;
                return false;
            }

            if (float.IsNaN(WorldLocation.Location.X) ||
                float.IsNaN(WorldLocation.Location.Y) ||
                float.IsNaN(WorldLocation.Location.Z))
            {
                DistanceSquared = CUTOFFDISTANCE + 1;
                return true;
            }

            DistanceSquared = WorldLocation.GetDistanceSquared(WorldLocation, Viewer.Camera.CameraWorldLocation);

            return DistanceSquared > CUTOFFDISTANCE;
        }

        /// <summary>
        /// Check if activation conditions are met,
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool Activate()
        {
            if (ActivationConditions == null)
                return false;

            if (ConditionsMet(ActivationConditions))
            {
                if (WorldLocation != null)
                {
                    // (ActivationConditions.Distance == 0) means distance checking disabled
                    if ((ActivationConditions.Distance == 0 || DistanceSquared < ActivationConditions.Distance * ActivationConditions.Distance) &&
                        DistanceSquared < CUTOFFDISTANCE)
                        return true;
                }
                else
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Check if deactivation conditions are met
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool DeActivate()
        {
            if (DeactivationConditions == null)
                return false;
         
            if (ConditionsMet(DeactivationConditions))
                return true;

            if (WorldLocation != null)
            {
                if (DeactivationConditions.Distance != 0 && DistanceSquared > DeactivationConditions.Distance * DeactivationConditions.Distance ||
                    DistanceSquared > CUTOFFDISTANCE)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns true if SoundSource belongs to a cabview of a vehicle not currently watched. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool IsntThisCabView
        {
            get
            {
                return (Viewer.Camera.Style == Camera.Styles.Cab || Viewer.Camera.Style == Camera.Styles.Passenger) && (Viewer.Camera.AttachedCar != Car);
            }
        }

        /// <summary>
        /// Returns true if SoundSource is a weather sound. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool WeatherSound { get { return Viewer.World.WeatherControl.WeatherSounds.Contains(this); } }

        /// <summary>
        /// Hack for enabling additional cab sounds (like radio sounds) of an attached (maybe invisible) car. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        /// <returns></returns>
        private bool IsInvisibleSoundCar
        {
            get
            {
                return (!IsEnvSound && !IsExternal && Viewer.Camera.Style == Camera.Styles.Cab
                    && Car != null && Viewer.Camera.AttachedCar != null && !(Car is MSTSLocomotive) 
                    && (Car.Train == Viewer.Camera.AttachedCar.Train || Car.Train.TrainType == Train.TRAINTYPE.STATIC || Car.Train.TrainType == Train.TRAINTYPE.AI_NOTSTARTED));
            }
        }

        /// <summary>
        /// Return true of the ViewPoint matches any of the ones specified in the conditions
        /// for activation or deactivation.
        /// </summary>
        /// <param name="conditions"></param>
        /// <returns></returns>
        private bool ConditionsMet(MSTS.Formats.Activation conditions)
        {
            if (conditions == null)
                return false;

            Camera.Styles viewpoint = Viewer.Camera.Style;

            if (IsEnvSound || !IsEnvSound && IsntThisCabView && !IsInvisibleSoundCar && !WeatherSound)
            {
                viewpoint = Camera.Styles.External;
            }

            if (conditions.CabCam && viewpoint == Camera.Styles.Cab)
                return true;
            if (conditions.PassengerCam && viewpoint == Camera.Styles.Passenger)
                return true;
            if (conditions.ExternalCam && viewpoint == Camera.Styles.External)
                return true;

            return false;
        }

        public override void Dispose()
        {
            if (SoundStreams != null)
            {
                foreach (SoundStream s in SoundStreams)
                    s.Dispose();
                SoundStreams.Clear();
            }
            Car = null;
        }
    }

/////////////////////////////////////////////////////////
// SOUND STREAM
/////////////////////////////////////////////////////////
        
    /// <summary>
    /// Owned by a <see cref="SoundSource"/>,
    /// can play only one sound at a time,
    /// the sound played is controlled by the various triggers
    /// </summary>
    public class SoundStream : IDisposable
    {
        /// <summary>
        /// Owner SoundSource
        /// </summary>
        public SoundSource SoundSource;
        /// <summary>
        /// Stream's volume can be controlled independently of the SoundSource's
        /// </summary>
        public float Volume;
        /// <summary>
        /// List of triggers controlling this stream
        /// </summary>
        public List<ORTSTrigger> Triggers = new List<ORTSTrigger>();
        /// <summary>
        /// OpenAL compatible representation of SoundStream.
        /// By OpenAL terminilogy our SoundStream is called as "SoundSource"
        /// </summary>
        public ALSoundSource ALSoundSource { get; private set; }
        /// <summary>
        /// A stream as is represented in sms file
        /// </summary>
        protected MSTS.Formats.SMSStream MSTSStream;
        /// <summary>
        /// Each stream can contain only one initial trigger, which should be audible
        /// in case the SoundSource is in scope, and no other variable trigger is active
        /// </summary>
        private ORTSInitialTrigger _InitialTrigger;
        /// <summary>
        /// If soundstream needs active management by sound process, or can be left to OpenAL
        /// </summary>
        public bool NeedsFrequentUpdate;
        /// <summary>
        /// If stream contains a release trigger with jump, looping cannot be handled fully by OpenAL.
        /// Sound process needs to watch carefully for jump command
        /// </summary>
        public bool IsReleasedWithJump;
        /// <summary>
        /// Store trigger used last time for being able to check if trigger got repeated
        /// </summary>
        public ORTSTrigger LastTriggered = new ORTSTrigger();
        /// <summary>
        /// True if the same trigger was used repeatedly.
        /// Needs for avoiding to queue same sound multiple times
        /// in case the player keeps hitting the keyboard
        /// </summary>
        public bool RepeatedTrigger;
        /// <summary>
        /// List of owned variable triggers. Used at determining if initial trigger is to be audible
        /// </summary>
        public List<ORTSTrigger> VariableTriggers = new List<ORTSTrigger>();
        /// <summary>
        /// Helper object for determining if initial trigger is to be audible
        /// </summary>
        IEnumerable<ORTSTrigger> TriggersList;

        public SoundStream(MSTS.Formats.SMSStream mstsStream, Events.Source eventSource, SoundSource soundSource)
        {
            SoundSource = soundSource;
            MSTSStream = mstsStream;
            Volume = MSTSStream.Volume;

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, soundSource.RolloffFactor);

            if (mstsStream.Triggers != null)
                foreach (MSTS.Formats.Trigger trigger in mstsStream.Triggers)
                {
                    if (trigger.SoundCommand == null) // ignore improperly formed SMS files
                    {
                        Triggers.Add(new ORTSTrigger()); // null trigger
                    }
                    else if (trigger.GetType() == typeof(MSTS.Formats.Dist_Travelled_Trigger) && soundSource.Car != null)
                    {
                        Triggers.Add(new ORTSDistanceTravelledTrigger(this, (MSTS.Formats.Dist_Travelled_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(MSTS.Formats.Initial_Trigger))
                    {
                        _InitialTrigger = new ORTSInitialTrigger(this, (MSTS.Formats.Initial_Trigger)trigger);
                        Triggers.Add(_InitialTrigger);
                    }
                    else if (trigger.GetType() == typeof(MSTS.Formats.Random_Trigger))
                    {
                        Triggers.Add(new ORTSRandomTrigger(this, (MSTS.Formats.Random_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(MSTS.Formats.Variable_Trigger) && (soundSource.Car != null || soundSource.IsEnvSound))
                    {
                        Triggers.Add(new ORTSVariableTrigger(this, (MSTS.Formats.Variable_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(MSTS.Formats.Discrete_Trigger) && soundSource.Car != null)
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, eventSource, (MSTS.Formats.Discrete_Trigger)trigger);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable 
                        SoundSource.Car.EventHandlers.Add(ortsTrigger);  // tell the simulator to call us when the event occurs
                    }
                    else if (trigger.GetType() == typeof(MSTS.Formats.Discrete_Trigger))
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, eventSource, (MSTS.Formats.Discrete_Trigger)trigger);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable 
                    }
                    IsReleasedWithJump |= (Triggers.Last().SoundCommand is ORTSReleaseLoopReleaseWithJump);
                }  // for each mstsStream.Trigger

            VariableTriggers = (from t in Triggers 
                                where t is ORTSVariableTrigger
                                select t).ToList();
        }

        /// <summary>
        /// Update OpenAL sound source position, then calls the main <see cref="Update()"/> function
        /// Position is relative to camera tile's center
        /// </summary>
        /// <param name="position"></param>
        public void Update(float[] position)
        {
            OpenAL.alSourcefv(ALSoundSource.SoundSourceID, OpenAL.AL_POSITION, position);
            Update();
        }

        /// <summary>
        /// Try triggers, update frequency and volume according to curves, call queue management
        /// </summary>
        public void Update()
        {
            if (ALSoundSource == null)
            {
                return;
            }

            foreach (ORTSTrigger trigger in Triggers)
                trigger.TryTrigger();
            
            if (_InitialTrigger != null)
            {
                // If no triggers active, Initialize the Initial
                if (!ALSoundSource.isPlaying)
                {
                    if (VariableTriggers.Count > 0 || Triggers.Count == 1)
                    {
                        TriggersList = from ORTSVariableTrigger t in VariableTriggers
                                                where t.IsBellow
                                                select t as ORTSTrigger;
                        if (TriggersList.Count() == VariableTriggers.Count && _InitialTrigger.SoundCommand is ORTSSoundPlayCommand
                            && !(_InitialTrigger.SoundCommand is ORTSPlayOneShot && _InitialTrigger.Signaled))
                        {
                            _InitialTrigger.Initialize();
                        }
                    }
                }
                // If triggers are active, reset the Initial
                else
                {
                    TriggersList = from t in Triggers
                             where t.Signaled &&
                             (t.SoundCommand is ORTSStartLoop || t.SoundCommand is ORTSStartLoopRelease)
                             select t;
                    if (TriggersList.Count() > 1 && _InitialTrigger.Signaled)
                        _InitialTrigger.Signaled = false;
                }
            }

            SetFreqAndVolume();

            ALSoundSource.Update();
            NeedsFrequentUpdate |= ALSoundSource.NeedsFrequentUpdate;
        }

        /// <summary>
        /// Calculate frequency and volume according to curves defined in sms file
        /// </summary>
        private void SetFreqAndVolume()
        {
            if (ALSoundSource == null)
                return;

            if (MSTSStream.FrequencyCurve != null) 
            {
                if (SoundSource.Car != null || SoundSource.Viewer.Camera.AttachedCar != null)
                {
                    float x = 0;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Control, SoundSource.Car);
                    else if (SoundSource.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Control, (MSTSWagon)SoundSource.Viewer.Camera.AttachedCar);
                    float y = Interpolate(x, MSTSStream.FrequencyCurve);

                    ALSoundSource.PlaybackSpeed = y / ALSoundSource.SampleRate;
                    NeedsFrequentUpdate = x != 0;
                }
            }

            float volume = SoundSource.Volume * Volume;

            if (MSTSStream.VolumeCurves.Count > 0)
                for (int i = 0; i < MSTSStream.VolumeCurves.Count; i++)
                {
                    float x;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Control, SoundSource.Car);
                    else if (SoundSource.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Control, (MSTSWagon)SoundSource.Viewer.Camera.AttachedCar);
                    else
                        x = SoundSource.DistanceSquared;

                    volume *= Interpolate(x, MSTSStream.VolumeCurves[i]);
                }

            if (SoundSource.IsExternal && SoundSource.Viewer.Camera.Style != Camera.Styles.External && SoundSource != SoundSource.Viewer.World.GameSounds)
                volume *= 0.5f;

            ALSoundSource.Volume = volume;
        }

        /// <summary>
        /// There must be at least two points in the curve
        /// // TODO do we need to implement support for Granularity()
        /// </summary>
        /// <param name="x"></param>
        /// <param name="Curve"></param>
        /// <returns></returns>
        static float Interpolate(float x, MSTS.Formats.VolumeCurve Curve)
        {
            MSTS.Formats.CurvePoint[] curvePoints = Curve.CurvePoints;

            if (x < curvePoints[0].X)
                return curvePoints[0].Y;
            if (x > curvePoints[curvePoints.Length - 1].X)
                return curvePoints[curvePoints.Length - 1].Y;

            int i = 1;
            while (i < curvePoints.Length - 1
                && curvePoints[i].X < x) ++i;
            // i points to the point equal to or above x, or to the last point in the table

            x -= curvePoints[i - 1].X;
            float rx = x / (curvePoints[i].X - curvePoints[i - 1].X);

            float dy = curvePoints[i].Y - curvePoints[i - 1].Y;

            float y = curvePoints[i - 1].Y + rx * dy;

            return y;
        }

        /// <summary>
        /// Read a variable from the attached TrainCar data
        /// </summary>
        /// <param name="control"></param>
        /// <param name="car"></param>
        /// <returns></returns>
        private float ReadValue(MSTS.Formats.VolumeCurve.Controls control, MSTSWagon car)
        {
            switch (control)
            {
                case MSTS.Formats.VolumeCurve.Controls.DistanceControlled: return SoundSource.DistanceSquared;
                case MSTS.Formats.VolumeCurve.Controls.SpeedControlled: return Math.Abs(car.SpeedMpS);
                case MSTS.Formats.VolumeCurve.Controls.Variable1Controlled: return car.Variable1;
                case MSTS.Formats.VolumeCurve.Controls.Variable2Controlled: return car.Variable2;
                case MSTS.Formats.VolumeCurve.Controls.Variable3Controlled: return car.Variable3;
                default: return 0;
            }
        }

        /// <summary>
        /// Stop OpenAL playing this stream, and flush buffers
        /// </summary>
        public void Stop()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Stop();
            }
        }

        /// <summary>
        /// Restore any previously playing sounds
        /// </summary>
        public void Activate()
        {
            if (ALSoundSource != null)
            {
                // Precalc volume to avoid glitches
                SetFreqAndVolume();
                ALSoundSource.Active = true;
            }
        }

        /// <summary>
        /// Deactivates a previously active sound
        /// </summary>
        public void Deactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Active = false;
            }
        }

        /// <summary>
        /// Allocates a new sound source ID in OpenAL, if one is not allocated yet.
        /// </summary>
        /// <param name="ignore3D">Whether the stream's world position should be ignored</param>
        public void HardActivate(bool ignore3D)
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardActivate(ignore3D, SoundSource.Car);
            }
        }

        /// <summary>
        /// Frees up the allocated sound source ID, and tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        public void HardDeactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardDeactivate();
            }
            Sweep();
        }

        public void Dispose()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardDeactivate();
                ALSoundSource.Dispose();
                ALSoundSource = null;
            }
            Sweep();
        }

        /// <summary>
        /// Tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        private void Sweep()
        {
            foreach (var trigger in Triggers)
                if (trigger.SoundCommand is ORTSSoundPlayCommand)
                    foreach (var name in (trigger.SoundCommand as ORTSSoundPlayCommand).Files)
                        SoundItem.Sweep(name, SoundSource.IsExternal, IsReleasedWithJump);
        }

    } // class ORTSStream

/////////////////////////////////////////////////////////
// SOUND TRIGGERS
/////////////////////////////////////////////////////////

    /// <summary>
    /// Trigger is defined in the SMS file as members of a SoundStream.
    /// They are activated by various events.
    /// When triggered, executes a SoundCommand
    /// </summary>
    public class ORTSTrigger
    {
        /// <summary>
        /// Set by the DisableTrigger, EnableTrigger sound commands
        /// </summary>
        public bool Enabled = true;
        /// <summary>
        /// True if trigger activation conditions are met
        /// </summary>
        public bool Signaled;
        /// <summary>
        /// Represents a sound command to be executed, when trigger is activated
        /// </summary>
        public ORTSSoundCommand SoundCommand;

        /// <summary>
        /// Check in every update loop whether to activate the trigger
        /// </summary>
        public virtual void TryTrigger() { }
        /// <summary>
        /// Executed in constructors, or when sound source gets into scope, or for InitialTrigger when other VariableTriggers stop working
        /// </summary>
        public virtual void Initialize() { }
    }


    /// <summary>
    /// Play this sound when a discrete TrainCar event occurs in the simulator
    /// </summary>
    public class ORTSDiscreteTrigger: ORTSTrigger, EventHandler
    {
        /// <summary>
        /// Event this trigger listens to
        /// </summary>
        public Event TriggerID;
        /// <summary>
        /// Store the owning SoundStream
        /// </summary>
        private SoundStream SoundStream;
        /// <summary>
        /// This flag is set by Updater process, and is used by Sound process to activate the trigger
        /// </summary>
        private bool Triggered;

        public ORTSDiscreteTrigger(SoundStream soundStream, Events.Source eventSound, MSTS.Formats.Discrete_Trigger smsData)
        {
            TriggerID = Events.From(eventSound, smsData.TriggerID);
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        /// <summary>
        /// Check if this trigger listens to an event
        /// </summary>
        /// <param name="eventID">Occured event</param>
        public void HandleEvent(Event eventID)
        {
            if (eventID == TriggerID)
            {
                Triggered = true;
            }
        }

        /// <summary>
        /// Check if this trigger listens to an event, and if also belongs to the object
        /// </summary>
        /// <param name="eventID">Occured event</param>
        /// <param name="viewer">Object the event belongs to</param>
        public void HandleEvent(Event eventID, object viewer)
        {
            if (eventID == TriggerID)
            {
                try
                {
                    if (SoundStream.SoundSource.Car.Simulator.Confirmer.Viewer.SoundProcess.GetSoundSources(viewer).Contains(SoundStream.SoundSource as SoundSourceBase))
                    {
                        Triggered = true;
                    }
                }
                catch
                {
                    return;
                }
            }
        }

        public override void TryTrigger()
        {
            Triggered &= Enabled;
            if (Triggered)
            {
                Triggered = false;
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
#if DEBUGSCR
                Console.WriteLine("({0})DiscreteTrigger: {1}:{2}", SoundStream.Index, TriggerID, SoundCommand.FileName);
#endif
            }
            // If the SoundSource is not active, should deactivate the SoundStream also
            //   preventing the hearing when not should be audible
            if (!SoundStream.SoundSource.Active)
                SoundStream.Deactivate();
        }

    } // class ORTSDiscreteTrigger

    /// <summary>
    /// Play this sound controlled by the distance a TrainCar has travelled
    /// </summary>
    public class ORTSDistanceTravelledTrigger: ORTSTrigger
    {
        MSTS.Formats.Dist_Travelled_Trigger SMS;
        float triggerDistance;
        TrainCar car;
        SoundStream SoundStream;

        public ORTSDistanceTravelledTrigger(SoundStream soundStream, MSTS.Formats.Dist_Travelled_Trigger smsData)
        {
            SoundStream = soundStream;
            car = soundStream.SoundSource.Car;
            SMS = smsData;
            SoundCommand = ORTSSoundCommand.FromMSTS(SMS.SoundCommand, soundStream );
            Initialize();
        }

        public override void Initialize()
        {
            UpdateTriggerDistance();
        }

        public override void TryTrigger()
        {
            if (car.DistanceM > triggerDistance)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)Program.Random.NextDouble() * (SMS.Volume_Max - SMS.Volume_Min) + SMS.Volume_Min;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerDistance();
#if DEBUGSCR
                Console.WriteLine("({0})DistanceTravelledTrigger: Current:{1}, Next:{2}", SoundStream.Index, car.DistanceM, triggerDistance);
#endif

            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate a new random distance to travel till the next trigger action
        /// </summary>
        private void UpdateTriggerDistance()
        {
            if (SMS.Dist_Max != SMS.Dist_Min)
            {
                triggerDistance = car.DistanceM + ((float)Program.Random.NextDouble() * (SMS.Dist_Max - SMS.Dist_Min) + SMS.Dist_Min);
            }
            else
            {
                triggerDistance = car.DistanceM + ((float)Program.Random.NextDouble() * (SMS.Dist_Min) + SMS.Dist_Min);
            }
        }

    } // class ORTSDistanceTravelledTrigger

    /// <summary>
    /// Play this sound immediately when this SoundSource becomes active, or in case no other VariableTriggers are active
    /// </summary>
    public class ORTSInitialTrigger: ORTSTrigger
    {
        private SoundStream SoundStream;

        public ORTSInitialTrigger(SoundStream soundStream, MSTS.Formats.Initial_Trigger smsData)
        {
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        public override void Initialize()
        {
            if (Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
#if DEBUGSCR
                if (!string.IsNullOrEmpty(SoundCommand.FileName))
                    Console.WriteLine("({0})InitialTrigger: {1}", SoundStream.Index, SoundCommand.FileName);
#endif
            }

            Signaled = true;
        }

    }

    /// <summary>
    /// Play the sound at random times
    /// </summary>
    public class ORTSRandomTrigger: ORTSTrigger
    {
        Simulator Simulator;
        MSTS.Formats.Random_Trigger SMS;
        double triggerAtSeconds;
        SoundStream SoundStream;

        public ORTSRandomTrigger(SoundStream soundStream, MSTS.Formats.Random_Trigger smsData)
        {
            SoundStream = soundStream;
            SMS = smsData;
            Simulator = soundStream.SoundSource.Viewer.Simulator;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
            UpdateTriggerAtSeconds();
        }

        public override void TryTrigger()
        {
            if (Simulator.ClockTime > triggerAtSeconds)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)Program.Random.NextDouble() * (SMS.Volume_Max - SMS.Volume_Min) + SMS.Volume_Min;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerAtSeconds();
            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate new random time till the next triggering action
        /// </summary>
        private void UpdateTriggerAtSeconds()
        {
            double interval = Program.Random.NextDouble() * (SMS.Delay_Max - SMS.Delay_Min) + SMS.Delay_Min;
            triggerAtSeconds = Simulator.ClockTime + interval;
        }

    }  // class RandomTrigger

    /// <summary>
    /// Control sounds based on TrainCar variables in the simulator 
    /// </summary>
    public class ORTSVariableTrigger: ORTSTrigger
    {
        MSTS.Formats.Variable_Trigger SMS;
        MSTSWagon car;
        SoundStream SoundStream;

        float StartValue;
        public bool IsBellow;

        public ORTSVariableTrigger(SoundStream soundStream, MSTS.Formats.Variable_Trigger smsData)
        {
            SMS = smsData;
            car = soundStream.SoundSource.Car;
            SoundStream = soundStream;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
            StartValue = SMS.Event == MSTS.Formats.Variable_Trigger.Events.Distance_Dec_Past ? float.MaxValue : 0;

            /*if ((new Variable_Trigger.Events[] { Variable_Trigger.Events.Variable1_Dec_Past,
                Variable_Trigger.Events.Variable1_Inc_Past, Variable_Trigger.Events.Variable2_Dec_Past, 
                Variable_Trigger.Events.Variable2_Inc_Past, Variable_Trigger.Events.Variable3_Dec_Past,
                Variable_Trigger.Events.Variable3_Inc_Past}).Contains(SMS.Event) && SMS.Threshold >= 1)
            {
                SMS.Threshold /= 100f;
            }*/
            IsBellow = StartValue < SMS.Threshold;
        }

        public override void TryTrigger( )
        {
            float newValue = ReadValue();
            bool triggered = false;
            Signaled = false;

            switch (SMS.Event)
            {
                case MSTS.Formats.Variable_Trigger.Events.Distance_Dec_Past:
                case MSTS.Formats.Variable_Trigger.Events.Speed_Dec_Past:
                case MSTS.Formats.Variable_Trigger.Events.Variable1_Dec_Past:
                case MSTS.Formats.Variable_Trigger.Events.Variable2_Dec_Past:
                case MSTS.Formats.Variable_Trigger.Events.Variable3_Dec_Past:
                    if (newValue < SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold <= StartValue)
                            triggered = true;
                    }
                    break;
                case MSTS.Formats.Variable_Trigger.Events.Distance_Inc_Past:
                case MSTS.Formats.Variable_Trigger.Events.Speed_Inc_Past:
                case MSTS.Formats.Variable_Trigger.Events.Variable1_Inc_Past:
                case MSTS.Formats.Variable_Trigger.Events.Variable2_Inc_Past:
                case MSTS.Formats.Variable_Trigger.Events.Variable3_Inc_Past:
                    if (newValue > SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold >= StartValue)
                            triggered = true;
                    }
                    break;
            }

            //Signaled = triggered;

            StartValue = newValue;
            IsBellow = newValue < SMS.Threshold;

            if (triggered && Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;

#if DEBUGSCR
                ORTSStartLoop sl = SoundCommand as ORTSStartLoop;
                if (sl != null)
                {
                    Console.WriteLine("({0})StartLoop ({1} {2}): {3} ", SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), sl.FileName);
                }
                ORTSStartLoopRelease slr = SoundCommand as ORTSStartLoopRelease;
                if (slr != null)
                {
                    Console.WriteLine("({0})StartLoopRelease ({1} {2}): {3} ", SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), slr.FileName);
                }
                ORTSReleaseLoopRelease rlr = SoundCommand as ORTSReleaseLoopRelease;
                if (rlr != null)
                {
                    Console.WriteLine("({0})ReleaseLoopRelease ({1} {2}): {3} ", SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), rlr.FileName);
                }
                ORTSReleaseLoopReleaseWithJump rlrwj = SoundCommand as ORTSReleaseLoopReleaseWithJump;
                if (rlrwj != null)
                {
                    Console.WriteLine("({0})ReleaseLoopReleaseWithJump ({1} {2}): {3} ", SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), rlrwj.FileName);
                }
#endif
            }
        }

        /// <summary>
        /// Read the desired variable either from the attached TrainCar, or the distance to sound source
        /// </summary>
        /// <returns></returns>
        private float ReadValue()
        {
            switch (SMS.Event)
            {
                case MSTS.Formats.Variable_Trigger.Events.Distance_Dec_Past:
                case MSTS.Formats.Variable_Trigger.Events.Distance_Inc_Past:
                    return SoundStream.SoundSource.DistanceSquared;
                case MSTS.Formats.Variable_Trigger.Events.Speed_Dec_Past:
                case MSTS.Formats.Variable_Trigger.Events.Speed_Inc_Past:
                    return Math.Abs(car.SpeedMpS);
                case MSTS.Formats.Variable_Trigger.Events.Variable1_Dec_Past:
                case MSTS.Formats.Variable_Trigger.Events.Variable1_Inc_Past:
                    return car.Variable1;
                case MSTS.Formats.Variable_Trigger.Events.Variable2_Dec_Past:
                case MSTS.Formats.Variable_Trigger.Events.Variable2_Inc_Past:
                    return car.Variable2;
                case MSTS.Formats.Variable_Trigger.Events.Variable3_Dec_Past:
                case MSTS.Formats.Variable_Trigger.Events.Variable3_Inc_Past:
                    return car.Variable3;
                default:
                    return 0;
            }
        }

    }  // class VariableTrigger


/////////////////////////////////////////////////////////
// SOUND COMMANDS
/////////////////////////////////////////////////////////
    

    /// <summary>
    /// Start playing the whole sound stream once, then stop
    /// </summary>
    public class ORTSPlayOneShot : ORTSSoundPlayCommand
    {
        public ORTSPlayOneShot(SoundStream ortsStream, MSTS.Formats.SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream, mstsSoundPlayCommand)
        {
        }
        public override void Run()
        {
            string p = GetNextFile();
            if (p != "")
            {
				if (ORTSStream != null && ORTSStream.ALSoundSource != null)
					ORTSStream.ALSoundSource.Queue(p, PlayMode.OneShot, ORTSStream.SoundSource.IsExternal, ORTSStream.RepeatedTrigger);
            }
        }
    } 

    /// <summary>
    /// Start looping the whole stream, release it only at the end
    /// </summary>
    public class ORTSStartLoop : ORTSSoundPlayCommand
    {
        public ORTSStartLoop( SoundStream ortsStream, MSTS.Formats.SoundPlayCommand mstsSoundPlayCommand )
            : base( ortsStream, mstsSoundPlayCommand )
        {
        }
        public override void  Run( )
        {
            // Support for Loop functions - by GeorgeS
            string p = GetNextFile();
            if (p != "")
            {
				if (ORTSStream != null && ORTSStream.ALSoundSource != null)
					ORTSStream.ALSoundSource.Queue(p, PlayMode.Loop, ORTSStream.SoundSource.IsExternal, false);
            }
        }
    } 

    /// <summary>
    /// Release the sound by playing the looped sustain part till its end, then play the last part
    /// </summary>
    public class ORTSReleaseLoopRelease : ORTSSoundCommand
    {
        public ORTSReleaseLoopRelease(SoundStream ortsStream)
            : base(ortsStream)
        {
        }
        
        public override void Run()
        {
			if (ORTSStream != null && ORTSStream.ALSoundSource != null)
				ORTSStream.ALSoundSource.Queue("", PlayMode.Release, ORTSStream.SoundSource.IsExternal, false);
        }
    }

    /// <summary>
    /// Start by playing the first part, then start looping the sustain part of the stream
    /// </summary>
    public class ORTSStartLoopRelease : ORTSSoundPlayCommand
    {
        public ORTSStartLoopRelease(SoundStream ortsStream, MSTS.Formats.PlayOneShot mstsStartLoopRelease)
            : base(ortsStream, mstsStartLoopRelease)
        {
        }

        // Support for Loop functions - by GeorgeS
        public override void Run()
        {
            string p = GetNextFile();
            if (p != "")
            {
				if (ORTSStream != null && ORTSStream.ALSoundSource != null)
					ORTSStream.ALSoundSource.Queue(p, PlayMode.LoopRelease, ORTSStream.SoundSource.IsExternal, ORTSStream.IsReleasedWithJump);
            }
        }
    }

    /// <summary>
    /// Release the sound by playing the looped sustain part till the next cue point, then jump to the last part and play that  
    /// </summary>
    public class ORTSReleaseLoopReleaseWithJump : ORTSSoundCommand
    {
        public ORTSReleaseLoopReleaseWithJump(SoundStream ortsStream)
            : base(ortsStream)
        {
        }

        public override void Run()
        {
			if (ORTSStream != null && ORTSStream.ALSoundSource != null)
				ORTSStream.ALSoundSource.Queue("", PlayMode.ReleaseWithJump, ORTSStream.SoundSource.IsExternal, true);
        }
    }

    /// <summary>
    /// Shut down this stream trigger 
    /// </summary>
    public class ORTSDisableTrigger : ORTSSoundCommand
    {
        int TriggerIndex;  // index into the stream's trigger list 

        public ORTSDisableTrigger(SoundStream ortsStream, MSTS.Formats.DisableTrigger smsData )
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerID - 1;
        }

        public override void Run()
        {
            if (TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = false;
        }
    }

    /// <summary>
    /// Re-enable this stream trigger
    /// </summary>
    public class ORTSEnableTrigger : ORTSSoundCommand
    {
        int TriggerIndex;

        public ORTSEnableTrigger(SoundStream ortsStream, MSTS.Formats.DisableTrigger smsData)
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerID - 1;
        }

        public override void Run()
        {
            if ( TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = true;
        }
    }

    /// <summary>
    /// Set Volume of Stream
    /// </summary>
    public class ORTSSetStreamVolume : ORTSSoundCommand
    {
        float Volume;

        public ORTSSetStreamVolume(SoundStream ortsStream, MSTS.Formats.SetStreamVolume smsData)
            : base(ortsStream)
        {
            Volume = smsData.Volume;
        }

        public override void Run()
        {
            ORTSStream.Volume = Volume;
        }
    }

    /// <summary>
    /// Used when the SMS file sound command is missing or malformed
    /// </summary>
    public class ORTSNoOp : ORTSSoundCommand
    {
        public ORTSNoOp()
            : base(null)
        {
        }
        public override void Run()
        {
        }
    }

    /// <summary>
    /// A base class for all sound commands
    /// Defines that they all have a stream and a 'Run()' function
    /// </summary>
    public abstract class ORTSSoundCommand
    {
        /// <summary>
        /// The Stream in .sms file it belongs to
        /// </summary>
        protected SoundStream ORTSStream;

        public ORTSSoundCommand(SoundStream ortsStream)
        {
            ORTSStream = ortsStream;
        }

        /// <summary>
        /// Put the command into stream's queue, or set its volume, or enable/disable other commands
        /// </summary>
        public abstract void Run();


        /// <summary>
        /// Create a sound command based on the sound command variable of a trigger in an SMS file.
        /// </summary>
        /// <param name="mstsSoundCommand"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand FromMSTS(MSTS.Formats.SoundCommand mstsSoundCommand, SoundStream soundStream)
        {
            if (mstsSoundCommand == null)
            {
                return new ORTSNoOp();
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.Formats.PlayOneShot))
            {
                return new ORTSPlayOneShot(soundStream, (MSTS.Formats.PlayOneShot)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.Formats.StartLoop))
            {
                return new ORTSStartLoop(soundStream, (MSTS.Formats.StartLoop)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.Formats.StartLoopRelease))
            {
                return new ORTSStartLoopRelease(soundStream, (MSTS.Formats.StartLoopRelease)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.Formats.ReleaseLoopRelease))
            {
                return new ORTSReleaseLoopRelease(soundStream);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.Formats.ReleaseLoopReleaseWithJump))
            {
                return new ORTSReleaseLoopReleaseWithJump(soundStream);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.Formats.SetStreamVolume))
            {
                return new ORTSSetStreamVolume(soundStream, (MSTS.Formats.SetStreamVolume)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.Formats.DisableTrigger))
            {
                return new ORTSDisableTrigger(soundStream, (MSTS.Formats.DisableTrigger)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.Formats.EnableTrigger))
            {
                return new ORTSEnableTrigger(soundStream, (MSTS.Formats.EnableTrigger)mstsSoundCommand);
            }
			throw new ArgumentException("Unexpected soundCommand type " + mstsSoundCommand.GetType().ToString() + " in " + soundStream.SoundSource.SMSFolder, "mstsSoundCommand");
        }

    }// ORTSSoundCommand

    /// <summary>
    /// A base class for commands that play a sound.
    /// Provides for selecting the sound from multiple files
    /// using a random or sequential selection strategy.
    /// </summary>
    public abstract class ORTSSoundPlayCommand : ORTSSoundCommand
    {
        /// <summary>
        /// File names to select from for playing
        /// </summary>
        public String[] Files;
        /// <summary>
        /// How to select from available files
        /// </summary>
        protected MSTS.Formats.SoundCommand.SelectionMethods SelectionMethod;
        /// <summary>
        /// Index of the file to play inside <see cref="Files"/> vector
        /// </summary>
        protected int iFile;

        public ORTSSoundPlayCommand(SoundStream ortsStream, MSTS.Formats.SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream)
        {
            Files = mstsSoundPlayCommand.Files;
            SelectionMethod = mstsSoundPlayCommand.SelectionMethod;
        }

        /// <summary>
        /// Select a file from the Files list using the SelectionMethod
        /// </summary>
        /// <returns>File name with full path </returns>
        protected string GetNextFile()
        {
            if (SelectionMethod == MSTS.Formats.SoundCommand.SelectionMethods.SequentialSelection)
            {
                ++iFile;
                if (iFile >= Files.Length)
                    iFile = 0;
            }
            else if (SelectionMethod == MSTS.Formats.SoundCommand.SelectionMethods.RandomSelection)
            {
                iFile = Program.Random.Next(Files.Length);
            }

            //<CJComment>SMSFolder is often same as BasePath, which means this searches the more general folder 
            // before the more specific folder. This is surely not intended.</CJComment>
            string[] pathArray = {ORTSStream.SoundSource.SMSFolder, 
                                     Program.Simulator.RoutePath + @"\SOUND", 
                                     Program.Simulator.BasePath + @"\SOUND"};
            var fullPath = ORTSPaths.GetFileFromFolders(pathArray, Files[iFile]);
            return (fullPath != null) ? fullPath : "";
        }
    }

    public class WorldSounds
    {
        Dictionary<string, List<WorldSoundRegion>> SoundRegions = new Dictionary<string, List<WorldSoundRegion>>();
        private Viewer Viewer;
        private SoundSource ss;
        private List<SoundSourceBase> ls;

        public WorldSounds(Viewer viewer)
        {
            Viewer = viewer;
        }

        public int GetTType(TDBObjects tdbObjs)
        {
            int retval = 0;
            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;
            float prevDist;
            float nextDist;

            List<int> validitems = (from lwsr in SoundRegions.Values
                                    from wsr in lwsr
                                    from i in wsr.TrackNodes
                                    select i).Distinct().ToList();

            TrItem prev = tdbObjs.FindPrevItem<SoundRegionItem>(out prevDist, validitems);
            TrItem next = tdbObjs.FindNextItem<SoundRegionItem>(out nextDist, validitems);

            if (prev != null)
            {
                prevItem = (from lwsr in SoundRegions.Values
                            from wsr in lwsr
                            where wsr.TrackNodes.Contains((int)prev.TrItemId)
                            select wsr).FirstOrDefault();
            }

            if (next != null)
            {
                nextItem = (from lwsr in SoundRegions.Values
                            from wsr in lwsr
                            where wsr.TrackNodes.Contains((int)next.TrItemId)
                            select wsr).FirstOrDefault();
            }

            if (prevItem != null && nextItem != null)
            {
                if (prevItem.SoundRegionTrackType == nextItem.SoundRegionTrackType)
                {
                    retval = prevItem.SoundRegionTrackType;
                }
                else if (nextDist < 10)
                {
                    retval = int.MaxValue;
                }
            }

            return retval;
        }

        public int GetTType(Train train)
        {
            int retval = 0;

            Traveller traveller = train.FrontTDBTraveller;

            MSTS.Formats.TrackDB trackDB = Viewer.Simulator.TDB.TrackDB;
            MSTS.Formats.TrItem[] trItems = trackDB.TrItemTable;

            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;
            
            Traveller tmp;

            float prevDist = float.MaxValue;
            float nextDist = float.MaxValue;
            float d;

            lock (SoundRegions)
            {
                // Check every sound region's all track nodes
                foreach (List<WorldSoundRegion> lwsr in SoundRegions.Values)
                {
                    foreach (WorldSoundRegion wsr in lwsr)
                    {
                        foreach (int trNode in wsr.TrackNodes)
                        {
                            if (trItems[trNode].ItemType == MSTS.Formats.TrItem.trItemType.trSOUNDREGION)
                            {
                                tmp = new Traveller(traveller);

                                // Try to find forward
                                d = tmp.DistanceTo(trItems[trNode].TileX, trItems[trNode].TileZ, trItems[trNode].X, trItems[trNode].Y, trItems[trNode].Z, 8192);
                                
                                if (d != -1)
                                {
                                    // This is nearer than previous one
                                    if (d < nextDist)
                                    {
                                        nextDist = d;
                                        nextItem = wsr;
                                    }
                                    // Or at exactly the same distance
                                    else if (d == nextDist)
                                    {
                                        if (traveller.Direction == tmp.Direction)
                                            tmp.ReverseDirection();

                                        // If faces toward us then it is applicable
                                        if (Math.Abs(tmp.RotY - wsr.ROTy) < .35)
                                        {
                                            nextDist = d;
                                            nextItem = wsr;
                                        }
                                    }
                                }
                                else
                                {
                                    // Not found forward, check backward
                                    tmp = new Traveller(traveller, Traveller.TravellerDirection.Backward);

                                    d = tmp.DistanceTo(trItems[trNode].TileX, trItems[trNode].TileZ, trItems[trNode].X, trItems[trNode].Y, trItems[trNode].Z, 8192);
                                    if (d != -1)
                                    {
                                        // It is nearer than previous
                                        if (d < prevDist)
                                        {
                                            prevDist = d;
                                            prevItem = wsr;
                                        }
                                        else if (d == prevDist)
                                        {
                                            if (traveller.Direction != tmp.Direction)
                                                tmp.ReverseDirection();

                                            // Applicable if faces with us
                                            if (Math.Abs(tmp.RotY - wsr.ROTy) < .35)
                                            {
                                                prevDist = d;
                                                prevItem = wsr;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Have before and behind us
            if (prevItem != null && nextItem != null)
            {
                // Between same type, means we are in a sound region
                if (prevItem.SoundRegionTrackType == nextItem.SoundRegionTrackType)
                {
                    // return one of those, doesn't matter which.
                    retval = prevItem.SoundRegionTrackType;
                }
                else if (nextDist < 10)
                {
                    // We are between different regions and the next is very near
                    // This case we won't change to default, unnecessary to that short period of time
                    // int.MaxValue means do not change the current region even if we left it
                    retval = int.MaxValue;
                }
            }
            // If none of the conditions above apply,
            //  - Missing items before or behind us, 
            //  - or they are different types and far from each other
            //  So we are in a neutral zone, retval is 0, default track type
            return retval;
        }

        public void AddByTile(int TileX, int TileZ)
        {
            string name = Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(TileX, TileZ) + "s";
            WSFile wf = new WSFile(name);
            if (wf.TR_WorldSoundFile != null)
            {
                string[] pathArray = {Viewer.Simulator.RoutePath, Viewer.Simulator.BasePath};
                
                ls = new List<SoundSourceBase>();
                foreach (var fss in wf.TR_WorldSoundFile.SoundSources)
                {
                    WorldLocation wl = new WorldLocation(TileX, TileZ, fss.X, fss.Y, fss.Z);
                    var fullPath = ORTSPaths.GetFileFromFolders(pathArray, @"Sound\" + fss.SoundSourceFileName);
                    if (fullPath != null)
                    {
                        ss = new SoundSource(Viewer, wl, Events.Source.None, fullPath, true);
                        if (ss != null)
                            ls.Add(ss);
                    }
                }
                Viewer.SoundProcess.AddSoundSource(name, ls);

                lock (SoundRegions)
                {
                    if (!SoundRegions.ContainsKey(name))
                    {
                        SoundRegions.Add(name, wf.TR_WorldSoundFile.SoundRegions);
                    }
                }
            }
        }

        public void RemoveByTile(int TileX, int TileZ)
        {
            string name = Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(TileX, TileZ) + "s";
            Viewer.SoundProcess.RemoveSoundSource(name);
            lock (SoundRegions)
            {
                if (SoundRegions.ContainsKey(name))
                {
                    SoundRegions.Remove(name);
                }
            }
        }
    }

    public class TDBObjects
    {
        private MSTSWagon _car;
#if !NEW_SIGNALLING
        private Dispatcher _dp;
#endif
        TrackNode[] trackNodes;
        TrItem[] trItems;
        private AIPath _aiPath;
#if !NEW_SIGNALLING
        private TrackAuthority _ta;
#endif

        public TDBObjects(MSTSWagon Car, Viewer Viewer)
        {
            _car = Car;
#if !NEW_SIGNALLING
            _dp = Viewer.Simulator.AI.Dispatcher;
#endif
            trackNodes = Viewer.Simulator.TDB.TrackDB.TrackNodes;
            trItems = Viewer.Simulator.TDB.TrackDB.TrItemTable;
        }

        private AIPathNode FindNode()
        {
            AIPathNode retval = null;

#if !NEW_SIGNALLING
            if (_aiPath == null)
            {

                _ta = _dp.TrackAuthorities.Where
                    (t => t.Train == _car.Train).FirstOrDefault();

                if (_ta != null)
                {
                    _aiPath = _ta.Path;
                }
            }

            if (_aiPath != null)
            {
                retval = _aiPath.FindTrackNode(_ta.Path.FirstNode, _car.Train.FrontTDBTraveller.TrackNodeIndex);
            }
#endif

            return retval;
        }

		private AIPathNode GetNextNode(AIPathNode node)
		{
#if !NEW_SIGNALLING
			if ((_ta != null && node == _ta.SidingNode) || node.NextMainNode == null)
				return node.NextSidingNode;
			else
				return node.NextMainNode;
#else
                        if (node.NextMainNode == null)
                                return node.NextSidingNode;
                        else
                                return node.NextMainNode;
#endif
		}

        private AIPathNode GetPrevNode(AIPathNode node)
        {
            AIPathNode retval = null;
            AIPathNode p = node;

            if (_aiPath != null)
            {
                AIPathNode c = _aiPath.FirstNode;

                while (c != p && c != null)
                {
                    retval = c;
                    c = GetNextNode(c);
                }

                if (c == null)
                    retval = null;
            }

            return retval;
        }

        private int GetTVNIndex(AIPathNode node)
		{
            if (node == null)
                return -1;

#if !NEW_SIGNALLING
            if ((_ta != null && node == _ta.SidingNode) || node.NextMainNode == null)
				return node.NextSidingTVNIndex;
			else
				return node.NextMainTVNIndex;
#else
			if (node.NextMainNode == null)
                                return node.NextSidingTVNIndex;
                        else
                                return node.NextMainTVNIndex;
#endif
		}

        public TrItem FindNextItem<T>(out float distance)
            where T : TrItem
        {
            Traveller traveller = _car.Train.FrontTDBTraveller;
            return FindItem<T>(traveller, GetNextNode, out distance, null);
        }

        public TrItem FindNextItem<T>(out float distance, List<int> validitems)
            where T : TrItem
        {
            Traveller traveller = _car.Train.FrontTDBTraveller;
            return FindItem<T>(traveller, GetNextNode, out distance, validitems);
        }

        public TrItem FindPrevItem<T>(out float distance)
            where T : TrItem
        {
            Traveller traveller = new Traveller(_car.Train.FrontTDBTraveller, Traveller.TravellerDirection.Backward);
            return FindItem<T>(traveller, GetPrevNode, out distance, null);
        }

        public TrItem FindPrevItem<T>(out float distance, List<int> validitems)
            where T : TrItem
        {
            Traveller traveller = new Traveller(_car.Train.FrontTDBTraveller, Traveller.TravellerDirection.Backward);
            return FindItem<T>(traveller, GetPrevNode, out distance, validitems);
        }

        private TrItem FindItem<T>(Traveller traveller, Func<AIPathNode, AIPathNode> move, out float distance, List<int> validitems)
            where T : TrItem
        {
            T Item = null;
            int currentNode;
            AIPathNode aiNode = FindNode();
            currentNode = GetTVNIndex(aiNode);
            distance = float.MaxValue;

            while (aiNode != null && currentNode != -1)
            {
                if (trackNodes[currentNode].TrVectorNode != null)
                {
                    if (trackNodes[currentNode].TrVectorNode.noItemRefs > 0)
                    {
                        for (int i = 0; i < trackNodes[currentNode].TrVectorNode.noItemRefs; i++)
                        {
                            //if (trItems[trackNodes[currenNode].TrVectorNode.TrItemRefs[i]].ItemType == TrItem.trItemType.trSIGNAL)
                            //{
                            T item = (trItems[trackNodes[currentNode].TrVectorNode.TrItemRefs[i]]) as T;
                            if (item != null && validitems != null && validitems.Contains((int)item.TrItemId))
                            {
                                float dist = traveller.DistanceTo(item.TileX, item.TileZ, item.X, item.Y, item.Z);
                                if (dist > 0)
                                {
                                    if (dist < distance)
                                    {
                                        distance = dist;
                                        Item = item;
                                    }
                                }
                            }
                            /*
                                }
                                     
                        }
                             */
                            //}
                        }

                        if (Item != null) return Item;
                    }

                }

                aiNode = move(aiNode);
                currentNode = GetTVNIndex(aiNode);
            }

            return null;
        }
    }
}

