// COPYRIGHT 2009, 2010, 2011, 2012, 2013 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

/* LOCOMOTIVE CLASSES
 * 
 * Used as a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  MSTSLocomotive - defines the behaviour, ie physics, motion, power generated etc
 *  MSTSLocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCar - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */

//#define ALLOW_ORTS_SPECIFIC_ENG_PARAMETERS

// Debug for Advanced Adhesion Model
//#define DEBUG_ADHESION

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Orts.Common;
using Orts.Formats.Msts;
using Orts.MultiPlayer;
using Orts.Parsers.Msts;
using Orts.Simulation.Physics;
using Orts.Simulation.RollingStocks.SubSystems;
using Orts.Simulation.RollingStocks.SubSystems.Brakes;
using Orts.Simulation.RollingStocks.SubSystems.Brakes.MSTS;
using Orts.Simulation.RollingStocks.SubSystems.Controllers;
using Orts.Simulation.RollingStocks.SubSystems.PowerSupplies;
using Orts.Simulation.RollingStocks.SubSystems.PowerTransmissions;
using ORTS.Common;
using ORTS.Scripting.Api;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Event = Orts.Common.Event;

namespace Orts.Simulation.RollingStocks
{

    ///////////////////////////////////////////////////
    ///   SIMULATION BEHAVIOUR
    ///////////////////////////////////////////////////

    public enum CabViewType
    {
        Front = 0,
        Rear = 1,
        Void = 2
    }

    /// <summary>
    /// Adds Throttle, Direction, Horn, Sander and Wiper control
    /// to the basic TrainCar.
    /// Use as a base for Electric, Diesel or Steam locomotives.
    /// </summary>
    public partial class MSTSLocomotive : MSTSWagon
    {

        public enum CombinedControl
        {
            None,
            ThrottleDynamic,
            ThrottleAir,
            ThrottleDynamicAir,
            DynamicAir,
        }

        public enum SoundState
        {
            Stopped,
            Sound,
            ContinuousSound
        }

        // simulation parameters
        public bool ManualHorn = false;
        public bool TCSHorn = false;
        public bool Horn = false;
        protected bool PreviousHorn = false;

        public bool ManualBell = false;
        public SoundState BellState = SoundState.Stopped;
        public bool Bell = false;
        protected bool PreviousBell = false;

        public bool AlerterSnd;
        public bool VigilanceMonitor;
        public bool Sander;
        public bool Wiper;
        public bool BailOff;
        public bool DynamicBrake;
        public float MaxPowerW;
        public float MaxForceN;
        public float TractiveForceN = 0f; // Raw tractive force for electric sound variable2
        public float MaxCurrentA = 0;
        public float MaxSpeedMpS = 1e3f;
        public float MainResPressurePSI = 130;
        public bool CompressorIsOn;
        public float AverageForceN;
        public bool PowerOn;
        public float PowerOnDelayS;
        public bool CabLightOn;
        public bool ShowCab = true;
        public bool MilepostUnitsMetric;
        public float DrvWheelWeightKg; // current weight on locomotive drive wheels, includes drag factor (changes as mass changes)
        public float InitialDrvWheelWeightKg; // initialising weight on locomotive drive wheels, includes drag factor
        public bool CabRadioOn;
        public bool OnLineCabRadio;
        public string OnLineCabRadioURL;

        // Water trough filling
        public bool HasWaterScoop = false; // indicates whether loco + tender have a water scoop or not
        public float ScoopMaxPickupSpeedMpS = 200.0f; // Maximum scoop pickup speed - used in steam locomotive viewer
        public bool ScoopIsBroken = false; // becomes broken if activated where there is no trough
        public bool RefillingFromTrough = false; // refilling from through is ongoing
        public float WaterScoopFillElevationM; // height water has to be raised to fill tender
        public float WaterScoopDepthM; // depth that water scoop goes into trough (pan)
        public float WaterScoopWidthM; // width of water scoop
        public float WaterScoopVelocityMpS; // Velocity of water entering water scoop
        public float WaterScoopDragForceN; // drag force due to scoop being in water trough
        public float WaterScoopedQuantityLpS; // Amount of water scooped up by water scoop per second
        public float WaterScoopInputAmountL; // Water scooped in elapsed time
        public float WaterScoopMinSpeedMpS; // Minimum speed for water pickup
        public bool IsWaterScoopDown = false;
        public bool WaterScoopDown;
        public const float GravitationalAccelerationFtpSpS = 32.26f;
        public float TenderWaterLevelFraction;
        public float WaterScoopTotalWaterL;
        bool WaterScoopOverTroughFlag = false;
        bool WaterScoopNotFittedFlag = false;
        bool WaterScoopSlowSpeedFlag = false;
        bool WaterScoopDirectionFlag = false;
        public bool IsWaterScoopPlayerLocomotive = false;
        public float MaxTotalCombinedWaterVolumeUKG;
        public MSTSNotchController WaterController = new MSTSNotchController(0, 1, 0.01f);
        public float CombinedTenderWaterVolumeUKG          // Decreased by running injectors and increased by refilling
        {
            get { return WaterController.CurrentValue* MaxTotalCombinedWaterVolumeUKG; }
            set { WaterController.CurrentValue = value / MaxTotalCombinedWaterVolumeUKG; }
        }

        public float IsTenderRequired = 1.0f;  // Flag indicates that a tender is required for operation of the locomotive. Typically tank locomotives do not require a tender. Assume by default that tender is required.

        // Vacuum Reservoir and Exhauster Settings

        // Steam heating Flags
        public bool IsSteamInitial = true;        // To initialise steam heat
        public bool IsSteamHeatFirstTime = true;  // Flag for first pass at steam heating.
        public bool IsSteamHeatFitted = false;    // Is steam heating fitted to locomotive
        public float CurrentSteamHeatPressurePSI = 0.0f;   // Current pressure in steam heat system

        public string LocomotiveName; // Name of locomotive from ENG file

        // Carriage Steam Heating Parameters
        public float MaxSteamHeatPressurePSI;    // Maximum Steam heating pressure
        public Interpolator SteamHeatPressureToTemperaturePSItoF;
        public float SteamHeatFuelTankCapacityL = 1500.0f; // Capacity of the fuel tank for the steam heating boiler
        public float SteamHeatBoilerFuelUsageLpH = 31.0f; // Usage rate of fuel for steam heating boiler
        public float CurrentSteamHeatFuelCapacityL;  // Current fuel level
        public bool TrainFittedSteamHeat = false;               // Flag to determine train fitted with steam heating

        // Adhesion Debug
        bool DebugSpeedReached;
        float DebugSpeedIncrement = 5.0f; // Speed increment for debug display - in mph
        float DebugSpeed = 5.0f; // Initialise at 5 mph
        float DebugTimer = 0.0f;

        // Adhesion parameters
        float BaseFrictionCoefficientFactor;  // Factor used to adjust Curtius formula depending upon weather conditions
        public float SteamStaticWheelForce;
        public float SteamTangentialWheelForce;
        public float SteamDrvWheelWeightLbs;  // Weight on each drive axle
        public float PreviousThrottleSetting = 0.0f;  // Holds the value of the previous throttle setting for calculating the correct antislip speed

        // parameters for Track Sander
        public float MaxTrackSandBoxCapacityFt3 = 5.0f;  // Capacity of sandbox - assume 3.5 cu ft
        public float TrackSandBoxCapacityFt3 = 5.0f;   // This value needs to be initialised to the value above.
        public float TrackSanderAirComsumptionFt3pM = 17.0f;  //
        public float TrackSanderAirPressurePSI = 80.0f;
        public float TrackSanderSandConsumptionFt3pH = 1.01f;

        // Vacuum Braking parameters
        readonly static float OneAtmospherePSI = Bar.ToPSI(1);
        public bool SmallSteamEjectorIsOn = false;
        public bool LargeSteamEjectorIsOn = false;
        public bool VacuumPumpOperating = false;
        public float SteamEjectorSmallPressurePSI = 0.0f;
        public bool VacuumPumpFitted;
        public bool SmallEjectorFitted = false;
        public float VacuumPumpResistanceN;
        public float EjectorSmallSteamConsumptionLbpS;
        public float EjectorLargeSteamConsumptionLbpS;
        public float SteamEjectorSmallSetting = 0.0f;
        public float MaxVaccuumMaxPressurePSI = 110.0f;  // Value for the boiler pressure when maximum vacuum will be produced for the steam ejector 
        public float SmallEjectorFeedFraction = 0.35f;
        public float LargeEjectorFeedFraction = 1.0f;
        public float VacuumPumpChargingRateInHgpS = 0.0f;
        public bool VacuumBrakeEQFitted = false;  // Flag to indicate that equalising resevoir fitted to vacuum brakes
        public float HUDNetBPLossGainPSI;
        public float SmallEjectorBrakePipeChargingRatePSIorInHgpS;
        public float LargeEjectorBrakePipeChargingRatePSIorInHgpS;
        public float ExhausterHighSBPChargingRatePSIorInHgpS;  // Rate for Exhauster in high speed mode
        public float ExhausterLowSBPChargingRatePSIorInHgpS;  // Rate for Exhauster in high speed mode

        public bool EngineBrakeFitted = false;
        public bool VacuumExhausterIsOn = false;
        public float VacuumBrakesMainResVolumeM3 = Me3.FromFt3(200.0f); // Main vacuum reservoir volume
        public float VacuumBrakesMainResMaxVacuumPSIAorInHg = Vac.ToPress(23);
        public float VacuumBrakesExhausterRestartVacuumPSIAorInHg = Vac.ToPress(21);
        public float VacuumBrakesMainResChargingRatePSIAorInHgpS = Bar.ToPSI(Bar.FromInHg(0.2f));
        public float VacuumMainResVacuumPSIAorInHg = Vac.ToPress(23); // Vacuum currently in Main Reservoir


        // Set values for display in HUD
        public float WagonCoefficientFrictionHUD;
        public float LocomotiveCoefficientFrictionHUD;

        public PressureUnit MainPressureUnit = PressureUnit.None;
        public Dictionary<BrakeSystemComponent, PressureUnit> BrakeSystemPressureUnits = new Dictionary<BrakeSystemComponent, PressureUnit>
        {
            { BrakeSystemComponent.MainReservoir, PressureUnit.None },
            { BrakeSystemComponent.EqualizingReservoir, PressureUnit.None },
            { BrakeSystemComponent.AuxiliaryReservoir, PressureUnit.None },
            { BrakeSystemComponent.EmergencyReservoir, PressureUnit.None },
            { BrakeSystemComponent.MainPipe, PressureUnit.None },
            { BrakeSystemComponent.BrakePipe, PressureUnit.None },
            { BrakeSystemComponent.BrakeCylinder, PressureUnit.None }
        };

        protected float OdometerResetPositionM = 0;
        protected bool OdometerCountingUp = true;
        protected bool OdometerCountingForwards = true;

        public bool OdometerVisible { get; private set; }
        public float OdometerM
        {
            get
            {
                if (Train == null)
                    return 0;

                return OdometerCountingForwards ? Train.DistanceTravelledM - OdometerResetPositionM : OdometerResetPositionM - Train.DistanceTravelledM;
            }
        }

        // ENG file data
        public string CabSoundFileName;
        public string CVFFileName;
        public float MaxMainResPressurePSI = 130;
        public float MainResVolumeM3 = 0.3f;
        public float TrainBrakePipeLeakPSIorInHgpS = 0.0f;    // Air leakage from train brake pipe - should normally be no more then 5psi/min - default off
        public float CompressorRestartPressurePSI = 110;
        public float CompressorChargingRateM3pS = 0.075f;
        public float MainResChargingRatePSIpS;
        public float EngineBrakeReleaseRatePSIpS = 12.5f;
        public float EngineBrakeApplyRatePSIpS = 12.5f;
        public float BrakePipeTimeFactorS = 0.0015f;
        public float BrakePipeDischargeTimeFactor;
        public float BrakeServiceTimeFactorS;
        public float BrakeEmergencyTimeFactorS;
        public float BrakePipeChargingRatePSIorInHgpS;
        public InterpolatorDiesel2D TractiveForceCurves;
        public InterpolatorDiesel2D DynamicBrakeForceCurves;
        public float DynamicBrakeSpeed1MpS = MpS.FromKpH(5);
        public float DynamicBrakeSpeed2MpS = MpS.FromKpH(30);
        public float DynamicBrakeSpeed3MpS = MpS.FromKpH(999);
        public float DynamicBrakeSpeed4MpS = MpS.FromKpH(999);
        public float DynamicBrakeRatioAtSpeed4 = 0;
        public float MaxDynamicBrakeForceN;
        public float DynamicBrakeMaxCurrentA;
        public float DynamicBrakeDelayS;
        public bool DynamicBrakeAutoBailOff;
        public bool UsingRearCab;

        protected bool DynamicBrakeBlended; // dynamic brake blending is currently active
        protected bool DynamicBrakeBlendingEnabled; // dynamic brake blending is configured
        protected bool DynamicBrakeAvailable; // dynamic brake is available
        AirSinglePipe airPipeSystem;
        protected double DynamicBrakeCommandStartTime;
        protected bool DynamicBrakeBlendingOverride; // true when DB lever >0% should always override the blending. When false, the bigger command is applied.
        protected bool DynamicBrakeBlendingForceMatch = true; // if true, dynamic brake blending tries to achieve the same braking force as the airbrake would have.

        public CombinedControl CombinedControlType;
        public float CombinedControlSplitPosition;
        public bool HasSmoothStruc;

        public float MaxContinuousForceN;
        public float ContinuousForceTimeFactor = 1800;
        public bool AntiSlip;
        public bool AdvancedAdhesionModel = false; // flag set depending upon adhesion model used.
        public float SanderSpeedEffectUpToMpS;
        public float SanderSpeedOfMpS = 30.0f;
        public string EngineOperatingProcedures;

        public bool EmergencyButtonPressed { get; set; }
        public bool EmergencyCausesPowerDown { get; private set; }
        public bool EmergencyCausesThrottleDown { get; private set; }
        public bool EmergencyEngagesHorn { get; private set; }
        public bool WheelslipCausesThrottleDown { get; private set; }

        public bool DoesBrakeCutPower { get; private set; }
        public float BrakeCutsPowerAtBrakeCylinderPressurePSI { get; private set; }
        public bool DoesHornTriggerBell { get; private set; }

        protected const float DefaultCompressorRestartToMaxSysPressureDiff = 35;    // Used to check if difference between these two .eng parameters is correct, and to correct it
        protected const float DefaultMaxMainResToCompressorRestartPressureDiff = 10; // Used to check if difference between these two .eng parameters is correct, and to correct it
        protected const float DefaultMaxCompressorRestartPressure = 135; // Max value to be inserted if .eng parameters are corrected
        protected const float DefaultMainResVolume = 0.78f; // Value to be inserted if .eng parameters are corrected
        protected const float DefaultMaxMainResPressure = 140; // Max value to be inserted if .eng parameters are corrected

        public List<CabView> CabViewList = new List<CabView>();
        public CabView3D CabView3D;

        public MSTSNotchController SteamHeatController = new MSTSNotchController(0, 1, 0.1f);

        public MSTSNotchController ThrottleController;
        public ScriptedBrakeController TrainBrakeController;
        public ScriptedBrakeController EngineBrakeController;
        public AirSinglePipe.ValveState EngineBrakeState = AirSinglePipe.ValveState.Lap;
        public MSTSNotchController DynamicBrakeController;
        public MSTSNotchController GearBoxController;

        public float EngineBrakeIntervention = -1;
        public float TrainBrakeIntervention = -1;
        public float ThrottleIntervention = -1;
        public float DynamicBrakeIntervention = -1;
        protected float PreviousDynamicBrakeIntervention = -1;

        public ScriptedTrainControlSystem TrainControlSystem;

        public Axle LocomotiveAxle;
        public IIRFilter CurrentFilter;
        public IIRFilter AdhesionFilter;

        public float FilteredMotiveForceN;

        public double CommandStartTime;

        public double LastBrakeSoundTime = 0;

        public float PowerReduction = 0;

        public MSTSLocomotive(Simulator simulator, string wagPath)
            : base(simulator, wagPath)
        {
          //  BrakePipeChargingRatePSIpS = Simulator.Settings.BrakePipeChargingRate;
                        
            MilepostUnitsMetric = Simulator.TRK.Tr_RouteFile.MilepostUnitsMetric;
            BrakeCutsPowerAtBrakeCylinderPressurePSI = 4.0f;

            LocomotiveAxle = new Axle();
            LocomotiveAxle.DriveType = AxleDriveType.ForceDriven;
            LocomotiveAxle.DampingNs = MassKG / 1000.0f;
            LocomotiveAxle.FrictionN = MassKG / 100.0f;
            LocomotiveAxle.StabilityCorrection = true;
            LocomotiveAxle.FilterMovingAverage.Size = Simulator.Settings.AdhesionMovingAverageFilterSize;
            CurrentFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(0.5f), 0.001f);
            AdhesionFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(1f), 0.001f);

            TrainBrakeController = new ScriptedBrakeController(this);
            EngineBrakeController = new ScriptedBrakeController(this);
            ThrottleController = new MSTSNotchController();
            DynamicBrakeController = new MSTSNotchController();
            TrainControlSystem = new ScriptedTrainControlSystem(this);
        }

        /// <summary>
        /// This initializer is called when we haven't loaded this type of car before
        /// and must read it new from the wag file.
        /// </summary>
        public override void LoadFromWagFile(string wagFilePath)
        {
            base.LoadFromWagFile(wagFilePath);

            // Assumes that CabViewList[0] is the front cab
            // and that CabViewList[1] is the rear cab, if present.
            // Could be extended to more than 2 cabs.
            if (CVFFileName != null)
            {
                var cabView = BuildCabView(WagFilePath, CVFFileName);
                if (cabView != null)
                {
                    CabViewList.Add(cabView);
                    var reverseCVFFileName = Path.Combine(
                        Path.GetDirectoryName(CVFFileName), // Some CVF paths begin with "..\..\", so Path.GetDirectoryName() is needed.
                        Path.GetFileNameWithoutExtension(CVFFileName) + "_rv.cvf"
                    );

                    {
                        cabView = BuildCabView(WagFilePath, reverseCVFFileName);
                        if (cabView != null)
                            CabViewList.Add(cabView);
                    }
                    // practically never happens, but never say never
                    if (CabViewList.Count == 2 && CabViewList[1].CabViewType == CabViewType.Front && CabViewList[0].CabViewType == CabViewType.Rear)
                    {
                        cabView = CabViewList[1];
                        CabViewList.Insert(0, cabView);
                        CabViewList.RemoveAt(2);
                    }
                    // only one cabview, and it looks rear; insert a void one at first place to maintain fast indexing
                    else if (CabViewList.Count == 1 && CabViewList[0].CabViewType == CabViewType.Rear)
                    {
                        UsingRearCab = true;
                        CabViewList.Add(CabViewList[0]);
                        CabViewList[0].CabViewType = CabViewType.Void;
                    }
                }
                CabView3D = BuildCab3DView();
                if (CabViewList.Count == 0 & CabView3D == null)
                    Trace.TraceWarning("{0} locomotive's CabView references non-existent {1}", wagFilePath, CVFFileName);
            }

            CorrectBrakingParams();
            CheckCoherence();
            GetPressureUnit();
            IsDriveable = true;

            MoveParamsToAxle();
        }

        protected void CheckCoherence()
        {
            if (!TrainBrakeController.IsValid())
                TrainBrakeController = new ScriptedBrakeController(this); //create a blank one
            if (!EngineBrakeController.IsValid())
                EngineBrakeController = null;

            if (ThrottleController == null)
            {
                //If no controller so far, we create a default one
                ThrottleController = new MSTSNotchController();
                ThrottleController.StepSize = 0.1f;
            }

            // need to test for Dynamic brake problem on 3DTS and SLI
            if (DynamicBrakeController.IsValid())
            {
                if (DynamicBrakeController.NotchCount() <= 3)
                {
                    HasSmoothStruc = true;
                }
            }
            else
                DynamicBrakeController = null;

            if (DynamicBrakeForceCurves == null && MaxDynamicBrakeForceN > 0)
            {
                DynamicBrakeForceCurves = new InterpolatorDiesel2D(2);
                Interpolator interp = new Interpolator(2);
                interp[0] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[0] = interp;
                interp = new Interpolator(7);
                interp[0] = 0;
                interp[DynamicBrakeSpeed1MpS] = 0;
                interp[DynamicBrakeSpeed2MpS] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed3MpS] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4MpS] = DynamicBrakeRatioAtSpeed4 * MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4MpS + 0.5f] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[1] = interp;
            }
        }

        protected void GetPressureUnit()
        {
            switch (Simulator.Settings.PressureUnit)
            {
                default:
                case "Automatic":
                    if (CabViewList.Count > 0)
                    {
                        Dictionary<CABViewControlTypes, BrakeSystemComponent> brakeSystemComponents = new Dictionary<CABViewControlTypes, BrakeSystemComponent>
                        {
                            { CABViewControlTypes.MAIN_RES, BrakeSystemComponent.MainReservoir },
                            { CABViewControlTypes.EQ_RES, BrakeSystemComponent.EqualizingReservoir },
                            { CABViewControlTypes.BRAKE_CYL, BrakeSystemComponent.BrakeCylinder },
                            { CABViewControlTypes.BRAKE_PIPE, BrakeSystemComponent.BrakePipe }
                        };

                        Dictionary<CABViewControlUnits, PressureUnit> pressureUnits = new Dictionary<CABViewControlUnits, PressureUnit>
                        {
                            { CABViewControlUnits.KILOPASCALS, PressureUnit.KPa },
                            { CABViewControlUnits.BAR, PressureUnit.Bar },
                            { CABViewControlUnits.PSI, PressureUnit.PSI },
                            { CABViewControlUnits.INCHES_OF_MERCURY, PressureUnit.InHg },
                            { CABViewControlUnits.KGS_PER_SQUARE_CM, PressureUnit.KgfpCm2 }
                       };

                        CabViewControls cvcList = CabViewList[0].CVFFile.CabViewControls;
                        foreach (CabViewControl cvc in cvcList)
                        {
                            if (brakeSystemComponents.ContainsKey(cvc.ControlType) && pressureUnits.ContainsKey(cvc.Units))
                            {
                                BrakeSystemComponent component = brakeSystemComponents[cvc.ControlType];
                                PressureUnit unit = pressureUnits[cvc.Units];

                                BrakeSystemPressureUnits[component] = unit;
                            }
                        }
                    }

                    // Manual rules :
                    BrakeSystemPressureUnits[BrakeSystemComponent.MainPipe] = BrakeSystemPressureUnits[BrakeSystemComponent.MainReservoir]; // Main Pipe is supplied by Main Reservoir
                    BrakeSystemPressureUnits[BrakeSystemComponent.AuxiliaryReservoir] = BrakeSystemPressureUnits[BrakeSystemComponent.BrakePipe]; // Auxiliary Reservoir is supplied by Brake Pipe (in single pipe brakes)
                    BrakeSystemPressureUnits[BrakeSystemComponent.EmergencyReservoir] = BrakeSystemPressureUnits[BrakeSystemComponent.BrakePipe]; // Emergency Reservoir is supplied by Brake Pipe

                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        if (BrakeSystemPressureUnits[component] == PressureUnit.None)
                        {
                            BrakeSystemPressureUnits[component] = (MilepostUnitsMetric ? PressureUnit.Bar : PressureUnit.PSI);
                        }
                    }
                    break;

                case "bar":
                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        BrakeSystemPressureUnits[component] = PressureUnit.Bar;
                    }
                    break;

                case "PSI":
                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        BrakeSystemPressureUnits[component] = PressureUnit.PSI;
                    }
                    break;

                case "inHg":
                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        BrakeSystemPressureUnits[component] = PressureUnit.InHg;
                    }
                    break;

                case "kgf/cm^2":
                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        BrakeSystemPressureUnits[component] = PressureUnit.KgfpCm2;
                    }
                    break;
            }

            // The main pressure unit is the one that is the most present in the brake system
            MainPressureUnit = BrakeSystemPressureUnits.Values.ToList()
                .GroupBy(x => x)
                .OrderByDescending(x => x.Count())
                .First().Key;
        }

        protected CabView BuildCabView(string wagFilePath, string cvfFileName)
        {
            var viewPointList = new List<ViewPoint>();
            var extendedCVF = new ExtendedCVF();
            bool noseAhead = false;

            var cvfBasePath = Path.Combine(Path.GetDirectoryName(wagFilePath), "CABVIEW");
            var cvfFilePath = Path.Combine(cvfBasePath, cvfFileName);
            if (!File.Exists(cvfFilePath))
                return null;

            var cvfFile = new CabViewFile(cvfFilePath, cvfBasePath);
            var viewPoint = new ViewPoint();
            if (cvfFile.Locations.Count <= 0) return null; //check for Protrain's dummy cab
            // Set up camera locations for the cab views
            for (int i = 0; i < cvfFile.Locations.Count; ++i)
            {
                if (i >= cvfFile.Locations.Count || i >= cvfFile.Directions.Count)
                {
                    Trace.TraceWarning("Skipped cab view camera {1} missing Position and Direction in {0}", cvfFilePath, i);
                    break;
                }
                viewPoint = new ViewPoint();
                viewPoint.Location = cvfFile.Locations[i];
                viewPoint.StartDirection = cvfFile.Directions[i];
                viewPoint.RotationLimit = new Vector3(0, 0, 0);  // cab views have a fixed head position
                viewPointList.Add(viewPoint);
            }
            var cabViewType = new CabViewType();
            cabViewType = ((viewPointList[0].StartDirection.Y >= 90 && viewPointList[0].StartDirection.Y <= 270)
                || (viewPointList[0].StartDirection.Y <= -90 && viewPointList[0].StartDirection.Y >= -270)) ? CabViewType.Rear : CabViewType.Front;
            var wag = this as MSTSWagon;
            var wagFolderSlash = Path.GetDirectoryName(wag.WagFilePath) + @"\";
            string shapeFilePath;
            bool boundingLimitsFound = false;
            ShapeDescriptorFile shapeFile = new ShapeDescriptorFile();
            if (wag.FreightShapeFileName != null)
            {
                shapeFilePath = wagFolderSlash + wag.FreightShapeFileName;
                if (shapeFilePath != null && File.Exists(shapeFilePath + "d"))
                {
                    shapeFile = new ShapeDescriptorFile(shapeFilePath + "d");
                    if (shapeFile.shape.ESD_Bounding_Box != null) boundingLimitsFound = true;
                }
            }
            if (!boundingLimitsFound)
            {
                shapeFilePath = wagFolderSlash + wag.MainShapeFileName;
                if (shapeFilePath != null && File.Exists(shapeFilePath + "d"))
                {
                    shapeFile = new ShapeDescriptorFile(shapeFilePath + "d");
                    if (shapeFile.shape.ESD_Bounding_Box != null) boundingLimitsFound = true;
                }
            }
            if (boundingLimitsFound)
            {
                if (cabViewType == CabViewType.Front)
                    noseAhead = (viewPointList[0].Location.Z + 0.5f < shapeFile.shape.ESD_Bounding_Box.Max.Z) ? true : false;
                else if (cabViewType == CabViewType.Rear)
                    noseAhead = (viewPointList[0].Location.Z - 0.5f > shapeFile.shape.ESD_Bounding_Box.Min.Z) ? true : false;
            }
            if (!(this is MSTSSteamLocomotive))
            {
                InitializeFromORTSSpecific(cvfFilePath, extendedCVF);
            }
            return new CabView(cvfFile, viewPointList, extendedCVF, cabViewType, noseAhead);
        }

        protected CabView3D BuildCab3DView()
        {
            if (Cab3DShapeFileName == null)
                return null;

            var extendedCVF = new ExtendedCVF();
            bool noseAhead = false;

            var cab3dBasePath = Path.Combine(Path.GetDirectoryName(WagFilePath), "CABVIEW3D");
            var shapeFilePath = Path.Combine(cab3dBasePath, Cab3DShapeFileName);
            if (!File.Exists(shapeFilePath))
                return null;

            var cvfBasePath = cab3dBasePath;
            var cvfFilePath = Path.Combine(cvfBasePath, Path.ChangeExtension(Cab3DShapeFileName, "cvf"));
            if (!File.Exists(cvfFilePath))
            {
                cvfFilePath = Path.Combine(cvfBasePath, CVFFileName);
                if (!File.Exists(cvfFilePath))
                {
                    cvfBasePath = Path.Combine(Path.GetDirectoryName(WagFilePath), "CABVIEW");
                    cvfFilePath = Path.Combine(cvfBasePath, CVFFileName);
                    if (!File.Exists(cvfFilePath))
                        return null;
                }
            }
            var cvfFile = new CabViewFile(cvfFilePath, cvfBasePath);
            if (!(this is MSTSSteamLocomotive))
                InitializeFromORTSSpecific(cvfFilePath, extendedCVF);

            return new CabView3D(cvfFile, CabViewpoints, extendedCVF, CabViewType.Front, noseAhead, shapeFilePath);
        }

        /// <summary>
        /// Parse the wag file parameters required for the simulator and viewer classes
        /// </summary>
        public override void Parse(string lowercasetoken, STFReader stf)
        {
            switch (lowercasetoken)
            {
                case "engine(sound": CabSoundFileName = stf.ReadStringBlock(null); break;
                case "engine(cabview": CVFFileName = stf.ReadStringBlock(null); break;
                case "engine(maxpower": MaxPowerW = stf.ReadFloatBlock(STFReader.UNITS.Power, null); break;
                case "engine(maxforce": MaxForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxcurrent": MaxCurrentA = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(maxcontinuousforce": MaxContinuousForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxvelocity": MaxSpeedMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;

                case "engine(type":
                    stf.MustMatch("(");
                    var engineType = stf.ReadString();
                    try
                    {
                        EngineType = (EngineTypes)Enum.Parse(typeof(EngineTypes), engineType.First().ToString().ToUpper() + engineType.Substring(1));
                    }
                    catch
                    {
                        STFException.TraceWarning(stf, "Skipped unknown engine type " + engineType);
                    }
                    break;

                case "engine(enginecontrollers(throttle": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(regulator": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(brake_dynamic": DynamicBrakeController.Parse(stf); break;

                case "engine(trainbrakescontrollermaxsystempressure":
                case "engine(trainbrakescontrollermaxreleaserate":
                case "engine(trainbrakescontrollermaxquickreleaserate":
                case "engine(trainbrakescontrollermaxapplicationrate":
                case "engine(trainbrakescontrolleremergencyapplicationrate":
                case "engine(trainbrakescontrollerfullservicepressuredrop":
                case "engine(trainbrakescontrollerminpressurereduction":
                case "engine(ortstrainbrakecontroller":
                case "engine(enginecontrollers(brake_train":
                    TrainBrakeController.Parse(lowercasetoken, stf);
                    break;

                case "engine(enginebrakescontrollermaxsystempressure":
                case "engine(enginebrakescontrollermaxreleaserate":
                case "engine(enginebrakescontrollermaxquickreleaserate":
                case "engine(enginebrakescontrollermaxapplicationrate":
                case "engine(enginebrakescontrolleremergencyapplicationrate":
                case "engine(enginebrakescontrollerfullservicepressuredrop":
                case "engine(enginebrakescontrollerminpressurereduction":
                case "engine(enginecontrollers(brake_engine":
                case "engine(ortsenginebrakecontroller":
                    EngineBrakeController.Parse(lowercasetoken, stf);
                    EngineBrakeFitted = true;
                    break;

                case "engine(ortstraincontrolsystem":
                case "engine(ortstraincontrolsystemsound":
                case "engine(ortstraincontrolsystemparameters":
                case "engine(vigilancemonitor":
                case "engine(emergencystopmonitor":
                case "engine(awsmonitor":
                case "engine(overspeedmonitor": VigilanceMonitor = true; TrainControlSystem.Parse(lowercasetoken, stf); break;
                case "engine(enginecontrollers(combined_control": ParseCombData(lowercasetoken, stf); break;
                case "engine(airbrakesmainresvolume": MainResVolumeM3 = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(airbrakesmainmaxairpressure": MainResPressurePSI = MaxMainResPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(airbrakescompressorrestartpressure": CompressorRestartPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(airbrakesaircompressorpowerrating": CompressorChargingRateM3pS = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(trainpipeleakrate": TrainBrakePipeLeakPSIorInHgpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(vacuumbrakesvacuumpumpresistance": VacuumPumpResistanceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;

                case "engine(ortsvacuumbrakesmainresvolume": VacuumBrakesMainResVolumeM3 = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(ortsvacuumbrakesmainresmaxvacuum": VacuumBrakesMainResMaxVacuumPSIAorInHg = OneAtmospherePSI - stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break; // convert to PSIA for vacuum brakes
                case "engine(ortsvacuumbrakesexhausterrestartvacuum": VacuumBrakesExhausterRestartVacuumPSIAorInHg = OneAtmospherePSI - stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break; // convert to PSIA for vacuum brakes
                case "engine(ortsvacuumbrakesmainreschargingrate": VacuumBrakesMainResChargingRatePSIAorInHgpS = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;

                case "engine(ortsmainreschargingrate": MainResChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsenginebrakereleaserate": EngineBrakeReleaseRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsenginebrakeapplicationrate": EngineBrakeApplyRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsbrakepipetimefactor": BrakePipeTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(ortsbrakeservicetimefactor": BrakeServiceTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(ortsbrakeemergencytimefactor": BrakeEmergencyTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(ortsbrakepipechargingrate": BrakePipeChargingRatePSIorInHgpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsbrakepipedischargetimemult": BrakePipeDischargeTimeFactor = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(ortsmaxtractiveforcecurves": TractiveForceCurves = new InterpolatorDiesel2D(stf, false); TractiveForceCurves.HasNegativeValue();  break;
                case "engine(ortstractioncharacteristics": TractiveForceCurves = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortsdynamicbrakeforcecurves": DynamicBrakeForceCurves = new InterpolatorDiesel2D(stf, false); break;
                case "engine(ortscontinuousforcetimefactor": ContinuousForceTimeFactor = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(orts(ortssanderspeedeffectupto": SanderSpeedEffectUpToMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(orts(ortsemergencycausespowerdown": EmergencyCausesPowerDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(ortsemergencycausesthrottledown": EmergencyCausesThrottleDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(ortsemergencyengageshorn": EmergencyEngagesHorn = stf.ReadBoolBlock(false); break;
                case "engine(orts(ortswheelslipcausesthrottledown": WheelslipCausesThrottleDown = stf.ReadBoolBlock(false); break;
                case "engine(dynamicbrakesminusablespeed": DynamicBrakeSpeed1MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesfadingspeed": DynamicBrakeSpeed2MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesmaximumeffectivespeed": DynamicBrakeSpeed3MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesmaximumspeedforfadeout": DynamicBrakeSpeed4MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakeseffectatmaximumfadeout": DynamicBrakeRatioAtSpeed4 = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(dynamicbrakesmaximumforce": MaxDynamicBrakeForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(dynamicbrakehasautobailoff":
                case "engine(ortsdynamicbrakeshasautobailoff": DynamicBrakeAutoBailOff = stf.ReadBoolBlock(true); break;
                case "engine(dynamicbrakesdelaytimebeforeengaging": DynamicBrakeDelayS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(dynamicbrakesresistorcurrentlimit": DynamicBrakeMaxCurrentA = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(numwheels": LocoNumDrvWheels = stf.ReadFloatBlock(STFReader.UNITS.None, 4.0f); if (LocoNumDrvWheels < 1) STFException.TraceWarning(stf, "Engine:NumWheels is less than 1, parts of the simulation may not function correctly"); break;
                case "engine(antislip": AntiSlip = stf.ReadBoolBlock(false); break;
                case "engine(ortsdrivewheelweight": InitialDrvWheelWeightKg = stf.ReadFloatBlock(STFReader.UNITS.Mass, null); break;
                case "engine(engineoperatingprocedures": EngineOperatingProcedures = stf.ReadStringBlock(""); break;
                case "engine(headout":
                    HeadOutViewpoints.Add(new ViewPoint(stf.ReadVector3Block(STFReader.UNITS.Distance, Vector3.Zero)));
                    HeadOutViewpoints.Add(new ViewPoint(HeadOutViewpoints[0], true));
                    break;
                case "engine(sanding": SanderSpeedOfMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, 30.0f); break;
                case "engine(doesbrakecutpower": DoesBrakeCutPower = stf.ReadBoolBlock(false); break;
                case "engine(brakecutspoweratbrakecylinderpressure": BrakeCutsPowerAtBrakeCylinderPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(doeshorntriggerbell": DoesHornTriggerBell = stf.ReadBoolBlock(false); break;
                case "engine(brakesenginecontrollers":
                    foreach (var brakesenginecontrollers in stf.ReadStringBlock("").ToLower().Replace(" ", "").Split(','))
                    {
                        if (EngineType == EngineTypes.Electric || EngineType == EngineTypes.Diesel)
                        {
                            switch (brakesenginecontrollers)
                            {
                                case "blended":                              
                                    DynamicBrakeBlendingEnabled = true;
                                    break;
                                case "dynamic":
                                    DynamicBrakeAvailable = true;
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                    break;

                case "engine(brakestrainbraketype":
                    foreach (var brakestrainbraketype in stf.ReadStringBlock("").ToLower().Replace(" ", "").Split(','))
                    {
                        switch (brakestrainbraketype)
                            {
                                case "vacuum_single_pipe_eq":
                                    VacuumBrakeEQFitted = true;
                                    break;
                                 default:
                                    break;
                            }
                    }
                    break;
                case "engine(ortsdynamicblendingoverride": DynamicBrakeBlendingOverride = stf.ReadBoolBlock(false); break;
                case "engine(ortsdynamicblendingforcematch": DynamicBrakeBlendingForceMatch = stf.ReadBoolBlock(false); break;
                case "engine(vacuumbrakeshasvacuumpump": VacuumPumpFitted = stf.ReadBoolBlock(false); break;
                case "engine(enginecontrollers(ortssteamheat": SteamHeatController.Parse(stf); break;
                case "engine(name": stf.MustMatch("("); LocomotiveName = stf.ReadString(); break;
                case "engine(maxsteamheatingpressure": MaxSteamHeatPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(ortsonlinecabradio": OnLineCabRadio = stf.ReadBoolBlock(false); break;
                case "engine(ortsonlinecabradiourl": OnLineCabRadioURL = stf.ReadString(); break;
                case "engine(vacuumbrakesminboilerpressuremaxvacuum": MaxVaccuumMaxPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(enginecontrollers(waterscoop": HasWaterScoop = true; break;
                case "engine(ortswaterscoopfillelevation": WaterScoopFillElevationM = stf.ReadFloatBlock(STFReader.UNITS.Distance, 0.0f); break;
                case "engine(ortswaterscoopdepth": WaterScoopDepthM = stf.ReadFloatBlock(STFReader.UNITS.Distance, 0.0f); break;
                case "engine(ortswaterscoopwidth": WaterScoopWidthM = stf.ReadFloatBlock(STFReader.UNITS.Distance, 0.0f); break;
                default: base.Parse(lowercasetoken, stf); break;
                    
            }
        }

        /// <summary>
        /// This initializer is called when we are making a new copy of a car already
        /// loaded in memory.  We use this one to speed up loading by eliminating the
        /// need to parse the wag file multiple times.
        /// </summary>
        public override void Copy(MSTSWagon copy)
        {
            base.Copy(copy);  // each derived level initializes its own variables

            MSTSLocomotive locoCopy = (MSTSLocomotive)copy;
            CabSoundFileName = locoCopy.CabSoundFileName;
            CVFFileName = locoCopy.CVFFileName;
            CabViewList = locoCopy.CabViewList;
            CabView3D = locoCopy.CabView3D;
            MaxPowerW = locoCopy.MaxPowerW;
            MaxForceN = locoCopy.MaxForceN;
            MaxCurrentA = locoCopy.MaxCurrentA;
            MaxSpeedMpS = locoCopy.MaxSpeedMpS;
            EngineType = locoCopy.EngineType;
            TractiveForceCurves = locoCopy.TractiveForceCurves;
            MaxContinuousForceN = locoCopy.MaxContinuousForceN;
            ContinuousForceTimeFactor = locoCopy.ContinuousForceTimeFactor;
            DynamicBrakeForceCurves = locoCopy.DynamicBrakeForceCurves;
            DynamicBrakeAutoBailOff = locoCopy.DynamicBrakeAutoBailOff;
            CombinedControlType = locoCopy.CombinedControlType;
            CombinedControlSplitPosition = locoCopy.CombinedControlSplitPosition;
            DynamicBrakeDelayS = locoCopy.DynamicBrakeDelayS;
            MaxDynamicBrakeForceN = locoCopy.MaxDynamicBrakeForceN;
            HasSmoothStruc = locoCopy.HasSmoothStruc;
            LocoNumDrvWheels = locoCopy.LocoNumDrvWheels;
            AntiSlip = locoCopy.AntiSlip;
            VacuumPumpFitted = locoCopy.VacuumPumpFitted;
            DrvWheelWeightKg = locoCopy.DrvWheelWeightKg;
            InitialDrvWheelWeightKg = locoCopy.InitialDrvWheelWeightKg;
            SanderSpeedEffectUpToMpS = locoCopy.SanderSpeedEffectUpToMpS;
            SanderSpeedOfMpS = locoCopy.SanderSpeedOfMpS;
            PowerOnDelayS = locoCopy.PowerOnDelayS;
            DoesHornTriggerBell = locoCopy.DoesHornTriggerBell;
            MaxSteamHeatPressurePSI = locoCopy.MaxSteamHeatPressurePSI;
            VacuumPumpResistanceN = locoCopy.VacuumPumpResistanceN;
            VacuumBrakesMainResVolumeM3 = locoCopy.VacuumBrakesMainResVolumeM3;
            VacuumBrakesMainResMaxVacuumPSIAorInHg = locoCopy.VacuumBrakesMainResMaxVacuumPSIAorInHg;
            VacuumBrakesExhausterRestartVacuumPSIAorInHg = locoCopy.VacuumBrakesExhausterRestartVacuumPSIAorInHg;
            VacuumBrakesMainResChargingRatePSIAorInHgpS = locoCopy.VacuumBrakesMainResChargingRatePSIAorInHgpS;

            EmergencyCausesPowerDown = locoCopy.EmergencyCausesPowerDown;
            EmergencyCausesThrottleDown = locoCopy.EmergencyCausesThrottleDown;
            EmergencyEngagesHorn = locoCopy.EmergencyEngagesHorn;

            WheelslipCausesThrottleDown = locoCopy.WheelslipCausesThrottleDown;

            CompressorRestartPressurePSI = locoCopy.CompressorRestartPressurePSI;
            TrainBrakePipeLeakPSIorInHgpS = locoCopy.TrainBrakePipeLeakPSIorInHgpS;
            MaxMainResPressurePSI = locoCopy.MaxMainResPressurePSI;
            MainResPressurePSI = MaxMainResPressurePSI;
            MainResVolumeM3 = locoCopy.MainResVolumeM3;
            MainResChargingRatePSIpS = locoCopy.MainResChargingRatePSIpS;
            BrakePipeDischargeTimeFactor = locoCopy.BrakePipeDischargeTimeFactor;

            DynamicBrakeBlended = locoCopy.DynamicBrakeBlended;
            DynamicBrakeBlendingEnabled = locoCopy.DynamicBrakeBlendingEnabled;
            airPipeSystem = locoCopy.airPipeSystem;
            DynamicBrakeCommandStartTime = locoCopy.DynamicBrakeCommandStartTime;
            DynamicBrakeBlendingOverride = locoCopy.DynamicBrakeBlendingOverride;
            DynamicBrakeBlendingForceMatch = locoCopy.DynamicBrakeBlendingForceMatch;

            MainPressureUnit = locoCopy.MainPressureUnit;
            BrakeSystemPressureUnits = locoCopy.BrakeSystemPressureUnits;
            IsDriveable = copy.IsDriveable;
            //ThrottleController = MSTSEngineController.Copy(locoCopy.ThrottleController);
            ThrottleController = (MSTSNotchController)locoCopy.ThrottleController.Clone();
            SteamHeatController = (MSTSNotchController)locoCopy.SteamHeatController.Clone();
            TrainBrakeController = locoCopy.TrainBrakeController.Clone(this);
            EngineBrakeController = locoCopy.EngineBrakeController != null ? locoCopy.EngineBrakeController.Clone(this) : null;
            DynamicBrakeController = locoCopy.DynamicBrakeController != null ? (MSTSNotchController)locoCopy.DynamicBrakeController.Clone() : null;
            TrainControlSystem.Copy(locoCopy.TrainControlSystem);
            LocomotiveName = locoCopy.LocomotiveName;
            MaxVaccuumMaxPressurePSI = locoCopy.MaxVaccuumMaxPressurePSI;
            VacuumBrakeEQFitted = locoCopy.VacuumBrakeEQFitted;
            HasWaterScoop = locoCopy.HasWaterScoop;
            WaterScoopFillElevationM = locoCopy.WaterScoopFillElevationM;
            WaterScoopDepthM = locoCopy.WaterScoopDepthM;
            WaterScoopWidthM = locoCopy.WaterScoopWidthM;
            MoveParamsToAxle();


        }

        /// <summary>
        /// We are moving parameters from locomotive to axle. 
        /// </summary>
        public void MoveParamsToAxle()
        {
            if (LocomotiveAxle != null)
            {
                LocomotiveAxle.SlipWarningTresholdPercent = SlipWarningThresholdPercent;
                LocomotiveAxle.AdhesionK = AdhesionK;
                LocomotiveAxle.CurtiusKnifflerA = Curtius_KnifflerA;
                LocomotiveAxle.CurtiusKnifflerB = Curtius_KnifflerB;
                LocomotiveAxle.CurtiusKnifflerC = Curtius_KnifflerC;
            }
        }

        /// <summary>
        /// We are saving the game.  Save anything that we'll need to restore the 
        /// status later.
        /// </summary>
        public override void Save(BinaryWriter outf)
        {
            // we won't save the horn state
            outf.Write(Bell);
            outf.Write(Sander);
            outf.Write(Wiper);
            outf.Write(OdometerResetPositionM);
            outf.Write(OdometerCountingUp);
            outf.Write(OdometerCountingForwards);
            outf.Write(OdometerVisible);
            outf.Write(MainResPressurePSI);
            outf.Write(CompressorIsOn);
            outf.Write(VacuumMainResVacuumPSIAorInHg);
            outf.Write(VacuumExhausterIsOn);
            outf.Write(TrainBrakePipeLeakPSIorInHgpS);
            outf.Write(AverageForceN);
            outf.Write(LocomotiveAxle.AxleSpeedMpS);
            outf.Write(CabLightOn);
            outf.Write(UsingRearCab);
            ControllerFactory.Save(ThrottleController, outf);
            ControllerFactory.Save(TrainBrakeController, outf);
            ControllerFactory.Save(EngineBrakeController, outf);
            ControllerFactory.Save(DynamicBrakeController, outf);
            ControllerFactory.Save(SteamHeatController, outf);
            outf.Write(AcceptMUSignals);
            outf.Write(PowerReduction);
            outf.Write(ScoopIsBroken);
            outf.Write(IsWaterScoopDown);

            base.Save(outf);
        }

        /// <summary>
        /// We are restoring a saved game.  The TrainCar class has already
        /// been initialized.   Restore the game state.
        /// </summary>
        public override void Restore(BinaryReader inf)
        {
            if (inf.ReadBoolean()) SignalEvent(Event.BellOn);
            if (inf.ReadBoolean()) SignalEvent(Event.SanderOn);
            if (inf.ReadBoolean()) SignalEvent(Event.WiperOn);
            OdometerResetPositionM = inf.ReadSingle();
            OdometerCountingUp = inf.ReadBoolean();
            OdometerCountingForwards = inf.ReadBoolean();
            OdometerVisible = inf.ReadBoolean();
            MainResPressurePSI = inf.ReadSingle();
            CompressorIsOn = inf.ReadBoolean();
            VacuumMainResVacuumPSIAorInHg = inf.ReadSingle();
            VacuumExhausterIsOn = inf.ReadBoolean();
            TrainBrakePipeLeakPSIorInHgpS = inf.ReadSingle();
            AverageForceN = inf.ReadSingle();
            LocomotiveAxle.Reset(Simulator.GameTime, inf.ReadSingle());
            CabLightOn = inf.ReadBoolean();
            UsingRearCab = inf.ReadBoolean();
            ControllerFactory.Restore(ThrottleController, inf);
            ControllerFactory.Restore(TrainBrakeController, inf);
            ControllerFactory.Restore(EngineBrakeController, inf);
            ControllerFactory.Restore(DynamicBrakeController, inf);
            ControllerFactory.Restore(SteamHeatController, inf);
            AcceptMUSignals = inf.ReadBoolean();
            PowerReduction = inf.ReadSingle();
            ScoopIsBroken = inf.ReadBoolean();
            IsWaterScoopDown = inf.ReadBoolean();

            AdhesionFilter.Reset(0.5f);

            base.Restore(inf);
        }

        public bool IsLeadLocomotive()
        {
            return Train.LeadLocomotive == this;
        }

        protected void ParseCombData(string lowercasetoken, STFReader stf)
        {
            var throttle = false;
            var train = false;
            var dynamic = false;
            var independent = false;

            stf.MustMatch("(");
            var minValue = stf.ReadFloat(STFReader.UNITS.None, 0);
            var maxValue = stf.ReadFloat(STFReader.UNITS.None, 1);
            var split = stf.ReadFloat(STFReader.UNITS.None, 0.5f);
            var defaultValue = stf.ReadFloat(STFReader.UNITS.None, 0.5f);

            string s;
            while ((s = stf.ReadItem()) != ")")
            {
                throttle |= s == "throttle";
                train |= s == "train";
                dynamic |= s == "dynamic";
                independent |= s == "independent";
            }

            CombinedControlSplitPosition = (split - minValue) / (maxValue - minValue);

            if (throttle && dynamic && train)
                CombinedControlType = CombinedControl.ThrottleDynamicAir;
            else if (throttle && train)
                CombinedControlType = CombinedControl.ThrottleAir;
            else if (throttle && dynamic)
                CombinedControlType = CombinedControl.ThrottleDynamic;
            else if (dynamic && train)
                CombinedControlType = CombinedControl.DynamicAir;

            if (train && !TrainBrakeController.IsValid())
                TrainBrakeController = new ScriptedBrakeController(this);
            if (dynamic && !DynamicBrakeController.IsValid())
                DynamicBrakeController = new MSTSNotchController(0, 1, .05f);
            if (dynamic)
                DynamicBrake = true;
        }

        /// <summary>
        /// Sets controler settings from other engine for cab switch
        /// </summary>
        /// <param name="other"></param>
        public override void CopyControllerSettings(TrainCar other)
        {
            base.CopyControllerSettings(other);
            if (ThrottleController != null)
                ThrottleController.SetValue(other.ThrottlePercent / 100);
            if (DynamicBrakeController != null)
                DynamicBrakeController.SetValue(other.DynamicBrakePercent / 100);
            if (TrainBrakeController != null)
                TrainBrakeController.SetValue(((MSTSLocomotive)other).TrainBrakeController.CurrentValue);
            if (EngineBrakeController != null)
                EngineBrakeController.SetValue(0);
        }

        public bool controlUpdated;
        public bool notificationReceived;

        /// <summary>
        /// Called just after the InitializeFromWagFile
        /// </summary>
        public override void Initialize()
        {
            TrainBrakeController.Initialize();
            EngineBrakeController.Initialize();
            TrainControlSystem.Initialize();

            if (MaxSteamHeatPressurePSI == 0)       // Check to see if steam heating is fitted to locomotive
            {
                IsSteamHeatFitted = false;
                TrainFittedSteamHeat = false;
            }
            else
            {
                IsSteamHeatFitted = true;
                TrainFittedSteamHeat = true;
                CurrentSteamHeatFuelCapacityL = SteamHeatFuelTankCapacityL;
            }

            SteamHeatPressureToTemperaturePSItoF = SteamTable.SteamHeatPressureToTemperatureInterpolatorPSItoF();

            // Check to see if water scoop elements have been configured
            if (WaterScoopFillElevationM == 0)
            {
                WaterScoopFillElevationM = 2.7432f; // Set to default of 9 ft
            } 

            if (WaterScoopDepthM == 0)
            {
                WaterScoopDepthM = 0.0889f; // Set to default of 3.5 ins
            }

            if (WaterScoopWidthM == 0)
            {
                WaterScoopWidthM = 0.3048f; // Set to default of 1 ft
            }
            
            // Calculate minimum speed to pickup water
            const float Aconst = 2;
            WaterScoopMinSpeedMpS = Me.FromFt((float)Math.Sqrt(Aconst * GravitationalAccelerationFtpSpS * Me.ToFt(WaterScoopFillElevationM)));

            // Initialise Brake Pipe Charging Rate
            if (BrakePipeChargingRatePSIorInHgpS == 0) // Check to see if BrakePipeChargingRate has been set in the ENG file.
            {
                // Set Default BrakePipe Charging Rate depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakePipeChargingRatePSIorInHgpS = 0.32f; // Vacuum brakes
                }
                else
                {
                    BrakePipeChargingRatePSIorInHgpS = Simulator.Settings.BrakePipeChargingRate; // Air brakes
                }
            }

            // Initialise Exhauster Charging rate in diesel and electric locomotives. The equivalent ejector charging rates are set in the steam locomotive.
            if (this is MSTSDieselLocomotive || this is MSTSElectricLocomotive)
            {
                ExhausterHighSBPChargingRatePSIorInHgpS = BrakePipeChargingRatePSIorInHgpS;
                ExhausterLowSBPChargingRatePSIorInHgpS = BrakePipeChargingRatePSIorInHgpS / 5.0f; // Low speed exhauster setting is 1/5 of high speed
            }
            else
            {
                // Default to zero if not used.
                ExhausterHighSBPChargingRatePSIorInHgpS = 0.0f;
                ExhausterLowSBPChargingRatePSIorInHgpS = 0.0f;
            }

            // Initialise BrakePipeDischargeTimeFactor
            if (BrakePipeDischargeTimeFactor == 0)
            {
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakePipeDischargeTimeFactor = 1.5f; // Vacuum brakes
                }
                else
                {
                    BrakePipeDischargeTimeFactor = 1.5f; // Air brakes
                }
            }
            
            // Initialise the resistance of the vacuum pump
            if (VacuumPumpResistanceN == 0)
            {
                VacuumPumpResistanceN = 120.0f;
            }

            // Initialise Brake Emergency Time Factor
            if (BrakeEmergencyTimeFactorS == 0) // Check to see if BrakeEmergencyTimeFactorS has been set in the ENG file.
            {
                // Set Default Brake Emergency Time Factor depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakeEmergencyTimeFactorS = 1.0f; // Vacuum brakes
                }
                else
                {
                    BrakeEmergencyTimeFactorS = 0.1f; // Air brakes
                }
            }

            // Initialise Brake Service Time Factor
            if (BrakeServiceTimeFactorS == 0) // Check to see if BrakeServiceTimeFactorS has been set in the ENG file.
            {
                // Set Default Brake Service Time Factor depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakeServiceTimeFactorS = 10.0f; // Vacuum brakes
                }
                else
                {
                    BrakeServiceTimeFactorS = 1.009f; // Air brakes
                }
            }

            // Check TrainBrakesControllerMaxSystemPressure parameter for "correct" value 
            // This is only done for vacuum brakes as the UoM can be confusing - it defaults to psi, and if no units are entered then a InHG value can be incorrectly converted.
            if ((BrakeSystem is VacuumSinglePipe) && TrainBrakeController.MaxPressurePSI > 12.5)
            {
                Trace.TraceInformation("TrainBrakeController.MaxPressurePSI being read as {0} Inhg, - defaulted to value of 21 InHg", Bar.ToInHg(Bar.FromPSI(TrainBrakeController.MaxPressurePSI)));
            }

            // Initialise Brake Time Factor
            if (BrakePipeTimeFactorS == 0) // Check to see if BrakePipeTimeFactorS has been set in the ENG file.
            {
                // Set Default Brake Pipe Time Factor depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakePipeTimeFactorS = 0.02f; // Vacuum brakes
                }
                else
                {
                    BrakePipeTimeFactorS = 0.0015f; // Air brakes
                }
            }

            // Initialise Train Pipe Leak Rate
            if (TrainBrakePipeLeakPSIorInHgpS == 0) // Check to see if TrainBrakePipeLeakPSIorInHgpS has been set in the ENG file.
            {
                // Set Default Train Brake Pipe Leak depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                // Default currently set to zero - means that by default function is off, and a value must be entered into the ENG file to get it to work
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    TrainBrakePipeLeakPSIorInHgpS = 0.0f; // Vacuum brakes
                }
                else
                {
                    TrainBrakePipeLeakPSIorInHgpS = 0.0f; // Air brakes
                }
            }

            base.Initialize();
            if (DynamicBrakeBlendingEnabled) airPipeSystem = BrakeSystem as AirSinglePipe;

            DrvWheelWeightKg = InitialDrvWheelWeightKg;
        }

        //================================================================================================//
        /// <summary>
        /// Set starting conditions  when initial speed > 0 
        /// </summary>
        /// 

        public override void InitializeMoving()
        {
            base.InitializeMoving();
            LocomotiveAxle.Reset(Simulator.GameTime, SpeedMpS);
            LocomotiveAxle.AxleSpeedMpS = SpeedMpS;
            LocomotiveAxle.AdhesionConditions = (float)(Simulator.Settings.AdhesionFactor) * 0.01f;
            AdhesionFilter.Reset(0.5f);
            AverageForceN = MaxForceN * Train.MUThrottlePercent / 100;
            float maxPowerW = MaxPowerW * Train.MUThrottlePercent * Train.MUThrottlePercent / 10000;
            if (AverageForceN * SpeedMpS > maxPowerW) AverageForceN = maxPowerW / SpeedMpS;
            LocomotiveAxle.FilterMovingAverage.Initialize(AverageForceN);
            if (Train.IsActualPlayerTrain)
            {
                TrainBrakeController.InitializeMoving();
                BrakeSystem.LocoInitializeMoving();
            }
        }

        //================================================================================================//
        /// <summary>
        /// Correct braking parameters if needed or required 
        /// </summary>
        /// 
        protected void CorrectBrakingParams()
        {
            if (Simulator.Settings.CorrectQuestionableBrakingParams)
            {
                if (!(BrakeSystem is EPBrakeSystem) && !(BrakeSystem is VacuumSinglePipe) && !(BrakeSystem is AirTwinPipe))
                {
                    if (CompressorRestartPressurePSI - TrainBrakeController.MaxPressurePSI < DefaultCompressorRestartToMaxSysPressureDiff - 10)
                    {
                        CompressorRestartPressurePSI = Math.Max(CompressorRestartPressurePSI, Math.Min(TrainBrakeController.MaxPressurePSI + DefaultCompressorRestartToMaxSysPressureDiff, DefaultMaxCompressorRestartPressure));
                        MainResPressurePSI = MaxMainResPressurePSI = Math.Max(MaxMainResPressurePSI, Math.Min(CompressorRestartPressurePSI + DefaultMaxMainResToCompressorRestartPressureDiff, DefaultMaxMainResPressure));

                    }
                    if (MainResVolumeM3 < 0.3f && MassKG > 20000) MainResVolumeM3 = DefaultMainResVolume;

                    // correct questionable MaxCylPressurePSI
                    BrakeSystem.CorrectMaxCylPressurePSI(this);
                }
                if (MainResChargingRatePSIpS <= 0)
                {
                    MainResChargingRatePSIpS = Math.Max(0.5f, (CompressorChargingRateM3pS * Bar.ToPSI(1)) / MainResVolumeM3);
                }
            }
            else if (MainResChargingRatePSIpS <= 0) MainResChargingRatePSIpS = 0.4f;

            // Corrections for dynamic braking parameters

            if (this is MSTSElectricLocomotive && DynamicBrakeDelayS > 4) DynamicBrakeDelayS = 2; // Electric locomotives have short engaging delays
            if (DynamicBrakeSpeed2MpS > 0 && DynamicBrakeSpeed3MpS > 0 && DynamicBrakeSpeed2MpS > DynamicBrakeSpeed3MpS)
            {
                // also exchanging DynamicBrakesMaximumEffectiveSpeed with DynamicBrakesFadingSpeed is a frequent error that upsets operation of
                // dynamic brakes
                var temp = DynamicBrakeSpeed2MpS;
                DynamicBrakeSpeed2MpS = DynamicBrakeSpeed3MpS;
                DynamicBrakeSpeed3MpS = temp;
            }
            if (Simulator.Settings.CorrectQuestionableBrakingParams)
            {
                if (MaxDynamicBrakeForceN > 0 && MaxContinuousForceN > 0 &&
                (MaxDynamicBrakeForceN / MaxContinuousForceN < 0.3f && MaxDynamicBrakeForceN == 20000))
                    MaxDynamicBrakeForceN = Math.Min (MaxContinuousForceN * 0.5f, 150000); // 20000 is suggested as standard value in the MSTS documentation, but in general it is a too low value
            }
        }

        /// <summary>
        /// Dynamic brake blending 
        /// </summary>
        public void DynamicBrakeBlending(float elapsedClockSeconds)
        {
            if (airPipeSystem != null && ((airPipeSystem is EPBrakeSystem && Train.BrakeLine4 > 0f) || airPipeSystem.BrakeLine1PressurePSI < TrainBrakeController.MaxPressurePSI - 1f)
                && ThrottleController.CurrentValue == 0f && !(DynamicBrakeController != null && DynamicBrakeBlendingOverride && DynamicBrakeController.CurrentValue > 0f)
                /* && (!DynamicBrakeBlendingLeverOverride && DynamicBrakeController != null && DynamicBrakeIntervention < DynamicBrakeController.CurrentValue)*/)
            {
                float threshold = DynamicBrakeBlendingForceMatch ? 100f : 0.01f;
                float maxCylPressurePSI = airPipeSystem.GetMaxCylPressurePSI();
                float targetDynamicBrakePercent = airPipeSystem is EPBrakeSystem ? Train.BrakeLine4 : Math.Min(((TrainBrakeController.MaxPressurePSI - airPipeSystem.BrakeLine1PressurePSI) * airPipeSystem.GetAuxCylVolumeRatio()) / maxCylPressurePSI, 1f);
                //DynamicBrakeIntervention = Math.Min(((TrainBrakeController.CurrentValue - DynamicBrakeBlendingStart) / (DynamicBrakeBlendingStop - DynamicBrakeBlendingStart)), 1f);

                if (!DynamicBrakeBlended)
                {
                    DynamicBrakeBlended = true;
                    if (DynamicBrakeController != null)
                        DynamicBrakeIntervention = DynamicBrakeController.CurrentValue;
                    else
                        DynamicBrakeIntervention = 0;
                    DynamicBrakeCommandStartTime = Simulator.ClockTime;
                }
                if (DynamicBrake)
                {
                    float diff = DynamicBrakeBlendingForceMatch ? targetDynamicBrakePercent * MaxBrakeForceN - DynamicBrakeForceN : targetDynamicBrakePercent - DynamicBrakeIntervention;
                    if (diff > threshold && DynamicBrakeIntervention <= 1)
                        DynamicBrakeIntervention = Math.Min( DynamicBrakeIntervention + elapsedClockSeconds * (airPipeSystem.GetMaxApplicationRatePSIpS() / maxCylPressurePSI), 1.0f);
                    else if (diff < -threshold)
                        DynamicBrakeIntervention -= elapsedClockSeconds * (airPipeSystem.GetMaxReleaseRatePSIpS() / maxCylPressurePSI);
                }
                if (DynamicBrakeController != null)
                    DynamicBrakeIntervention = Math.Max(DynamicBrakeIntervention, DynamicBrakeController.CurrentValue);
            }
            else if (DynamicBrakeBlended)
            {
                DynamicBrakeIntervention = -1;
                DynamicBrakeBlended = false;
            }
        }

        /// <summary>
        /// This function updates periodically the states and physical variables of the locomotive's subsystems.
        /// </summary>
        public override void Update(float elapsedClockSeconds)
        {
            TrainControlSystem.Update();

            UpdatePowerSupply(elapsedClockSeconds);

            UpdateControllers(elapsedClockSeconds);

            // Train Heading - only check the lead locomotive otherwise flipped locomotives further in consist will overwrite the train direction
            if (IsLeadLocomotive())
            {
                var heading = (float)Math.Atan2(WorldPosition.XNAMatrix.M13, WorldPosition.XNAMatrix.M11);
                Train.PhysicsTrainLocoDirectionDeg = MathHelper.ToDegrees((float)heading);

                if (Flipped)
                {
                    Train.PhysicsTrainLocoDirectionDeg += 180.0f; // Reverse direction of train
                    if (Train.PhysicsTrainLocoDirectionDeg > 360) // If this results in an angle greater then 360, then convert it back to an angle between 0 & 360.
                    {
                        Train.PhysicsTrainLocoDirectionDeg -= 360;
                    }
                }
            }
 
            // TODO  this is a wild simplification for electric and diesel electric
                        float t = ThrottlePercent / 100f;

            if (!AdvancedAdhesionModel)  // Advanced adhesion model turned off.
               AbsWheelSpeedMpS = AbsSpeedMpS;

            UpdateMotiveForce(elapsedClockSeconds, t, AbsSpeedMpS, AbsWheelSpeedMpS);

            ApplyDirectionToMotiveForce();

            // Update dynamic brake force
            if (DynamicBrakePercent > 0 && DynamicBrakeForceCurves != null && AbsSpeedMpS > 0)
            {
                float f = DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, AbsSpeedMpS);
                if (f > 0 && PowerOn)
                {
                    DynamicBrakeForceN = f * (1 - PowerReduction);
                }
                else
                {
                    DynamicBrakeForceN = 0f;
                }
            }
            else
                DynamicBrakeForceN = 0; // Set dynamic brake force to zero if in Notch 0 position

            UpdateFrictionCoefficient(elapsedClockSeconds); // Find the current coefficient of friction depending upon the weather

            UpdateWaterTroughRefill(elapsedClockSeconds, AbsSpeedMpS); // Update refill from trough

            switch (this.Train.TrainType)
            {
                case Train.TRAINTYPE.AI:
                case Train.TRAINTYPE.AI_PLAYERHOSTING:
                    if (AcceptMUSignals)
                    {
                        if (!PowerOn)
                        {
                            Train.SignalEvent(PowerSupplyEvent.RaisePantograph, 1);

                            if (this is MSTSDieselLocomotive)
                            {
                                foreach (DieselEngine de in (this as MSTSDieselLocomotive).DieselEngines)
                                {
                                    if (de.EngineStatus != DieselEngine.Status.Running)
                                        de.Initialize(true);
                                }
                            }
                        }
                        if (this is MSTSDieselLocomotive)
                        {
                            foreach (DieselEngine de in (this as MSTSDieselLocomotive).DieselEngines)
                            {
                                 if (de.GearBox != null)
                                    de.GearBox.GearBoxOperation = GearBoxOperation.Automatic;
                            }
                        }
                    }



                    AntiSlip = true; // Always set AI trains to AntiSlip
                    SimpleAdhesion();                         //let's call the basic physics instead for now
                    if (Train.IsActualPlayerTrain) FilteredMotiveForceN = CurrentFilter.Filter(MotiveForceN, elapsedClockSeconds);
                    WheelSpeedMpS = Flipped ? -AbsSpeedMpS : AbsSpeedMpS;            //make the wheels go round
                    break;
                case Train.TRAINTYPE.STATIC:
                case Train.TRAINTYPE.INTENDED_PLAYER:
                    break;
                case Train.TRAINTYPE.PLAYER:
                case Train.TRAINTYPE.AI_PLAYERDRIVEN:
                case Train.TRAINTYPE.REMOTE:
                    // For notched throttle controls (e.g. Dash 9 found on Marias Pass) UpdateValue is always 0.0
                    if (ThrottleController.UpdateValue != 0.0)
                    {
                        Simulator.Confirmer.UpdateWithPerCent(
                            this is MSTSSteamLocomotive ? CabControl.Regulator : CabControl.Throttle,
                            ThrottleController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            ThrottleController.CurrentValue * 100);
                    }
                    if (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0 && DynamicBrake)
                    {
                        Simulator.Confirmer.UpdateWithPerCent(
                            CabControl.DynamicBrake,
                            DynamicBrakeController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            DynamicBrakeController.CurrentValue * 100);
                    }

                    if ((Simulator.UseAdvancedAdhesion) && (!Simulator.Paused)) 
                    {
                        AdvancedAdhesion(elapsedClockSeconds); // Use advanced adhesion model
                        AdvancedAdhesionModel = true;  // Set flag to advise advanced adhesion model is in use
                    }
                    else
                    {
                        SimpleAdhesion();  // Use simple adhesion model
                        AdvancedAdhesionModel = false; // Set flag to advise simple adhesion model is in use
                    }

                    UpdateTrackSander(elapsedClockSeconds);

                    if (this is MSTSDieselLocomotive || this is MSTSElectricLocomotive)  // Antislip and throttle down should only work on diesel or electric locomotives.
                    {

                        // If wheel slip waring activated, and antislip is set in ENG file then reduce throttle setting to a value below warning power
                        if (WheelSlipWarning && AntiSlip)
                        {
                            ThrottleController.SetValue(PreviousThrottleSetting);
                        }


                        PreviousThrottleSetting = (ThrottlePercent / 100.0f) - 0.005f;
                        PreviousThrottleSetting = MathHelper.Clamp(PreviousThrottleSetting, 0.0f, 1.0f); // Prevents parameter going outside of bounds 

                        // If wheels slip and WheelslipCausesThrottleDown is set in engine file reduce throttle to 0 setting
                        if (WheelslipCausesThrottleDown && WheelSlip)
                            ThrottleController.SetValue(0.0f);
                    }

                    //Force to display
                    FilteredMotiveForceN = CurrentFilter.Filter(MotiveForceN, elapsedClockSeconds);
                    break;
                default:
                    break;

            }

            // always set AntiSlip for AI trains
              if (Train.TrainType == Train.TRAINTYPE.AI || Train.TrainType == Train.TRAINTYPE.AI_PLAYERHOSTING)
                 {
                    AntiSlip = true;
                 }

            // If the train is vacuumed braked then no need to update the compressor, but udate the ejector instead
              if (BrakeSystem is VacuumSinglePipe)
                 {
                    
                    if (VacuumBrakeEQFitted) // Only update exhauster/main reservoir on locomotives fitted ith an EQ reservoir
                    {
                    UpdateVacuumExhauster(elapsedClockSeconds);
                    }
                    else
                    {
                        UpdateSteamEjector(elapsedClockSeconds);
                    }
                
                 }
                 else
                 {
                   UpdateCompressor(elapsedClockSeconds);
                 }

            UpdateHornAndBell(elapsedClockSeconds);

            UpdateSoundVariables(elapsedClockSeconds);

            PrevMotiveForceN = MotiveForceN;
            base.Update(elapsedClockSeconds);

#if DEBUG_ADHESION
            // Timer to determine travel time - resets when locomotive stops
            if (AbsSpeedMpS > 0)
            {
                DebugTimer += elapsedClockSeconds;  // Increment debug timer whilever train is moving
            }
            else
            {
                DebugTimer = 0.0f; // Reset timer if train is stopped
            }

            // Speed detector, set to print out an adhesion snapshot every 5mph increment
            if (AbsSpeedMpS > MpS.FromMpH(DebugSpeed))
            {
                if (!DebugSpeedReached)
                {
                    DebugSpeedReached = true;                    
                }
                else
                {
                    if (DebugSpeedReached)
                    {
                        DebugSpeed += DebugSpeedIncrement;
                    }
                    DebugSpeedReached = false;

                }

            }

            // Only prints out in speed increments of 5mph
            if (DebugSpeedReached)
            {
                
                Trace.TraceInformation("====================================== Debug Adhesion (MSTSLocomotive.cs) ===============================");
                Trace.TraceInformation("AntiSlip - {0} ABSWheelSpeed {1}", AntiSlip, AbsWheelSpeedMpS);
                Trace.TraceInformation("Advanced Adhesion Model - {0}", Simulator.UseAdvancedAdhesion);
                Trace.TraceInformation("Car Id: {0} Engine type: {1} Speed: {2} Gradient: {3} Time: {4}", CarID, EngineType, FormatStrings.FormatSpeedDisplay(AbsSpeedMpS, IsMetric), -CurrentElevationPercent, DebugTimer);
                Trace.TraceInformation("Rail TE: {0} DBTE: {1}", FormatStrings.FormatForce(MotiveForceN, IsMetric), FormatStrings.FormatForce(CouplerForceU, IsMetric));

                Trace.TraceInformation("Axle - Drive Force: {0} Axle Force: {1} Wheelspeed: {2}", FormatStrings.FormatForce(LocomotiveAxle.DriveForceN, IsMetric), FormatStrings.FormatForce(LocomotiveAxle.AxleForceN, IsMetric), FormatStrings.FormatSpeedDisplay(WheelSpeedMpS, IsMetric));
                Trace.TraceInformation("Axle - Axle Inertia: {0} Wheel Radius: {1}", LocomotiveAxle.InertiaKgm2, DriverWheelRadiusM);

                Trace.TraceInformation("Adhesion - Curtius_A: {0} Curtius_B: {1} Curtius_C: {2} Curtius_D: {3}", Curtius_KnifflerA, Curtius_KnifflerB, Curtius_KnifflerC, AdhesionK);
                Trace.TraceInformation("Locomotive Weight: {0} Axle Weight: {1}", MassKG, DrvWheelWeightKg);

                Trace.TraceInformation("Axle Speed: {0} TrainSpeed: {1} Slip Speed: {2}", LocomotiveAxle.AxleSpeedMpS, LocomotiveAxle.TrainSpeedMpS, LocomotiveAxle.SlipSpeedMpS);

                Trace.TraceInformation("Adhesion Conditions: {0}", LocomotiveAxle.AdhesionConditions);

                Trace.TraceInformation("Fog - Min {0} fog {1}", Math.Min((Simulator.Weather.FogDistance * 2.75e-4f + 0.45f), 1.0f), Simulator.Weather.FogDistance);

                Trace.TraceInformation("Rain - Min {0} pric {1}", Math.Min((Simulator.Weather.PricipitationIntensityPPSPM2 * 0.0078f + 0.45f), 0.607f), Simulator.Weather.PricipitationIntensityPPSPM2);

            }
#endif

        } // End Method Update

        /// <summary>
        /// This function updates periodically the states and physical variables of the locomotive's power supply.
        /// </summary>
        protected virtual void UpdatePowerSupply(float elapsedClockSeconds)
        {
        }

        /// <summary>
        /// This function updates periodically the states and physical variables of the locomotive's controllers.
        /// </summary>
        protected virtual void UpdateControllers(float elapsedClockSeconds)
        {

            SteamHeatController.Update(elapsedClockSeconds);
            if (IsPlayerTrain)
            {
                if (SteamHeatController.UpdateValue > 0.0)
                    Simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeat, CabSetting.Increase, SteamHeatController.CurrentValue * 100);
                if (SteamHeatController.UpdateValue < 0.0)
                    Simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeat, CabSetting.Decrease, SteamHeatController.CurrentValue * 100);
            }

            TrainBrakeController.Update(elapsedClockSeconds);
            if (TrainBrakeController.UpdateValue > 0.0)
            {
                Simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatus());
            }

            if (TrainBrakeController.UpdateValue < 0.0)
            {
                Simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatus());
            }

            if (EngineBrakeController != null)
            {
                EngineBrakeController.Update(elapsedClockSeconds);
                if (EngineBrakeController.UpdateValue > 0.0)
                {
                    Simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
                }
                if (EngineBrakeController.UpdateValue < 0.0)
                {
                    Simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Decrease, GetEngineBrakeStatus());
                }
            }

            DynamicBrakeBlending(elapsedClockSeconds);
            if (DynamicBrakeController != null && DynamicBrakeController.CommandStartTime > DynamicBrakeCommandStartTime) // use the latest command time
                DynamicBrakeCommandStartTime = DynamicBrakeController.CommandStartTime;

            if ((DynamicBrakeController != null || DynamicBrakeBlendingEnabled || DynamicBrakeAvailable) && (DynamicBrakePercent >= 0 || IsLeadLocomotive() && DynamicBrakeIntervention >= 0))
            {
                if (!DynamicBrake)
                {
                    if (DynamicBrakeCommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime /*|| (DynamicBrakeController != null && DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)*/)
                    {
                        DynamicBrake = true; // Engage
                        if (IsLeadLocomotive() && DynamicBrakeController != null)
                            Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                    }
                    else if (IsLeadLocomotive())
                        Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
                }
                else if (this.IsLeadLocomotive())
                {
                    if (DynamicBrakeController != null)
                    {
                        DynamicBrakeController.Update(elapsedClockSeconds);
                        DynamicBrakePercent = (DynamicBrakeIntervention < 0 ? DynamicBrakeController.CurrentValue : DynamicBrakeIntervention) * 100f;
                    }
                    else
                        DynamicBrakePercent = Math.Max(DynamicBrakeIntervention * 100f, 0f);

                    if (DynamicBrakeIntervention < 0 && PreviousDynamicBrakeIntervention >= 0 && DynamicBrakePercent == 0)
                        DynamicBrakePercent = -1;
                    PreviousDynamicBrakeIntervention = DynamicBrakeIntervention;
                }
                else if (DynamicBrakeController != null)
                    DynamicBrakeController.Update(elapsedClockSeconds);
            }
            else if ((DynamicBrakeController != null || DynamicBrakeBlendingEnabled || DynamicBrakeAvailable) && DynamicBrakePercent < 0 && (DynamicBrakeIntervention < 0 || !IsLeadLocomotive()) && DynamicBrake)
            {
                // <CScomment> accordingly to shown documentation dynamic brake delay is required only when engaging
                //           if (DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)
                //           {
                DynamicBrake = false; // Disengage
                DynamicBrakeForceN = 0f; // Reset dynamic brake force
                if (IsLeadLocomotive())
                    Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.Off);
                //           }
                //            else if (IsLeadLocomotive())
                //               Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
            }

            //Currently the ThrottlePercent is global to the entire train
            //So only the lead locomotive updates it, the others only updates the controller (actually useless)
            if (this.IsLeadLocomotive())
            {
                var throttleCurrentNotch = ThrottleController.CurrentNotch;
                ThrottleController.Update(elapsedClockSeconds);
                if (ThrottleController.CurrentNotch < throttleCurrentNotch && ThrottleController.ToZero)
                    SignalEvent(Event.ThrottleChange);
                ThrottlePercent = (ThrottleIntervention < 0 ? ThrottleController.CurrentValue : ThrottleIntervention) * 100.0f;
                ConfirmWheelslip(elapsedClockSeconds);
                LocalThrottlePercent = (ThrottleIntervention < 0 ? ThrottleController.CurrentValue : ThrottleIntervention) * 100.0f;
            }
            else
            {
                ThrottleController.Update(elapsedClockSeconds);
            }

#if INDIVIDUAL_CONTROL
            //this train is remote controlled, with mine as a helper, so I need to send the controlling information, but not the force.
            if (MultiPlayer.MPManager.IsMultiPlayer() && this.Train.TrainType == Train.TRAINTYPE.REMOTE && this == Program.Simulator.PlayerLocomotive)
            {
                //cannot control train brake as it is the remote's job to do so
                if ((EngineBrakeController != null && EngineBrakeController.UpdateValue != 0.0) || (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0) || ThrottleController.UpdateValue != 0.0)
                {
                    controlUpdated = true;
                }
                ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
                if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0)) DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
                return; //done, will go back and send the message to the remote train controller
            }

            if (MultiPlayer.MPManager.IsMultiPlayer() && this.notificationReceived == true)
            {
                ThrottlePercent = ThrottleController.CurrentValue * 100.0f;
                this.notificationReceived = false;
            }
#endif
        }

        /// <summary>
        /// This function updates periodically the locomotive's motive force.
        /// </summary>
        protected virtual void UpdateMotiveForce(float elapsedClockSeconds, float t, float AbsSpeedMpS, float AbsWheelSpeedMpS)
        {
            // Method to set force and power info
            // An alternative method in the steam locomotive will override this and input force and power info for it.
            if (PowerOn && Direction != Direction.N)
            {
                if (TractiveForceCurves == null)
                {
                    float maxForceN = MaxForceN * t * (1 - PowerReduction);
                    float maxPowerW = MaxPowerW * t * t * (1 - PowerReduction);

                    if (maxForceN * AbsWheelSpeedMpS > maxPowerW)
                        maxForceN = maxPowerW / AbsWheelSpeedMpS;
                    //if (AbsSpeedMpS > MaxSpeedMpS)
                    //    maxForceN = 0;
                    if (AbsSpeedMpS > MaxSpeedMpS - 0.05f)
                        maxForceN = 20 * (MaxSpeedMpS - AbsSpeedMpS) * maxForceN;
                    if (AbsSpeedMpS > (MaxSpeedMpS))
                        maxForceN = 0;
                    MotiveForceN = maxForceN;
                }
                else
                {
                    MotiveForceN = TractiveForceCurves.Get(t, AbsWheelSpeedMpS) * (1 - PowerReduction);
                    if (MotiveForceN < 0 && !TractiveForceCurves.AcceptsNegativeValues())
                        MotiveForceN = 0;
                }
                TractiveForceN = MotiveForceN;
            }
            else
                TractiveForceN = 0f;

            if (MaxForceN > 0 && MaxContinuousForceN > 0 && PowerReduction < 1)
            {
                MotiveForceN *= 1 - (MaxForceN - MaxContinuousForceN) / (MaxForceN * MaxContinuousForceN) * AverageForceN * (1 - PowerReduction);
                float w = (ContinuousForceTimeFactor - elapsedClockSeconds) / ContinuousForceTimeFactor;
                if (w < 0)
                    w = 0;
                AverageForceN = w * AverageForceN + (1 - w) * MotiveForceN;
            }
        }

        /// <summary>
        /// This function applies a sign to the motive force as a function of the direction of the train.
        /// </summary>
        protected virtual void ApplyDirectionToMotiveForce()
        {
            // Steam locomotives have their MotiveForceN already pre-inverted based on Direction
            if (!(this is MSTSSteamLocomotive))
            {
                if (Train.IsPlayerDriven)
                {
                    switch (Direction)
                    {
                        case Direction.Forward:
                            //MotiveForceN *= 1;     //Not necessary
                            break;
                        case Direction.Reverse:
                            MotiveForceN *= -1;
                            break;
                        case Direction.N:
                        default:
                            MotiveForceN *= 0;
                            break;
                    }
                }
                else // for AI locomotives
                {
                    switch (Direction)
                    {
                        case Direction.Reverse:
                            MotiveForceN *= -1;
                            break;
                        default:
                            break;
                    }
                }// end AI locomotive
            }
        }

        protected enum Wheelslip
        {
            None,
            Warning,
            Occurring
        };

        protected Wheelslip WheelslipState = Wheelslip.None;

        public void ConfirmWheelslip(float elapsedClockSeconds)
        {
            if (elapsedClockSeconds > 0 && Simulator.GameTime - LocomotiveAxle.ResetTime > 5)
            {
                if (AdvancedAdhesionModel)
                {
                    // Wheelslip
                    if (LocomotiveAxle.IsWheelSlip)
                    {
                        if (WheelslipState != Wheelslip.Occurring)
                        {
                            WheelslipState = Wheelslip.Occurring;
                            Simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                        }
                    }
                    else
                    {
                        if (LocomotiveAxle.IsWheelSlipWarning)
                        {
                            if (WheelslipState != Wheelslip.Warning)
                            {
                                WheelslipState = Wheelslip.Warning;
                                Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Warn1);
                            }
                        }
                        else
                        {
                            if (WheelslipState != Wheelslip.None)
                            {
                                WheelslipState = Wheelslip.None;
                                Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                            }
                        }
                    }
                }
                else
                {
                    if (WheelSlip && (WheelslipState != Wheelslip.Occurring))
                    {
                        WheelslipState = Wheelslip.Occurring;
                        Simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                    }
                    if ((!WheelSlip) && (WheelslipState != Wheelslip.None))
                    {
                        WheelslipState = Wheelslip.None;
                        Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                    }
                }
            }
        }

        /// <summary>
        /// This function updates periodically the state of the steam ejector on a vacuum braked system.
        /// </summary>
        protected virtual void UpdateSteamEjector(float elapsedClockSeconds)
        {
            if (TrainBrakeController.TrainBrakeControllerState == ControllerState.Release || TrainBrakeController.TrainBrakeControllerState == ControllerState.FullQuickRelease )
            {
                LargeSteamEjectorIsOn = true;  // If brake is set to a release controller, then turn ejector on
            }
            else
            {
                LargeSteamEjectorIsOn = false; // If brake is not set to a release controller, then turn ejector off
            }

            // If diesel or electric locomotive, assume vacuum pump (exhauster) is continually running.
            if (!(this is MSTSSteamLocomotive))
            {
                VacuumPumpOperating = true;
            }


        }

        /// <summary>
        /// This function updates periodically the state of the vacuum exhauster on a vacuum braked system with a EQ reservoir.
        /// Resevoir vacuum is maintained in "atmospheric pressure" and converted to vacuum
        /// Vacuum reservoir should normally be maintained at approx 26InHg (4.185 psi)
        /// </summary>
        protected virtual void UpdateVacuumExhauster(float elapsedClockSeconds)
        {
            if (VacuumMainResVacuumPSIAorInHg > VacuumBrakesExhausterRestartVacuumPSIAorInHg && AuxPowerOn && !VacuumExhausterIsOn)
                SignalEvent(Event.VacuumExhausterOn);
            else if ((VacuumMainResVacuumPSIAorInHg < VacuumBrakesMainResMaxVacuumPSIAorInHg || !AuxPowerOn) && VacuumExhausterIsOn)
                SignalEvent(Event.VacuumExhausterOff);

            if (VacuumExhausterIsOn)
                VacuumMainResVacuumPSIAorInHg -= elapsedClockSeconds * VacuumBrakesMainResChargingRatePSIAorInHgpS;
        }

        /// <summary>
        /// This function updates periodically the state of the compressor and charges the main reservoir if the compressor is active.
        /// </summary>
        protected virtual void UpdateCompressor(float elapsedClockSeconds)
        {
            if (MainResPressurePSI < CompressorRestartPressurePSI && AuxPowerOn && !CompressorIsOn)
                SignalEvent(Event.CompressorOn);
            else if ((MainResPressurePSI > MaxMainResPressurePSI || !AuxPowerOn) && CompressorIsOn)
                SignalEvent(Event.CompressorOff);

            if (CompressorIsOn)
                MainResPressurePSI += elapsedClockSeconds * MainResChargingRatePSIpS;
        }

        /// <summary>
        /// This function updates periodically the states of the horn/whistle and the bell of the locomotive.
        /// </summary>
        protected virtual void UpdateHornAndBell(float elapsedClockSeconds)
        {
            Horn = ManualHorn || TCSHorn;
            if (Horn && !PreviousHorn)
            {
                SignalEvent(Event.HornOn);
                if (MPManager.IsMultiPlayer()) MPManager.Notify((new MSGEvent(MPManager.GetUserName(), "HORN", 1)).ToString());
            }
            else if (!Horn && PreviousHorn)
            {
                SignalEvent(Event.HornOff);
                if (MPManager.IsMultiPlayer()) MPManager.Notify((new MSGEvent(MPManager.GetUserName(), "HORN", 0)).ToString());
            }

            if (ManualBell)
            {
                BellState = SoundState.Sound;
            }
            else if (DoesHornTriggerBell && Horn)
            {
                BellState = SoundState.ContinuousSound;
            }
            else if (!ManualBell && BellState == SoundState.Sound)
            {
                BellState = SoundState.Stopped;
            }

            Bell = BellState != SoundState.Stopped;
            if (Bell && !PreviousBell)
            {
                SignalEvent(Event.BellOn);
                if (Train.TrainType != Train.TRAINTYPE.REMOTE && MPManager.IsMultiPlayer()) MPManager.Notify((new MSGEvent(MPManager.GetUserName(), "BELL", 1)).ToString());
            }
            else if (!Bell && PreviousBell)
            {
                SignalEvent(Event.BellOff);
                if (Train.TrainType != Train.TRAINTYPE.REMOTE && MPManager.IsMultiPlayer()) MPManager.Notify((new MSGEvent(MPManager.GetUserName(), "BELL", 0)).ToString());
            }

            PreviousHorn = Horn;
            PreviousBell = Bell;
        }

        /// <summary>
        /// This function updates periodically the locomotive's sound variables.
        /// </summary>
        protected virtual void UpdateSoundVariables(float elapsedClockSeconds)
        {
        }

        /// <summary>
        /// Calls the Update method in the parent class MSTSWagon.
        /// </summary>
        /// <param name="elapsedClockSeconds"></param>
        protected void UpdateParent(float elapsedClockSeconds)
        {
            base.Update(elapsedClockSeconds);
        }

        /// <summary>
        /// Adjusts the MotiveForce to account for adhesion limits
        /// If UseAdvancedAdhesion is true, dynamic adhesion model is computed
        /// If UseAdvancedAdhesion is false, the basic force limits are calculated the same way MSTS calculates them, but
        /// the weather handleing is different and Curtius-Kniffler curves are considered as a static limit
        /// </summary>
        public void AdvancedAdhesion(float elapsedClockSeconds)
        {

            if (LocoNumDrvWheels <= 0)
            {
                WheelSpeedMpS = AbsSpeedMpS;
                return;
            }

            //Curtius-Kniffler computation for the basic model
    //        float max0 = 1.0f;  //Adhesion conditions [N]

            if (EngineType == EngineTypes.Steam && SteamEngineType != MSTSSteamLocomotive.SteamEngineTypes.Geared )
             {
                // Steam locomotive details updated in UpdateMotiveForce method, and inserted into adhesion module
                // ****************  NB WheelSpeed updated within Steam Locomotive module at the moment - to be fixed to prevent discrepancies ******************
            }
            
            else 
            {
               
                //Compute axle inertia from parameters if possible
                if (AxleInertiaKgm2 > 10000.0f) // if axleinertia value supplied in ENG file, then use in calculations
                {
                    LocomotiveAxle.InertiaKgm2 = AxleInertiaKgm2;
                }
                else // if no value in ENG file, calculate axleinertia value.
                {
                    if (WheelAxles.Count > 0 && DriverWheelRadiusM > 0)
                    {
                        float upperLimit = 2.0f * WheelAxles.Count * (15000.0f * DriverWheelRadiusM - 2900.0f);
                        upperLimit = upperLimit < 100.0f ? 100.0f : upperLimit;

                        float lowerLimit = WheelAxles.Count * (9000.0f * DriverWheelRadiusM - 1750.0f);
                        lowerLimit = lowerLimit < 100.0f ? 100.0f : lowerLimit;

                        LocomotiveAxle.InertiaKgm2 = (upperLimit - lowerLimit) / (5000000.0f) * MaxPowerW + lowerLimit;
                    }
                    else
                        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                }
                //Limit the inertia to 40000 kgm2
                LocomotiveAxle.InertiaKgm2 = LocomotiveAxle.InertiaKgm2 > 40000.0f ? 40000.0f : LocomotiveAxle.InertiaKgm2;

                LocomotiveAxle.AxleRevolutionsInt.MinStep = LocomotiveAxle.InertiaKgm2 / MaxPowerW / 5.0f;


                //Set axle model parameters

               //LocomotiveAxle.BrakeForceN = FrictionForceN;
              //  LocomotiveAxle.BrakeRetardForceN = BrakeForceN;
                LocomotiveAxle.BrakeRetardForceN = BrakeRetardForceN;
                LocomotiveAxle.AxleWeightN = 9.81f * DrvWheelWeightKg;   //will be computed each time considering the tilting
                LocomotiveAxle.DriveForceN = MotiveForceN;           //Developed force
                LocomotiveAxle.TrainSpeedMpS = SpeedMpS;            //Set the train speed of the axle model
                LocomotiveAxle.Update(elapsedClockSeconds);         //Main updater of the axle model
                MotiveForceN = LocomotiveAxle.AxleForceN;           //Get the Axle force and use it for the motion
                if (elapsedClockSeconds > 0)
                {
                    WheelSlip = LocomotiveAxle.IsWheelSlip;             //Get the wheelslip indicator
                    WheelSlipWarning = LocomotiveAxle.IsWheelSlipWarning;
                }
                WheelSpeedMpS = LocomotiveAxle.AxleSpeedMpS;
            }
        }

        public void SimpleAdhesion()
        {

            // Check if the following few lines are required???
            if (LocoNumDrvWheels <= 0)
            {
                WheelSpeedMpS = AbsSpeedMpS;
                return;
            }
            
            if (LocoNumDrvWheels <= 0)
                return;
            //float max0 = MassKG * 9.8f * Adhesion3 / NumWheelsAdhesionFactor;   //Not used

            //Curtius-Kniffler computation
            float uMax = 1.3f * (7.5f / (AbsSpeedMpS * 3.6f + 44.0f) + 0.161f); // Curtius - Kniffler equation
            float adhesionUtil = 0.95f;   //Adhesion utilization

            float max0 = MassKG * 9.81f * adhesionUtil * uMax;  //Ahesion limit in [N]
            float max1;

            if (Simulator.WeatherType == WeatherType.Rain || Simulator.WeatherType == WeatherType.Snow)
            {
                if (Train.SlipperySpotDistanceM < 0)
                {
                    Train.SlipperySpotLengthM = 10 + 40 * (float)Simulator.Random.NextDouble();
                    Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Simulator.Random.NextDouble();
                }
                if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                    max0 *= .8f;
                if (Simulator.WeatherType == WeatherType.Rain)
                    max0 *= .8f;
                else
                    max0 *= .7f;
            }
            //float max1 = (Sander ? .95f : Adhesion2) * max0;  //Not used this way
            max1 = MaxForceN;
            //add sander
            if (AbsSpeedMpS < SanderSpeedOfMpS && TrackSandBoxCapacityFt3 > 0.0 && MainResPressurePSI > 80.0)
            {
                if (SanderSpeedEffectUpToMpS > 0.0f)
                {
                    if ((Sander) && (AbsSpeedMpS < SanderSpeedEffectUpToMpS))
                    {
                        switch (Simulator.WeatherType)
                        {
                            case WeatherType.Clear: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.2f; break;
                            case WeatherType.Rain: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.8f; break;
                            case WeatherType.Snow: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 2.5f; break;
                        }
                    }
                }
                else
                    if (Sander)
                {
                    switch (Simulator.WeatherType)
                    {
                        case WeatherType.Clear: max0 *= 1.2f; break;
                        case WeatherType.Rain: max0 *= 1.8f; break;
                        case WeatherType.Snow: max0 *= 2.5f; break;
                    }
                }
            }

            max1 = max0;

            WheelSlip = false;

            if (MotiveForceN > max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = max1;
                else
                    MotiveForceN = Adhesion1 * max0;        //Lowers the adhesion limit to 20% of its full
            }
            else if (MotiveForceN < -max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = -max1;
                else
                    MotiveForceN = -Adhesion1 * max0;       //Lowers the adhesion limit to 20% of its full
            }
        }

        /// <summary>
        /// Refills the locomotive from a water trough
        /// </summary>
        public virtual void UpdateWaterTroughRefill(float elapsedClockSeconds, float absSpeedMpS)
        {
            // Check to see whether locomotive is to be refilled over water trough
            if (Simulator.PlayerLocomotive == this && IsWaterScoopDown)
            {


                var fraction = GetFilledFraction((uint)MSTSWagon.PickupType.FuelWater);

                if (!HasWaterScoop)
                {
                    if (!WaterScoopNotFittedFlag)
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("No water scoop on this loco"));
                        WaterScoopNotFittedFlag = true;
                    }
                    RefillingFromTrough = false;
                    return;
                }
                else if (ScoopIsBroken)
                {
                    Simulator.Confirmer.Message(ConfirmLevel.Error, Simulator.Catalog.GetString("Scoop is broken, can't refill"));
                    RefillingFromTrough = false;
                    return;
                }
                else if (IsOverJunction())
                {
                    if (!ScoopIsBroken) // Only display message first time scoop is broken
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.Error, Simulator.Catalog.GetString("Scoop is broken by junction track"));
                    }
                    ScoopIsBroken = true;
                    RefillingFromTrough = false;
                    return;
                }
                else if (!IsOverTrough())
                {
                    if (!WaterScoopOverTroughFlag)
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Scoop is not over trough, can't refill"));
                        WaterScoopOverTroughFlag = true;
                        MSTSWagon.RefillProcess.OkToRefill = false;
                        MSTSWagon.RefillProcess.ActivePickupObjectUID = 0;
                    }
                    RefillingFromTrough = false;
                    return;
                }
                else if (IsTenderRequired == 1 && Direction == Direction.Reverse) // Locomotives with tenders cannot go in reverse
                {
                    if (!WaterScoopDirectionFlag)
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetStringFmt("Refill: Loco must be moving forward."));
                        WaterScoopDirectionFlag = true;
                    }
                    RefillingFromTrough = false;
                    return;
                }
                else if (absSpeedMpS < WaterScoopMinSpeedMpS)
                {
                    if (!WaterScoopSlowSpeedFlag)
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetStringFmt("Refill: Loco speed must exceed {0} for water to enter tender.",
                                FormatStrings.FormatSpeedLimit(WaterScoopMinSpeedMpS, MilepostUnitsMetric)));
                        WaterScoopSlowSpeedFlag = true;
                        MSTSWagon.RefillProcess.OkToRefill = false;
                        MSTSWagon.RefillProcess.ActivePickupObjectUID = 0;
                    }
                    RefillingFromTrough = false;
                    return;
                }
                else if (fraction > 1.0)
                {
                    Simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetStringFmt("Refill: Water supply now replenished."));
                    return;
                }
                else
                {
                    MSTSWagon.RefillProcess.OkToRefill = true;
                    MSTSWagon.RefillProcess.ActivePickupObjectUID = -1;
                    RefillingFromTrough = true;
                    WaterScoopOverTroughFlag = false; // Reset flag so that message will come up again
                }

            }
            else if (HasWaterScoop && MSTSWagon.RefillProcess.OkToRefill == true && IsOverTrough())// water scoop has been raised, stop water filling
            {
                MSTSWagon.RefillProcess.OkToRefill = false;
                MSTSWagon.RefillProcess.ActivePickupObjectUID = 0;
                RefillingFromTrough = false;
                return;
            }


            // update water scoop
            // Water scoop fill charateristics can be found in - 
            // Calculate water velocity entering pipe: v = SQRT ( loco speed^2 - 2 * gravity * h)
            // Calculate the drag of the water scoop in the water: Drag Force = 0.5 * Drag Coeff * Fluid Density * Reference Area * Velocity

            if (RefillingFromTrough)
            {
                // Calculate water velocity
                const float Aconst = 2;
                const float Bconst = 2.15f;
                float Avalue = ((float)Math.Pow(MpS.ToMpH(absSpeedMpS), 2) * Bconst);
                float Bvalue = Aconst * GravitationalAccelerationFtpSpS * Me.ToFt(WaterScoopFillElevationM);

                if (Avalue > Bvalue)
                {
                    WaterScoopVelocityMpS = Me.FromFt((float)Math.Sqrt(Avalue - Bvalue));
                }
                else
                {
                    WaterScoopVelocityMpS = 0;
                }

                // calculate volume of water scooped per period
                const float CuFttoGalUK = 6.22884f; // imperial gallons of water in a cubic foot of water
                WaterScoopedQuantityLpS = L.FromGUK(Me2.ToFt2((WaterScoopDepthM * WaterScoopWidthM)) * Me.ToFt(WaterScoopVelocityMpS) * CuFttoGalUK);
                WaterScoopInputAmountL = WaterScoopedQuantityLpS * elapsedClockSeconds; // Calculate current input quantity

                // Max sure that water level can't exceed maximum tender water level. Assume that water will be vented out of tender if maximum value exceeded. 
                // If filling from water trough this will be done with force
                const float NominalExtraWaterVolumeFactor = 1.0001f;
                CombinedTenderWaterVolumeUKG += L.ToGUK(WaterScoopInputAmountL); // add the amouunt of water added by scoop
                WaterScoopTotalWaterL += WaterScoopInputAmountL;

                CombinedTenderWaterVolumeUKG = MathHelper.Clamp(CombinedTenderWaterVolumeUKG, 0.0f, MaxTotalCombinedWaterVolumeUKG * NominalExtraWaterVolumeFactor);

                // Calculate drag force
                float ScoopDragCoeff = 1.05f;
                float ScoopDragAreaM = WaterScoopDepthM * WaterScoopWidthM;
                float ScoopFluidDensityKgpM3 = 998.2f; // Fuild density of water @ 20c
                WaterScoopDragForceN = 0.5f * ScoopDragCoeff * ScoopFluidDensityKgpM3 * ScoopDragAreaM * absSpeedMpS * absSpeedMpS;

            }
            else // Ensure water scoop values are zero if not taking water.
            {
                WaterScoopDragForceN = 0f;
                WaterScoopedQuantityLpS = 0;
                WaterScoopInputAmountL = 0;
                WaterScoopVelocityMpS = 0;

                if (!IsOverTrough()) // Only reset once train moves off the trough
                {
                    WaterScoopTotalWaterL = 0.0f; // Reset amount of water picked up by water sccop.
                }
            }


        }

        #region Calculate Friction Coefficient
        /// <summary>
        /// Calculates the current coefficient of friction based upon the current weather 
        /// The calculation of Coefficient of Friction appears to provide a wide range of 
        /// variations depending upon a number of factors including the wheel and track 
        /// composition, and whether the track is dry, wet (or lubricated), icy, covered 
        /// in leaf litter, etc.
        /// For the purposes of simulating frcition the following values have been used. 
        /// Some reference documents have suggested that friction can vary between 0.07 
        /// for lubricated or icy track to 0.78 for dry track.
        /// The standard Cutius-Kniffler formula for dry rail is used as a base.
        /// Dry track = 0.33 
        /// 
        /// The following values have been used as an "appropriate common" standard  to vary the above value by (sourced from Principles and Applications of Tribology).
        /// Wet track (clean) = 0.18 <=> 0.2
        /// Wet track (sand) = 0.22 <=> 0.25
        /// Dew or fog = 0.09 <=> 0.15
        /// Sleet = 0.15
        /// Sleet (sand) = 0.2
        /// Snow track = 0.1 
        /// Snow track (sand) = 0.15
        /// 
        /// Note Heavy rain will actually wash track clean, and will give a higher value of adhesion then light drizzling rain
        /// </summary>
        public virtual void UpdateFrictionCoefficient(float elapsedClockSeconds)
        {
            float BaseuMax = (Curtius_KnifflerA / (MpS.ToKpH(AbsSpeedMpS) + Curtius_KnifflerB) + Curtius_KnifflerC); // Base Curtius - Kniffler equation - u = 0.33, all other values are scaled off this formula

            //Set the friction coeff due to weather
            if (Simulator.WeatherType == WeatherType.Rain || Simulator.WeatherType == WeatherType.Snow)
            {
                if (Train.SlipperySpotDistanceM < 0)
                {
                    Train.SlipperySpotLengthM = 10 + 40 * (float)Simulator.Random.NextDouble();
                    Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Simulator.Random.NextDouble();
                }
                if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                {
                    BaseFrictionCoefficientFactor = 0.8f;
                }
                if (Simulator.WeatherType == WeatherType.Rain) // Wet weather
                {
                    if (Simulator.Settings.AdhesionProportionalToWeather && AdvancedAdhesionModel && !Simulator.Paused)  // Adjust clear weather for precipitation presence - base friction value will be approximately between 0.15 and 0.2
                        // ie base value between 0.607 and 0.45 
                        // note lowest friction will be for drizzle rain; friction will increase for precipitation both higher and lower than drizzle rail
                    {
                       float pric = Simulator.Weather.PricipitationIntensityPPSPM2 * 1000;
                // precipitation will calculate a value between 0.15 (light rain) and 0.2 (heavy rain) - this will be a factor that is used to adjust the base value - assume linear value between upper and lower precipitation values
                        if (pric >= 0.5)
                            BaseFrictionCoefficientFactor = Math.Min((pric * 0.0078f + 0.45f), 0.607f);
                        else
                            BaseFrictionCoefficientFactor = 0.4539f + 1.0922f * (0.5f - pric);
                    }
                    else // if not proportional to precipitation use fixed friction value approximately equal to 0.2, thus factor will be 0.6 x friction coefficient of 0.33
                    {
                        BaseFrictionCoefficientFactor = 0.607f;
                    }
                }
                else     // Snow weather
                {
                    BaseFrictionCoefficientFactor = 0.4f;
                }
            }
            else // Default to Dry (Clear) weather
            {

                if (Simulator.Settings.AdhesionProportionalToWeather && AdvancedAdhesionModel && !Simulator.Paused)  // Adjust clear weather for fog presence
                {
                    float fog = Simulator.Weather.FogDistance;
                    if (fog > 2000)
                    {
                        BaseFrictionCoefficientFactor = 1.0f; // if fog is not too thick don't change the friction
                    }
                    else
                    {
                        BaseFrictionCoefficientFactor = Math.Min((fog * 2.75e-4f + 0.45f), 1.0f); // If fog is less then 2km then it will impact friction
                    }                                        
                }
                else // if not proportional to fog use fixed friction value approximately equal to 0.33, thus factor will be 1.0 x friction coefficient of 0.33
                {
                    BaseFrictionCoefficientFactor = 1.0f;
                }

            }

            Train.WagonCoefficientFriction = BaseuMax * BaseFrictionCoefficientFactor;  // Find friction coefficient factor for wagons
            WagonCoefficientFrictionHUD = Train.WagonCoefficientFriction; // Save value for HUD display

            if (EngineType == EngineTypes.Steam && SteamDrvWheelWeightLbs < 10000 && Simulator.WeatherType == WeatherType.Clear)
            {
                BaseFrictionCoefficientFactor *= 0.75f;  // Dry track - static friction for vehicles with wheel weights less then 10,000lbs - u = 0.25

            }

            if (WheelSlip && ThrottlePercent > 0.2f && !BrakeSkid)   // Test to see if loco wheel is slipping, then coeff of friction will be decreased below static value.
            {
                BaseFrictionCoefficientFactor = 0.15f;  // Descrease friction to take into account dynamic (kinetic) friction U = 0.0525
            }
            else if (WheelSlip && ThrottlePercent < 0.1f && BrakeSkid) // Test to see if loco wheel is skidding due to brake application
            {
                BaseFrictionCoefficientFactor = 0.15f;  // Descrease friction to take into account dynamic (kinetic) friction U = 0.0525
            }

            //add sander
            if (AbsSpeedMpS < SanderSpeedOfMpS && TrackSandBoxCapacityFt3 > 0.0 && MainResPressurePSI > 80.0 && (AbsSpeedMpS > 0))
            {
                if (SanderSpeedEffectUpToMpS > 0.0f)
                {
                    if ((Sander) && (AbsSpeedMpS < SanderSpeedEffectUpToMpS))
                    {
                        BaseFrictionCoefficientFactor *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.5f;
                    }
                }
                else
                {
                    if (Sander)  // If sander is on, and train speed is greater then zero, then put sand on the track
                    {
                        BaseFrictionCoefficientFactor *= 1.5f; // Sanding track adds approx 150% adhesion (best case)
                    }
                }
            }

            var AdhesionMultiplier = Simulator.Settings.AdhesionFactor / 100.0f; // Convert to a factor where 100% = no change to adhesion
            var AdhesionRandom = (float)((float)(Simulator.Settings.AdhesionFactorChange) * 0.01f * 2f * (Simulator.Random.NextDouble() - 0.5f));

            Train.LocomotiveCoefficientFriction = BaseuMax * BaseFrictionCoefficientFactor * AdhesionMultiplier;  // Find friction coefficient factor for locomotive
            Train.LocomotiveCoefficientFriction = MathHelper.Clamp(Train.LocomotiveCoefficientFriction, 0.05f, 0.8f); // Ensure friction coefficient never exceeds a "reasonable" value

            // Set adhesion conditions for diesel, electric or steam geared locomotives
            if (elapsedClockSeconds > 0)
            {
                LocomotiveAxle.AdhesionConditions = AdhesionMultiplier * AdhesionFilter.Filter(BaseFrictionCoefficientFactor + AdhesionRandom, elapsedClockSeconds);
                LocomotiveAxle.AdhesionConditions = MathHelper.Clamp(LocomotiveAxle.AdhesionConditions, 0.05f, 2.5f); // Avoids NaNs in axle speed computing
            }

           // Set adhesion conditions for other steam locomotives
            if (EngineType == EngineTypes.Steam && SteamEngineType != MSTSSteamLocomotive.SteamEngineTypes.Geared)  // ToDo explore adhesion factors
            {
                LocomotiveCoefficientFrictionHUD = Train.LocomotiveCoefficientFriction; // Set display value for HUD - steam
            }
            else
            {
                LocomotiveCoefficientFrictionHUD = BaseuMax * LocomotiveAxle.AdhesionConditions; // Set display value for HUD - diesel
            }

            
        }

        #endregion


        public void UpdateTrackSander(float elapsedClockSeconds)
        {
        // updates track sander in terms of sand usage and impact on air compressor
        // The following assumptions have been made:
        //

            if (Sander)  // If sander is on adjust parameters
            {
                if (TrackSandBoxCapacityFt3 > 0.0) // if sand still in sandbox then sanding is available
                {
                    // Calculate consumption of sand, and drop in sand box level
                    float ActualSandConsumptionFt3pS = pS.FrompH(TrackSanderSandConsumptionFt3pH) * elapsedClockSeconds;
                    TrackSandBoxCapacityFt3 -= ActualSandConsumptionFt3pS;
                    TrackSandBoxCapacityFt3 = MathHelper.Clamp(TrackSandBoxCapacityFt3, 0.0f, MaxTrackSandBoxCapacityFt3);
                    if (TrackSandBoxCapacityFt3 == 0.0)
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Sand supply has been exhausted"));
                    }
                }

          // Calculate air consumption and change in main air reservoir pressure
                float ActualAirConsumptionFt3pS = pS.FrompM(TrackSanderAirComsumptionFt3pM) * elapsedClockSeconds;
                float SanderPressureDiffPSI = ActualAirConsumptionFt3pS / Me3.ToFt3(MainResVolumeM3) ;
                MainResPressurePSI -= SanderPressureDiffPSI;
                MainResPressurePSI = MathHelper.Clamp(MainResPressurePSI, 0.001f, MaxMainResPressurePSI);
            }

        }

        public override bool GetSanderOn()
        {
            return Sander;
        }

        #region Reverser
        public void SetDirection(Direction direction)
        {
            if (Direction != direction && ThrottlePercent < 1)
            {
                Direction = direction;
                switch (direction)
                {
                    case Direction.Reverse: SignalEvent(Event.ReverserToForwardBackward); break;
                    case Direction.N: SignalEvent(Event.ReverserToNeutral); break;
                    case Direction.Forward: SignalEvent(Event.ReverserToForwardBackward); break;
                }
                // passes event also to other locomotives
                foreach (TrainCar car in Train.Cars)
                {
                    var loco = car as MSTSLocomotive;
                    if (loco != null && car != this && loco.AcceptMUSignals)
                        switch (direction)
                        {
                            case Direction.Reverse: loco.SignalEvent(Event.ReverserToForwardBackward); break;
                            case Direction.N: loco.SignalEvent(Event.ReverserToNeutral); break;
                            case Direction.Forward: loco.SignalEvent(Event.ReverserToForwardBackward); break;
                        }

                }
                SignalEvent(Event.ReverserChange);
                if (direction == Direction.Forward)
                    Train.MUReverserPercent = 100;
                else
                    Train.MUReverserPercent = -100;
            }

        }

        public virtual void StartReverseIncrease(float? target)
        {
            AlerterReset(TCSEvent.ReverserChanged);
            if (this.IsLeadLocomotive())
            {
                {
                    switch (Direction)
                    {
                        case Direction.Reverse: SetDirection(Direction.N); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Neutral); break;
                        case Direction.N: SetDirection(Direction.Forward); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.On); break;
                        case Direction.Forward: SetDirection(Direction.Forward); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.On); break;
                    }
                }
            }
        }

        public virtual void StartReverseDecrease(float? target)
        {
            AlerterReset(TCSEvent.ReverserChanged);
            if (this.IsLeadLocomotive())
            {
                {
                    switch (Direction)
                    {
                        case Direction.Reverse: SetDirection(Direction.Reverse); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Off); break;
                        case Direction.N: SetDirection(Direction.Reverse); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Off); break;
                        case Direction.Forward: SetDirection(Direction.N); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Neutral); break;
                    }
                }
            }
        }
        #endregion

        #region ThrottleController
        public void StartThrottleIncrease(float? target)
        {
            if (ThrottleController.CurrentValue >= ThrottleController.MaximumValue)
                return;

            if (target != null) ThrottleController.StartIncrease(target);
            else new NotchedThrottleCommand(Simulator.Log, true);

            SignalEvent(Event.ThrottleChange);
            AlerterReset(TCSEvent.ThrottleChanged);
            CommandStartTime = Simulator.ClockTime;
        }

        public void StartThrottleIncrease()
        {
            if (DynamicBrakePercent >= 0 || !(DynamicBrakePercent == -1 && !DynamicBrake || DynamicBrakePercent >= 0 && DynamicBrake))
            {
                if (!(CombinedControlType == CombinedControl.ThrottleDynamic
                    || CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0))
                {
                    Simulator.Confirmer.Warning(CabControl.Throttle, CabSetting.Warn1);
                    return;
                }
            }

            if (CombinedControlType == CombinedControl.ThrottleDynamic && DynamicBrake)
                StartDynamicBrakeDecrease(null);
            else if (CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0)
                StartTrainBrakeDecrease(null);
            else
                StartThrottleIncrease(ThrottleController.SmoothMax());
        }

        public void StopThrottleIncrease()
        {
            AlerterReset(TCSEvent.ThrottleChanged);
            ThrottleController.StopIncrease();

            if (CombinedControlType == CombinedControl.ThrottleDynamic)
                StopDynamicBrakeDecrease();
            else if (CombinedControlType == CombinedControl.ThrottleAir)
                StopTrainBrakeDecrease();
            else if (ThrottleController.SmoothMax() != null)
                new ContinuousThrottleCommand(Simulator.Log, true, ThrottleController.CurrentValue, CommandStartTime);
        }

        public void StartThrottleDecrease(float? target)
        {
            if (ThrottleController.CurrentValue <= ThrottleController.MinimumValue)
                return;

            if (target != null) ThrottleController.StartDecrease(target);
            else new NotchedThrottleCommand(Simulator.Log, false);

            SignalEvent(Event.ThrottleChange);
            AlerterReset(TCSEvent.ThrottleChanged);
            CommandStartTime = Simulator.ClockTime;
        }

        public void StartThrottleDecrease()
        {
            if (CombinedControlType == CombinedControl.ThrottleDynamic && ThrottleController.CurrentValue <= 0)
                StartDynamicBrakeIncrease(null);
            else if (CombinedControlType == CombinedControl.ThrottleAir && ThrottleController.CurrentValue <= 0)
                StartTrainBrakeIncrease(null);
            else
                StartThrottleDecrease(ThrottleController.SmoothMin());
        }

        public void StopThrottleDecrease()
        {
            AlerterReset(TCSEvent.ThrottleChanged);
            ThrottleController.StopDecrease();

            if (CombinedControlType == CombinedControl.ThrottleDynamic)
                StopDynamicBrakeIncrease();
            else if (CombinedControlType == CombinedControl.ThrottleAir)
                StopTrainBrakeIncrease();
            if (ThrottleController.SmoothMin() != null)
                new ContinuousThrottleCommand(Simulator.Log, false, ThrottleController.CurrentValue, CommandStartTime);
        }

        //Steam Heat Controller

        #region Steam heating controller

        public void StartSteamHeatIncrease(float? target)
        {
            SteamHeatController.CommandStartTime = Simulator.ClockTime;
            if (IsPlayerTrain)
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.SteamHeat, CabSetting.Increase, SteamHeatController.CurrentValue * 100);
            SteamHeatController.StartIncrease(target);
            SignalEvent(Event.SteamHeatChange);
        }

        public void StopSteamHeatIncrease()
        {
            SteamHeatController.StopIncrease();
            new ContinuousSteamHeatCommand(Simulator.Log, 1, true, SteamHeatController.CurrentValue, SteamHeatController.CommandStartTime);
        }

        public void StartSteamHeatDecrease(float? target)
        {
            if (IsPlayerTrain)
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.SteamHeat, CabSetting.Decrease, SteamHeatController.CurrentValue * 100);
            SteamHeatController.StartDecrease(target);
            SignalEvent(Event.SteamHeatChange);
        }

        public void StopSteamHeatDecrease()
        {
            SteamHeatController.StopDecrease();
            if (IsPlayerTrain)
                new ContinuousSteamHeatCommand(Simulator.Log, 1, false, SteamHeatController.CurrentValue, SteamHeatController.CommandStartTime);
        }

        public void SteamHeatChangeTo(bool increase, float? target)
        {
            if (increase)
            {
                if (target > SteamHeatController.CurrentValue)
                {
                    StartSteamHeatIncrease(target);
                }
            }
            else
            {
                if (target < SteamHeatController.CurrentValue)
                {
                    StartSteamHeatDecrease(target);
                }
            }
        }

        public void SetSteamHeatValue(float value)
        {
            var controller = SteamHeatController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new ContinuousSteamHeatCommand(Simulator.Log, 1, change > 0, controller.CurrentValue, Simulator.GameTime);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeat, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, controller.CurrentValue * 100);
        }

        public void ToggleWaterScoop()
        {
            if (Simulator.PlayerLocomotive == this)
            {
                WaterScoopDown = !WaterScoopDown;
                SignalEvent(Event.WaterScoopDown);
                if (WaterScoopDown)
                {
                    IsWaterScoopDown = true; // Set flag to potentially fill from water trough
                    SignalEvent(Event.WaterScoopDown);
                }
                else
                {
                    IsWaterScoopDown = false;
                    SignalEvent(Event.WaterScoopUp);
                    WaterScoopOverTroughFlag = false; // Reset flags so that message will come up again
                    WaterScoopNotFittedFlag = false;
                    WaterScoopSlowSpeedFlag = false;
                    WaterScoopDirectionFlag = false;
                }
                    Simulator.Confirmer.Confirm(CabControl.WaterScoop, WaterScoopDown? CabSetting.On : CabSetting.Off);
            }
        }

        #endregion

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        public void ThrottleChangeTo(bool increase, float? target)
        {
            if (increase)
            {
                if (target > ThrottleController.CurrentValue)
                {
                    StartThrottleIncrease(target);
                }
            }
            else
            {
                if (target < ThrottleController.CurrentValue)
                {
                    StartThrottleDecrease(target);
                }
            }
        }

        /// <summary>
        /// Used by commands to make a single adjustment.
        /// </summary>
        public void AdjustNotchedThrottle(bool increase)
        {
            if (increase)
            {
                ThrottleController.StartIncrease();
                ThrottleController.StopIncrease();
            }
            else
            {
                ThrottleController.StartDecrease();
                ThrottleController.StopDecrease();
            }
            Simulator.Confirmer.ConfirmWithPerCent(CabControl.Throttle, ThrottleController.CurrentValue * 100);
        }

        public void SetThrottleValue(float value)
        {
            var controller = ThrottleController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new ContinuousThrottleCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                SignalEvent(Event.ThrottleChange);
                AlerterReset(TCSEvent.ThrottleChanged);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.UpdateWithPerCent(
                    this is MSTSSteamLocomotive ? CabControl.Regulator : CabControl.Throttle,
                    oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease,
                    controller.CurrentValue * 100);
        }

        public void SetThrottlePercent(float percent)
        {
            ThrottleController.SetPercent(percent);
        }

        public void SetThrottlePercentWithSound(float percent)
        {
            var oldThrottlePercent = ThrottleController.CurrentValue * 100;
            SetThrottlePercent(percent);
            if (Math.Abs(oldThrottlePercent - ThrottleController.CurrentValue * 100) > 2)
                SignalEvent(Event.ThrottleChange);
        }

        public void ThrottleToZero()
        {
            if (CombinedControlType == CombinedControl.ThrottleDynamic && ThrottleController.CurrentValue <= 0)
                StartDynamicBrakeIncrease(null);
            else if (CombinedControlType == CombinedControl.ThrottleAir && ThrottleController.CurrentValue <= 0)
                StartTrainBrakeIncrease(null);
            else
                StartThrottleToZero(0.0f);

        }

        public void StartThrottleToZero(float? target)
        {
            if (ThrottleController.CurrentValue <= ThrottleController.MinimumValue)
                return;

            ThrottleController.StartDecrease(target, true);
            if (ThrottleController.NotchCount() <= 0) SignalEvent(Event.ThrottleChange);
            AlerterReset(TCSEvent.ThrottleChanged);
            CommandStartTime = Simulator.ClockTime;
        }

        #endregion

        #region CombinedHandle
        /// <summary>
        /// Determines which sub-control of combined handle is to be set when receiving a combined value.
        /// Combined value is in 0-1 range, where arrangement is [[1--throttle--0]split[0--dynamic|airbrake--1]].
        /// </summary>
        public void SetCombinedHandleValue(float value)
        {
            if (CombinedControlType == CombinedControl.ThrottleDynamic && DynamicBrake)
            {
                if (DynamicBrakeController.CurrentValue == 0 && value < CombinedControlSplitPosition)
                    DynamicBrakeChangeActiveState(false);
                else if (DynamicBrakePercent > -1)
                    SetDynamicBrakeValue((MathHelper.Clamp(value, CombinedControlSplitPosition, 1) - CombinedControlSplitPosition) / (1 - CombinedControlSplitPosition));
            }
            else if (CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0)
            {
                SetTrainBrakeValue((MathHelper.Clamp(value, CombinedControlSplitPosition, 1) - CombinedControlSplitPosition) / (1 - CombinedControlSplitPosition));
            }
            else
            {
                if (CombinedControlType == CombinedControl.ThrottleDynamic && ThrottleController.CurrentValue == 0 && value > CombinedControlSplitPosition)
                    DynamicBrakeChangeActiveState(true);
                else if (DynamicBrakePercent < 0)
                    SetThrottleValue(1 - MathHelper.Clamp(value, 0, CombinedControlSplitPosition) / CombinedControlSplitPosition);
            }
        }

        /// <summary>
        /// Determines which sub-control of combined handle is active (based on its type), 
        /// and returns the overall position considering the split position. 
        /// </summary>
        /// <param name="intermediateValue">Whather asking for intermediate (for mouse operation) or notched (for displaying) value.</param>
        /// <returns>Combined position into 0-1 range, where arrangement is [[1--throttle--0]split[0--dynamic|airbrake--1]]</returns>
        public float GetCombinedHandleValue(bool intermediateValue)
        {
            if (CombinedControlType == CombinedControl.ThrottleDynamic && DynamicBrake)
                return CombinedControlSplitPosition + (1 - CombinedControlSplitPosition) * (intermediateValue ? DynamicBrakeController.IntermediateValue : DynamicBrakeController.CurrentValue);
            else if (CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0)
                return CombinedControlSplitPosition + (1 - CombinedControlSplitPosition) * (intermediateValue ? TrainBrakeController.IntermediateValue : TrainBrakeController.CurrentValue);
            else
                return CombinedControlSplitPosition * (1 - (intermediateValue ? ThrottleController.IntermediateValue : ThrottleController.CurrentValue));
        }
        #endregion

        #region GearBoxController
        public virtual void ChangeGearUp()
        {
        }

        public virtual void StartGearBoxIncrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StartIncrease();
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Increase, GearBoxController.CurrentNotch);
                AlerterReset(TCSEvent.GearBoxChanged);
            }

            ChangeGearUp();
        }

        public virtual void StopGearBoxIncrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StopIncrease();
            }
        }

        public virtual void ChangeGearDown()
        {
        }

        public virtual void StartGearBoxDecrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StartDecrease();
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Decrease, GearBoxController.CurrentNotch);
                AlerterReset(TCSEvent.GearBoxChanged);
            }

            ChangeGearDown();
        }

        public virtual void StopGearBoxDecrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StopDecrease();
            }
        }

        public void SetGearBoxValue(float value)
        {
            var controller = GearBoxController;
            var oldValue = controller.CurrentValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                //new GarBoxCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                SignalEvent(change > 0 ? Event.GearUp : Event.GearDown);
                AlerterReset(TCSEvent.GearBoxChanged);
            }
            if (oldValue != controller.CurrentValue)
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Decrease, GearBoxController.CurrentNotch);
        }
        #endregion

        #region TrainBrakeController
        public void StartTrainBrakeIncrease(float? target)
        {
            if (CombinedControlType == CombinedControl.ThrottleAir)
                ThrottleController.SetValue(0);

            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StartIncrease(target);
            TrainBrakeController.CommandStartTime = Simulator.ClockTime;
            Simulator.Confirmer.Confirm(CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatus());
            SignalEvent(Event.TrainBrakeChange);
        }

        public void StopTrainBrakeIncrease()
        {
            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StopIncrease();
            new TrainBrakeCommand(Simulator.Log, true, TrainBrakeController.CurrentValue, TrainBrakeController.CommandStartTime);
        }

        public void StartTrainBrakeDecrease(float? target, bool toZero = false)
        {
            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StartDecrease(target, toZero);
            TrainBrakeController.CommandStartTime = Simulator.ClockTime;
            Simulator.Confirmer.Confirm(CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatus());
            SignalEvent(Event.TrainBrakeChange);
        }

        public void StopTrainBrakeDecrease()
        {
            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StopDecrease();
            new TrainBrakeCommand(Simulator.Log, false, TrainBrakeController.CurrentValue, TrainBrakeController.CommandStartTime);
        }

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        /// <param name="increase"></param>
        /// <param name="target"></param>
        public void TrainBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number?
            if (increase)
            {
                if (target > TrainBrakeController.CurrentValue)
                {
                    StartTrainBrakeIncrease(target);
                }
            }
            else
            {
                if (target < TrainBrakeController.CurrentValue)
                {
                    StartTrainBrakeDecrease(target);
                }
            }
        }

        //Debrief Eval
        public static int DbfEvalFullTrainBrakeUnder8kmh = 0;
        public bool ldbfevalfulltrainbrakeunder8kmh = false;

        public override string GetTrainBrakeStatus()
        {
            var train = Simulator.PlayerLocomotive.Train;//Debrief Eval
            string s = TrainBrakeController.GetStatus();
 

            if (s == "Emergency" && train.LeadLocomotive != null && !ldbfevalfulltrainbrakeunder8kmh && train.LeadLocomotive.IsPlayerTrain && Math.Abs(train.SpeedMpS) < 2.22222)
            {
                
                DbfEvalFullTrainBrakeUnder8kmh++;
                ldbfevalfulltrainbrakeunder8kmh = true;
                train.DbfEvalValueChanged = true;//Debrief eval
            }
            if (s != "Emergency" && ldbfevalfulltrainbrakeunder8kmh)
                ldbfevalfulltrainbrakeunder8kmh = false;

            TrainCar lastCar = Train.Cars[Train.Cars.Count - 1];
            if (lastCar == this)
                lastCar = Train.Cars[0];
            s += BrakeSystem.GetFullStatus(lastCar.BrakeSystem, BrakeSystemPressureUnits);
            return s;
        }

        public void SetTrainBrakeValue(float value)
        {
            var controller = TrainBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new TrainBrakeCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                SignalEvent(Event.TrainBrakeChange);
                AlerterReset(TCSEvent.TrainBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.Update(CabControl.TrainBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, GetTrainBrakeStatus());
        }

        public void SetTrainBrakePercent(float percent)
        {
            // Insure we have TrainBrakeController ; some vehicles do not
            // such as Hy-rail truck
            // if (HasTrainBrake)
            if (TrainBrakeController.IsValid())
                TrainBrakeController.SetPercent(percent);
        }
        #endregion

        #region EngineBrakeController
        public void StartEngineBrakeIncrease(float? target)
        {
            AlerterReset(TCSEvent.EngineBrakeChanged);
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StartIncrease(target);
            Simulator.Confirmer.Confirm(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
            SignalEvent(Event.EngineBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopEngineBrakeIncrease()
        {
            if (EngineBrakeController == null)
                return;

            AlerterReset(TCSEvent.EngineBrakeChanged);
            EngineBrakeController.StopIncrease();
            new EngineBrakeCommand(Simulator.Log, true, EngineBrakeController.CurrentValue, EngineBrakeController.CommandStartTime);
        }

        public void StartEngineBrakeDecrease(float? target)
        {
            if (EngineBrakeController == null)
                return;

            AlerterReset(TCSEvent.EngineBrakeChanged);
            EngineBrakeController.StartDecrease(target);
            EngineBrakeController.CommandStartTime = Simulator.ClockTime; // Remember when the command was issued
            Simulator.Confirmer.Confirm(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
            SignalEvent(Event.EngineBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopEngineBrakeDecrease()
        {
            if (EngineBrakeController == null)
                return;

            AlerterReset(TCSEvent.EngineBrakeChanged);
            EngineBrakeController.StopDecrease();
            new EngineBrakeCommand(Simulator.Log, false, EngineBrakeController.CurrentValue, EngineBrakeController.CommandStartTime);
        }

        public void EngineBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (increase)
            {
                if (target > EngineBrakeController.CurrentValue)
                {
                    StartEngineBrakeIncrease(target);
                }
            }
            else
            {
                if (target < EngineBrakeController.CurrentValue)
                {
                    StartEngineBrakeDecrease(target);
                }
            }
        }

        public void SetEngineBrakeValue(float value)
        {
            var controller = EngineBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new EngineBrakeCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                SignalEvent(Event.EngineBrakeChange);
                AlerterReset(TCSEvent.EngineBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.Update(CabControl.EngineBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, GetEngineBrakeStatus());
        }

        public void SetEngineBrakePercent(float percent)
        {
            if (EngineBrakeController == null)
                return;
            EngineBrakeController.SetPercent(percent);
        }

        public override string GetEngineBrakeStatus()
        {
            if (EngineBrakeController == null)
                return null;
            // If brake type is only a state, and no numerical fraction application is displayed in the HUD, then display Brake Cylinder (BC) pressure
                if (String.IsNullOrEmpty(EngineBrakeController.GetStateFractionScripted())) // Test to see if a brake state only is present without a fraction of application, if no fraction display BC pressure
            {
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    return string.Format("{0} BC {1}", EngineBrakeController.GetStatus(), FormatStrings.FormatPressure(Vac.FromPress(Train.HUDLocomotiveBrakeCylinderPSI), PressureUnit.InHg, PressureUnit.InHg, true));
                }
                else
                {
                    return string.Format("{0} BC {1} {2}", EngineBrakeController.GetStatus(), FormatStrings.FormatPressure(Train.HUDLocomotiveBrakeCylinderPSI, PressureUnit.PSI, MainPressureUnit, true), BailOff ? " BailOff" : "");
                }
                    
                // Fraction not found so display BC                
            }
            else
            {
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    return string.Format("{0}", EngineBrakeController.GetStatus());  // Fraction found so don't display BC
                }
                else
                {
                    return string.Format("{0}{1}", EngineBrakeController.GetStatus(), BailOff ? " BailOff" : "");  // Fraction found so don't display BC
                }
            }
        }
        #endregion

        #region DynamicBrakeController
        public void StartDynamicBrakeIncrease(float? target)
        {
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent < 0)
            {
                DynamicBrakeChangeActiveState(true);
            }
            else if (DynamicBrake)
            {
                SignalEvent(Event.DynamicBrakeChange);
                DynamicBrakeController.StartIncrease(target);
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeIncrease();
                    Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public void StopDynamicBrakeIncrease()
        {
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (CanUseDynamicBrake())
            {
                DynamicBrakeController.StopIncrease();
                new DynamicBrakeCommand(Simulator.Log, true, DynamicBrakeController.CurrentValue, DynamicBrakeController.CommandStartTime);
            }
        }

        public void StartDynamicBrakeDecrease(float? target)
        {
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent <= 0)
            {
                DynamicBrakeChangeActiveState(false);
            }
            else if (DynamicBrake)
            {
                SignalEvent(Event.DynamicBrakeChange);
                DynamicBrakeController.StartDecrease(target);
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeDecrease();
                    Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public void StopDynamicBrakeDecrease()
        {
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (CanUseDynamicBrake())
            {
                DynamicBrakeController.StopDecrease();
                new DynamicBrakeCommand(Simulator.Log, false, DynamicBrakeController.CurrentValue, DynamicBrakeController.CommandStartTime);
            }
        }

        public void DynamicBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (increase)
            {
                if (target > DynamicBrakeController.CurrentValue)
                {
                    StartDynamicBrakeIncrease(target);
                }
            }
            else
            {
                if (target < DynamicBrakeController.CurrentValue)
                {
                    StartDynamicBrakeDecrease(target);
                }
            }
        }

        public void SetDynamicBrakeValue(float value)
        {
            if (!DynamicBrake && ThrottleController.CurrentValue == 0 && value > 0.05f)
                DynamicBrakeChangeActiveState(true);
            if (DynamicBrake && DynamicBrakeController.CurrentValue == 0 && value < -0.05f)
            {
                DynamicBrakeChangeActiveState(false);
                return;
            }
            if (!DynamicBrake)
                return;

            var controller = DynamicBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new DynamicBrakeCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                SignalEvent(Event.DynamicBrakeChange);
                AlerterReset(TCSEvent.DynamicBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.UpdateWithPerCent(CabControl.DynamicBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, DynamicBrakeController.CurrentValue * 100);
        }

        public void SetDynamicBrakePercent(float percent)
        {
            if (!CanUseDynamicBrake())
                return;
            DynamicBrakeController.SetPercent(percent);
            DynamicBrakeChangeActiveState(percent >= 0);
        }

        public void SetDynamicBrakePercentWithSound(float percent)
        {
            if (!CanUseDynamicBrake())
                return;
            var oldDynamicBrakePercent = DynamicBrakeController.CurrentValue * 100;
            SetDynamicBrakePercent(percent);
            if (Math.Abs(oldDynamicBrakePercent - DynamicBrakeController.CurrentValue * 100) > 2)
                SignalEvent(Event.DynamicBrakeChange);
        }

        public void DynamicBrakeChangeActiveState(bool toState)
        {
            if (toState && !DynamicBrake && DynamicBrakePercent < 0)
            {
                DynamicBrakePercent = 0;
                DynamicBrakeController.CommandStartTime = Simulator.ClockTime;
                StopDynamicBrakeIncrease();
            }
            else if (!toState && DynamicBrake && DynamicBrakePercent > -1 && DynamicBrakeIntervention < 0)
            {
                SignalEvent(Event.DynamicBrakeOff);
                DynamicBrakePercent = -1;
                DynamicBrakeController.CommandStartTime = Simulator.ClockTime;
                StopDynamicBrakeIncrease();
            }
        }

        protected bool CanUseDynamicBrake()
        {
            return (DynamicBrakeController != null
                && ThrottlePercent == 0);
        }

        public override string GetDynamicBrakeStatus()
        {
            if (DynamicBrakeController == null)
                return null;
            if (DynamicBrakePercent < 0)
                return string.Empty;
            return string.Format("{0}", DynamicBrakeController.GetStatus());
        }
        #endregion

        public virtual void SetPower(bool ToState)
        {

        }

        internal void ToggleMUCommand(bool ToState)
        {
            AcceptMUSignals = ToState;
        }

        public void SetTrainHandbrake(bool apply)
        {
            if (apply)
            {
                Train.SetHandbrakePercent(100);
                Simulator.Confirmer.Confirm(CabControl.Handbrake, CabSetting.On);
            }
            else
            {
                Train.SetHandbrakePercent(0);
                Simulator.Confirmer.Confirm(CabControl.Handbrake, CabSetting.Off);
            }
        }

        public void SetTrainRetainers(bool apply)
        {
            Train.SetRetainers(apply);
            Simulator.Confirmer.ConfirmWithPerCent(CabControl.Retainers, CabSetting.Increase, Train.RetainerPercent, (int)CabSetting.Range1 + (int)Train.RetainerSetting);
        }

        public void BrakeHoseConnect(bool apply)
        {
            if (apply)
            {
                Train.ConnectBrakeHoses();
                Simulator.Confirmer.Confirm(CabControl.BrakeHose, CabSetting.On);
            }
            else
            {
                Train.DisconnectBrakes();
                Simulator.Confirmer.Confirm(CabControl.BrakeHose, CabSetting.Off);
            }
        }

        public void ToggleCabLight()
        {
            if (this is MSTSSteamLocomotive)
                return;

            CabLightOn = !CabLightOn;
            SignalEvent(Event.CabLightSwitchToggle);
            Simulator.Confirmer.Confirm(CabControl.CabLight, CabLightOn ? CabSetting.On : CabSetting.Off);
        }

        public void ToggleCabRadio( bool newState)
        {
            CabRadioOn = newState;
            if (!OnLineCabRadio)
            {
                if (CabRadioOn) SignalEvent(Event.CabRadioOn); // hook for sound trigger
                else SignalEvent(Event.CabRadioOff);
            }
            else if (OnLineCabRadioURL != "")
            { }
            if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CabRadio, CabRadioOn ? CabSetting.On : CabSetting.Off);
        }

        public void ToggleWipers(bool newState)
        {
            SignalEvent(newState ? Event.WiperOn : Event.WiperOff);
        }

        public void SetBailOff(bool bailOff)
        {
            BailOff = bailOff;
            Simulator.Confirmer.Confirm(CabControl.BailOff, bailOff ? CabSetting.On : CabSetting.Off);
        }

        public virtual void Refuel()
        {
            // Electric locos do nothing. Diesel and steam override this.
        }

        public void OdometerToggle()
        {
            OdometerVisible = !OdometerVisible;
        }

        /// <summary>
        /// Set odometer reference distance to actual travelled distance,
        /// and set measuring direction to the actual direction
        /// </summary>
        public void OdometerReset()
        {
            if (Train == null)
                return;

            if (OdometerCountingForwards != OdometerCountingUp ^ (Direction == Direction.Reverse))
            {
                OdometerCountingForwards = !OdometerCountingForwards;
            }

            if (Direction == Direction.Reverse)
            {
                if (OdometerCountingForwards)
                    OdometerResetPositionM = Train.DistanceTravelledM - Train.Length;
                else
                    OdometerResetPositionM = Train.DistanceTravelledM;
            }
            else
            {
                if (OdometerCountingForwards)
                    OdometerResetPositionM = Train.DistanceTravelledM;
                else
                    OdometerResetPositionM = Train.DistanceTravelledM + Train.Length;
            }

            Simulator.Confirmer.Confirm(CabControl.Odometer, CabSetting.On);
        }

        public void OdometerToggleDirection()
        {
            if (Train == null)
                return;

            OdometerCountingUp = !OdometerCountingUp;

            Simulator.Confirmer.Confirm(CabControl.Odometer, OdometerCountingUp ? CabSetting.Increase : CabSetting.Decrease);
        }

        public override bool GetCabFlipped()
        {
            return UsingRearCab;
        }

        public void SetEmergency(bool emergency)
        {
            if (this.Train != null && this.Train.TrainType == Train.TRAINTYPE.REMOTE) return; //not apply emergency for remote trains.
            TrainControlSystem.SetEmergency(emergency);
        }

        public void AlerterReset()
        {
            TrainControlSystem.HandleEvent(TCSEvent.AlerterReset);
        }

        public void AlerterReset(TCSEvent evt)
        {
            AlerterReset();
            TrainControlSystem.HandleEvent(evt);
        }

        public void AlerterPressed(bool pressed)
        {
            TrainControlSystem.AlerterPressed(pressed);
        }

        //put here because you can have diesel helpers and electric player locomotive
        public void ToggleHelpersEngine()
        {
            var onOffFound = false; //this avoids that locomotive engines toggle in opposite directions
            var powerOn = false;
            var helperLocos = 0;

            foreach (var car in Train.Cars)
            {
                var mstsDieselLocomotive = car as MSTSDieselLocomotive;
                if (mstsDieselLocomotive != null && mstsDieselLocomotive.AcceptMUSignals)
                {
                    if (mstsDieselLocomotive.DieselEngines.Count > 0)
                    {
                        if ((car == Simulator.PlayerLocomotive))
                        {
                            if ((mstsDieselLocomotive.DieselEngines.Count > 1))
                            {
                                for (int i = 1; i < mstsDieselLocomotive.DieselEngines.Count; i++)
                                {
                                    if (!onOffFound)
                                    {
                                        onOffFound = true;
                                        if (mstsDieselLocomotive.DieselEngines[i].EngineStatus == DieselEngine.Status.Stopped)
                                        {
                                            mstsDieselLocomotive.DieselEngines[i].Start();
                                            powerOn = true;
                                        }
                                        if (mstsDieselLocomotive.DieselEngines[i].EngineStatus == DieselEngine.Status.Running)
                                        {
                                            mstsDieselLocomotive.DieselEngines[i].Stop();
                                        }
                                    }
                                    else
                                    {
                                        if (mstsDieselLocomotive.DieselEngines[i].EngineStatus == DieselEngine.Status.Stopped && powerOn)
                                        {
                                            mstsDieselLocomotive.DieselEngines[i].Start();
                                        }
                                        if (mstsDieselLocomotive.DieselEngines[i].EngineStatus == DieselEngine.Status.Running && !powerOn)
                                        {
                                            mstsDieselLocomotive.DieselEngines[i].Stop();
                                        }
                                    }
                                }
                                if (mstsDieselLocomotive.DieselEngines[1].EngineStatus == DieselEngine.Status.Stopping)
                                    mstsDieselLocomotive.SignalEvent(Event.SecondEnginePowerOff);
                                else if (mstsDieselLocomotive.DieselEngines[1].EngineStatus == DieselEngine.Status.Starting)
                                    mstsDieselLocomotive.SignalEvent(Event.SecondEnginePowerOn);
                            }
                        }
                        else
                        {
                            foreach (DieselEngine de in mstsDieselLocomotive.DieselEngines)
                            {
                                if (!onOffFound)
                                {
                                    if (de.EngineStatus == DieselEngine.Status.Stopped)
                                    {
                                        de.Start();
                                        powerOn = true;
                                    }
                                    if (de.EngineStatus == DieselEngine.Status.Running)
                                    {
                                        de.Stop();
                                    }
                                }
                                else
                                {

                                    if (de.EngineStatus == DieselEngine.Status.Stopped && powerOn)
                                    {
                                        de.Start();
                                    }
                                    if (de.EngineStatus == DieselEngine.Status.Running && !powerOn)
                                    {
                                        de.Stop();
                                    }
                                }
                            }
                        }
                    }
                    //mstsDieselLocomotive.StartStopDiesel();

                    if ((car != Simulator.PlayerLocomotive) && (mstsDieselLocomotive.AcceptMUSignals))
                    {
                        if (mstsDieselLocomotive.DieselEngines[0].EngineStatus == DieselEngine.Status.Stopping)
                            mstsDieselLocomotive.SignalEvent(Event.EnginePowerOff);
                        else if (mstsDieselLocomotive.DieselEngines[0].EngineStatus == DieselEngine.Status.Starting)
                            mstsDieselLocomotive.SignalEvent(Event.EnginePowerOn);
                        if (mstsDieselLocomotive.DieselEngines.Count > 1)
                        {
                            if (mstsDieselLocomotive.DieselEngines[1].EngineStatus == DieselEngine.Status.Stopping)
                                mstsDieselLocomotive.SignalEvent(Event.SecondEnginePowerOff);
                            else if (mstsDieselLocomotive.DieselEngines[1].EngineStatus == DieselEngine.Status.Starting)
                                mstsDieselLocomotive.SignalEvent(Event.SecondEnginePowerOn);
                        }
                    }
                    helperLocos++;
                }
            }
            // One confirmation however many helper locomotives
            // <CJComment> Couldn't make one confirmation per loco work correctly :-( </CJComment>
            if (helperLocos > 0)
            {
                Simulator.Confirmer.Confirm(CabControl.HelperDiesel, powerOn ? CabSetting.On : CabSetting.Off);
            }

        }

        public override void SignalEvent(Event evt)
        {
            switch (evt)
            {
                case Event.VigilanceAlarmOn: { AlerterSnd = true; if (Simulator.Settings.Alerter) Simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.On); break; }
                case Event.VigilanceAlarmOff: { AlerterSnd = false; if (Simulator.Settings.Alerter) Simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.Off); break; }
                case Event.BellOn:
                case Event.BellOff:
                    if (this == Simulator.PlayerLocomotive && Simulator.Confirmer != null)
                        Simulator.Confirmer.Confirm(CabControl.Bell, Bell ? CabSetting.On : CabSetting.Off);
                    break;
                case Event.HornOn:
                case Event.HornOff:
                    if (this == Simulator.PlayerLocomotive && Simulator.Confirmer != null)
                        Simulator.Confirmer.Confirm(this is MSTSSteamLocomotive ? CabControl.Whistle : CabControl.Horn, Horn ? CabSetting.On : CabSetting.Off);
                    break;
                case Event.SanderOn: { Sander = true; if (this.IsLeadLocomotive() && this == Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Sander, CabSetting.On); break; }
                case Event.SanderOff: { Sander = false; if (this.IsLeadLocomotive() && this == Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Sander, CabSetting.Off); break; }
                case Event.WiperOn: { Wiper = true; if (this == Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Wipers, CabSetting.On); break; }
                case Event.WiperOff: { Wiper = false; if (this == Simulator.PlayerLocomotive) Simulator.Confirmer.Confirm(CabControl.Wipers, CabSetting.Off); break; }

                // <CJComment> The "H" key doesn't call these SignalEvents yet. </CJComment>
                case Event._HeadlightOff: { Headlight = 0; break; }
                case Event._HeadlightDim: { Headlight = 1; break; }
                case Event._HeadlightOn: { Headlight = 2; break; }

                case Event.CompressorOn: { CompressorIsOn = true; break; }
                case Event.CompressorOff: { CompressorIsOn = false; break; }
                case Event.VacuumExhausterOn: { VacuumExhausterIsOn = true; break; }
                case Event.VacuumExhausterOff : { VacuumExhausterIsOn = false; break; }

                case Event._ResetWheelSlip: { LocomotiveAxle.Reset(Simulator.GameTime, SpeedMpS); ThrottleController.SetValue(0.0f); break; }
                case Event.TrainBrakePressureDecrease:
                case Event.TrainBrakePressureIncrease:
                    {
                        if (Train.TrainType == Train.TRAINTYPE.AI || Train.TrainType == Train.TRAINTYPE.AI_PLAYERHOSTING)
                        {
                            if (Train.Simulator.GameTime - LastBrakeSoundTime < 15) // don't repeat sound too often for AI trains (which frequently set brakes on and off)
                            {
                                return;
                            }
                            LastBrakeSoundTime = Train.Simulator.GameTime;
                        }
                        break;
                    }
            }

            base.SignalEvent(evt);
        }

        //used by remote train locomotives
 /*       public virtual void RemoteUpdate()
        {
        }*/

        public virtual float GetDataOf(CabViewControl cvc)
        {
            float data = 0;
            switch (cvc.ControlType)
            {
                case CABViewControlTypes.SPEEDOMETER:
                    {
                        //data = SpeedMpS;
                        if (AdvancedAdhesionModel)
                            data = WheelSpeedMpS;
                        else
                            data = SpeedMpS;

                        if (cvc.Units == CABViewControlUnits.KM_PER_HOUR)
                            data *= 3.6f;
                        else // MPH
                            data *= 2.2369f;
                        data = Math.Abs(data);
                        break;
                    }
                case CABViewControlTypes.SPEED_PROJECTED:
                    {
                        if (Train != null)
                            data = Train.ProjectedSpeedMpS;
                        else data = 0;
                        if (cvc.Units == CABViewControlUnits.KM_PER_HOUR)
                            data *= 3.6f;
                        else // MPH
                            data *= 2.2369f;
                        data = Math.Abs(data);
                        break;
                    }
                case CABViewControlTypes.ACCELEROMETER:
                    {
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.METRES_SEC_SEC:
                                data = this.AccelerationMpSS;
                                break;

                            case CABViewControlUnits.METRES_SEC_HOUR:
                                data = this.AccelerationMpSS * 3600.0f;
                                break;

                            case CABViewControlUnits.KM_HOUR_SEC:
                                data = this.AccelerationMpSS * 3.6f;
                                break;

                            case CABViewControlUnits.KM_HOUR_HOUR:
                                data = this.AccelerationMpSS * 3.6f * 3600.0f;
                                break;

                            case CABViewControlUnits.MILES_HOUR_MIN:
                                data = this.AccelerationMpSS * 2.236936f * 60.0f;
                                break;

                            case CABViewControlUnits.MILES_HOUR_HOUR:
                                // 
                                data = this.AccelerationMpSS * 2.236936f * 3600.0f;
                                break;

                            default:
                                data = this.AccelerationMpSS;
                                break;

                        }
                        break;
                    }

                 case CABViewControlTypes.ORTS_WATER_SCOOP:
                    data = WaterScoopDown ? 1 : 0;
                    break;

                case CABViewControlTypes.STEAM_HEAT:
                    data = SteamHeatController.CurrentValue;
                    break;
                
                case CABViewControlTypes.AMMETER: // Current not modelled yet to ammeter shows tractive effort until then.
                case CABViewControlTypes.AMMETER_ABS:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        if (MaxCurrentA == 0)
                            MaxCurrentA = (float)cvc.MaxValue;
                        if (LocomotiveAxle != null)
                        {
                            data = 0.0f;
                            if (ThrottlePercent > 0)
                            {
                                //float rangeFactor = direction == 0 ? (float)cvc.MaxValue : (float)cvc.MinValue;
                                float rangeFactor = direction == 0 ? MaxCurrentA : (float)cvc.MinValue;
                                if (FilteredMotiveForceN != 0)
                                    data = this.FilteredMotiveForceN / MaxForceN * rangeFactor;
                                else
                                    data = this.LocomotiveAxle.AxleForceN / MaxForceN * rangeFactor;
                                data = Math.Abs(data);
                            }
                            if (DynamicBrakePercent > 0 && MaxDynamicBrakeForceN > 0)
                            {
                                float rangeFactor;
                                if (cvc.ControlType == CABViewControlTypes.AMMETER_ABS)
                                {
                                    if (DynamicBrakeMaxCurrentA == 0)
                                        rangeFactor = direction == 0 ? (float)cvc.MaxValue : (float)cvc.MinValue;
                                    else
                                        rangeFactor = direction == 0 ? DynamicBrakeMaxCurrentA : (float)cvc.MinValue;
                                }
                                else
                                {
                                    if (DynamicBrakeMaxCurrentA == 0)
                                        rangeFactor = direction == 0 ? (float)cvc.MinValue : (float)cvc.MaxValue;
                                    else
                                        rangeFactor = direction == 0 ? -DynamicBrakeMaxCurrentA : (float)cvc.MaxValue;
                                }
                                data = DynamicBrakeForceN / MaxDynamicBrakeForceN * rangeFactor;
                            }
                            if (direction == 1)
                                data = -data;
                            if (cvc.ControlType == CABViewControlTypes.AMMETER_ABS) data = Math.Abs(data);
                            break;
                        }
                        data = this.MotiveForceN / MaxForceN * MaxCurrentA;
                        if (cvc.ControlType == CABViewControlTypes.AMMETER_ABS) data = Math.Abs(data);
                        break;
                    }
                case CABViewControlTypes.LOAD_METER:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        if (MaxCurrentA == 0)
                            MaxCurrentA = (float)cvc.MaxValue;
                        if (DynamicBrakeMaxCurrentA == 0)
                            DynamicBrakeMaxCurrentA = (float)cvc.MinValue;
                        data = 0.0f;
                        if (ThrottlePercent > 0)
                        {
                            if (FilteredMotiveForceN != 0)
                                data = this.FilteredMotiveForceN / MaxForceN * MaxCurrentA;
                            else
                                data = this.LocomotiveAxle.AxleForceN / MaxForceN * MaxCurrentA;
                            data = Math.Abs(data);
                        }
                        if (DynamicBrakePercent > 0 && MaxDynamicBrakeForceN > 0)
                        {
                            data = DynamicBrakeForceN / MaxDynamicBrakeForceN * DynamicBrakeMaxCurrentA;
                            data = -Math.Abs(data); // Ensure that dynamic force is seen as a "-ve force", changes colour on the load meter
                        }
                        if (direction == 1)
                            data = -data;
                        break;
                    }
                case CABViewControlTypes.TRACTION_BRAKING:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        data = 0.0f;
                        if (FilteredMotiveForceN != 0)
                            data = this.FilteredMotiveForceN;
                        else
                            data = this.LocomotiveAxle.AxleForceN;
                        if (DynamicBrakePercent > 0)
                        {
                            data = DynamicBrakeForceN;
                        }
                        data = Math.Abs(data);
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.AMPS:
                                if (MaxCurrentA == 0)
                                    MaxCurrentA = (float)cvc.MaxValue;
                                if (DynamicBrakeMaxCurrentA == 0)
                                    DynamicBrakeMaxCurrentA = (float)cvc.MinValue;
                                if (ThrottlePercent > 0)
                                {
                                    data = (data / MaxForceN) * MaxCurrentA;
                                 }
                                if (DynamicBrakePercent > 0)
                                {
                                    data = (DynamicBrakeForceN / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                                }
                                data = Math.Abs(data);
                                break;
                    
                            case CABViewControlUnits.NEWTONS:
                                break;
                    
                            case CABViewControlUnits.KILO_NEWTONS:
                                data = data / 1000.0f;
                                break;
                    
                            case CABViewControlUnits.KILO_LBS:
                                data = data / 4448.22162f;
                                break;
                        }                   
                        if (direction == 1 && !(cvc is CVCGauge))
                            data = -data;
                        break;
                    }
                case CABViewControlTypes.DYNAMIC_BRAKE_FORCE:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        data = 0.0f;
                        data = DynamicBrakeForceN;
                        if (data > 0 && SpeedMpS > 0 || data < 0 && SpeedMpS < 0)
                        {
                            data = 0;
                            break;
                        }
                        data = Math.Abs(data);
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.AMPS:
                                if (MaxCurrentA == 0)
                                    MaxCurrentA = (float)cvc.MaxValue;
                                if (DynamicBrakeMaxCurrentA == 0)
                                    DynamicBrakeMaxCurrentA = (float)cvc.MinValue;
                                if (ThrottlePercent > 0)
                                {
                                    data = 0;
                                }
                                if (DynamicBrakePercent > 0)
                                {
                                    data = (DynamicBrakeForceN / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                                }
                                data = Math.Abs(data);
                                break;

                            case CABViewControlUnits.NEWTONS:
                                break;

                            case CABViewControlUnits.KILO_NEWTONS:
                                data = data / 1000.0f;
                                break;

                            case CABViewControlUnits.KILO_LBS:
                                data = data / 4448.22162f;
                                break;
                        }
                        if (direction == 1 && !(cvc is CVCGauge))
                            data = -data;
                        break;
                    }
                case CABViewControlTypes.MAIN_RES:
                    {
                        data = ConvertFromPSI(cvc, MainResPressurePSI);
                        break;
                    }
                case CABViewControlTypes.BRAKE_PIPE:
                    {
                        data = ConvertFromPSI(cvc, this.BrakeSystem.BrakeLine1PressurePSI);
                        break;
                    }
                case CABViewControlTypes.EQ_RES:
                    {
                        data = ConvertFromPSI(cvc, this.Train.EqualReservoirPressurePSIorInHg);
                        break;
                    }
                case CABViewControlTypes.BRAKE_CYL:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.GetCylPressurePSI());
                        break;
                    }
                case CABViewControlTypes.VACUUM_RESERVOIR_PRESSURE:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.GetVacResPressurePSI());
                        break;
                    }
                case CABViewControlTypes.RPM:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = mstsDieselLocomotive.DieselEngines[0].RealRPM;
                        break;
                    }
                case CABViewControlTypes.ORTS_DIESEL_TEMPERATURE:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = mstsDieselLocomotive.DieselEngines[0].DieselTemperatureDeg;
                        break;
                    }
                case CABViewControlTypes.ORTS_OIL_PRESSURE:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = ConvertFromPSI(cvc, mstsDieselLocomotive.DieselEngines[0].DieselOilPressurePSI);
                        break;
                    }
                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                case CABViewControlTypes.CPH_DISPLAY:
                    {
                        data = Train.TrainType == Train.TRAINTYPE.AI_PLAYERHOSTING? ThrottlePercent / 100f : LocalThrottlePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.ENGINE_BRAKE:
                    {
                        data = (EngineBrakeController == null) ? 0.0f : EngineBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.TRAIN_BRAKE:
                    {
                        data = (TrainBrakeController == null) ? 0.0f : TrainBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.FRICTION_BRAKING:
                    {
                        data = (BrakeSystem == null) ? 0.0f : BrakeSystem.GetCylPressurePSI();
                        break;
                    }
                case CABViewControlTypes.DYNAMIC_BRAKE:
                case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                    //case CABViewControlTypes.CP_HANDLE:
                    {
                        data = DynamicBrakePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.WIPERS:
                    {
                        data = Wiper ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.HORN:
                    {
                        data = Horn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.BELL:
                    {
                        data = Bell ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.RESET:
                    {
                        if (TrainControlSystem.AlerterButtonPressed)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }

                case CABViewControlTypes.ALERTER_DISPLAY:
                    {
                        if (Simulator.Settings.Alerter)
                        {
                            if (TrainControlSystem.VigilanceEmergency)
                                data = 2;
                            else if (TrainControlSystem.VigilanceAlarm)
                                data = 1;
                            else
                                data = 0;
                        }
                        break;
                    }
                case CABViewControlTypes.OVERSPEED:
                    {
                        data = TrainControlSystem.OverspeedWarning ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.PENALTY_APP:
                    {
                        data = TrainControlSystem.PenaltyApplication ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.EMERGENCY_BRAKE:
                    {
                        data = EmergencyButtonPressed ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.DOORS_DISPLAY:
                    {
                        data = DoorLeftOpen | DoorRightOpen ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.SANDERS:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                // MultStateDisplay entry in CVF file had Type SANDING. W/O the below entry and another entry at line 3625
                // the independant sanding light found in some cabs would not work.
                case CABViewControlTypes.SANDING:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.CLOCK:
                    {
                        data = 0;
                        break;
                    }

                case CABViewControlTypes.FRONT_HLIGHT:
                    {
                        data = Headlight;
                        break;
                    }
                case CABViewControlTypes.WHEELSLIP:
                    {
                        if (AdvancedAdhesionModel && Train.TrainType != Train.TRAINTYPE.AI_PLAYERHOSTING)
                            data = LocomotiveAxle.IsWheelSlipWarning ? 1 : 0;
                        else
                            data = WheelSlip ? 1 : 0;
                        break;
                    }

                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                    {
                        if (Direction == Direction.Forward)
                            data = 2;
                        else if (Direction == Direction.Reverse)
                            data = 0;
                        else
                            data = 1;
                        break;
                    }
                case CABViewControlTypes.ASPECT_DISPLAY:
                    {
                        switch (TrainControlSystem.CabSignalAspect)
                        {
                            case TrackMonitorSignalAspect.Stop:
                                {
                                    data = 0;
                                    break;
                                }
                            case TrackMonitorSignalAspect.StopAndProceed:
                                {
                                    data = 1;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Restricted:
                                {
                                    data = 2;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach_1:
                                {
                                    data = 3;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach_2:
                                {
                                    data = 4;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach_3:
                                {
                                    data = 5;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Clear_1:
                                {
                                    data = 6;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Clear_2:
                                {
                                    data = 7;
                                    break;
                                }
                            default:
                                {
                                    data = 7;
                                    break;
                                }
                        }
                        break;
                    }
                case CABViewControlTypes.SPEEDLIMIT:
                    {
                        // Displays current allowable speed
                        bool metric = cvc.Units == CABViewControlUnits.KM_PER_HOUR;
                        data = MpS.FromMpS(TrainControlSystem.CurrentSpeedLimitMpS, metric);
                        break;
                    }
                case CABViewControlTypes.SPEEDLIM_DISPLAY:
                    {
                        // Displays allowable speed shown on next signal
                        bool metric = cvc.Units == CABViewControlUnits.KM_PER_HOUR;
                        data = MpS.FromMpS(TrainControlSystem.NextSpeedLimitMpS, metric);
                        break;
                    }
                case CABViewControlTypes.GEARS_DISPLAY:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            if (dieselLoco.DieselEngines.HasGearBox)
                                data = dieselLoco.DieselEngines[0].GearBox.CurrentGearIndex + 1;
                        }
                        break;
                    }
                case CABViewControlTypes.CAB_RADIO:
                    {
                        data = CabRadioOn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_PLAYER_DIESEL_ENGINE:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = (dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Running ||
                                dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Starting) ? 1 : 0;
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_HELPERS_DIESEL_ENGINES:
                    {
                        foreach (var car in Train.Cars)
                        {
                            var dieselLoco = car as MSTSDieselLocomotive;
                            if (dieselLoco != null && dieselLoco.AcceptMUSignals)
                            {
                                if (car == Simulator.PlayerLocomotive && dieselLoco.DieselEngines.Count > 1)
                                {
                                    data = (dieselLoco.DieselEngines[1].EngineStatus == DieselEngine.Status.Running ||
                                        dieselLoco.DieselEngines[1].EngineStatus == DieselEngine.Status.Starting) ? 1 : 0;
                                    break;
                                }
                                else if (car != Simulator.PlayerLocomotive)
                                {
                                    data = (dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Running ||
                                        dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Starting) ? 1 : 0;
                                    break;
                                }
                             }
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_PLAYER_DIESEL_ENGINE_STATE:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = (int)dieselLoco.DieselEngines[0].EngineStatus;
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_PLAYER_DIESEL_ENGINE_STARTER:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Starting ? 1 : 0;
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_PLAYER_DIESEL_ENGINE_STOPPER:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Stopping ? 1 : 0;
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_CABLIGHT:
                    data = CabLightOn ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_LEFTDOOR:
                    data = GetCabFlipped() ? (DoorRightOpen ? 1 : 0) : DoorLeftOpen ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_RIGHTDOOR:
                    data = GetCabFlipped() ? (DoorLeftOpen ? 1 : 0) : DoorRightOpen ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_MIRRORS:
                    data = MirrorOpen ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_HOURDIAL:
                    float hour = (float)(Simulator.ClockTime / 3600) % 12;
                    if (hour < 0)
                        hour += 12;
                    data = hour;
                    break;
                case CABViewControlTypes.ORTS_MINUTEDIAL:
                    float minute = (float)(Simulator.ClockTime / 60) % 60;
                    if (minute < 0)
                        minute += 60;
                    data = minute;
                    break;
                case CABViewControlTypes.ORTS_SECONDDIAL:
                    int seconds = (int)Simulator.ClockTime % 60;
                    if (seconds < 0)
                        seconds += 60;
                    data = seconds;
                    break;

                default:
                    {
                        data = 0;
                        break;
                    }
            }
            return data;
        }

        protected static float ConvertFromPSI(CabViewControl cvc, float data)
        {
            if (cvc.Units == CABViewControlUnits.BAR)
                data = Bar.FromPSI(data);
            else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                data = KPa.FromPSI(data);
            else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                data *= 70.307e-3f;
            else if (cvc.Units == CABViewControlUnits.INCHES_OF_MERCURY)
                data = Vac.FromPress(data);
            return data;
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual void RefillImmediately()
        {
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual MSTSNotchController GetRefillController(uint type)
        {
            return null;
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual void SetStepSize(PickupObj matchPickup)
        {
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public override float GetFilledFraction(uint pickupType)
        {
            return 0f;
        }

        public override void SwitchToPlayerControl()
        {
            base.SwitchToPlayerControl();
            return;
        }

        public override void SwitchToAutopilotControl()
        {
            base.SwitchToAutopilotControl();
            return;
        }

    } // End Class MSTSLocomotive

    public class CabView
    {
        public CabViewFile CVFFile;
        public List<ViewPoint> ViewPointList;
        public ExtendedCVF ExtendedCVF;
        public CabViewType CabViewType;
        public bool NoseAhead; // if cabview is not in front of engine; used to define how terrain tilts if there is freightanimation

        public CabView(CabViewFile cvfFile, List<ViewPoint> viewPointList, ExtendedCVF extendedCVF, CabViewType cabViewType, bool noseAhead)
        {
            CVFFile = cvfFile;
            ViewPointList = viewPointList;
            ExtendedCVF = extendedCVF;
            CabViewType = cabViewType;
            NoseAhead = noseAhead;
        }
    }

    public class CabView3D : CabView
    {
        public string ShapeFilePath;

        public CabView3D(CabViewFile cvfFile, List<PassengerViewPoint> cabViewpoints, ExtendedCVF extendedCVF, CabViewType cabViewType, bool noseAhead, string shapeFilePath)
            : base(cvfFile, new List<ViewPoint>(), extendedCVF, cabViewType, noseAhead)
        {
            ShapeFilePath = shapeFilePath;
            if (cabViewpoints != null)
                foreach (var point in cabViewpoints)
                    ViewPointList.Add(point);
        }

    }

    /// <summary>
    /// Extended CVF data, currently used for CAB light
    /// By GeorgeS
    /// </summary>
    [ORTSPhysicsFile("lit", "ORTSExtendedCVF")]
    public class ExtendedCVF
    {
        /// <summary>
        /// Translate to current screen resolution
        /// </summary>
        /// <param name="displaySize">Current screen resolution</param>
        /// <returns>Translated vectors</returns>
        public static Vector4 TranslatedPosition(Vector4 Position, Point displaySize)
        {
            return new Vector4(Position.X / 640 * displaySize.X,
                Position.Y / 480 * displaySize.Y,
                Position.Z / 640 * displaySize.X,
                Position.W);
        }

        /// <summary>
        /// Used by the shader
        /// </summary>
        public static Vector3 TranslatedColor(Color Color)
        {
            return new Vector3((float)Color.R / 255, (float)Color.G / 255, (float)Color.B / 255);
        }

        [ORTSPhysics("First light Position", "Light1Position", "The position and aspect of the first cab light", "320 360 155 2")]
        public Vector4 Light1Position;

        [ORTSPhysics("First light ARGB", "Light1ColorARGB", "The color of the first cab light", "255 216 178 255")]
        public Color Light1Color;

        [ORTSPhysics("Second light Position", "Light2Position", "The position and aspect of the first cab light", "0 0 0 0")]
        public Vector4 Light2Position;

        [ORTSPhysics("Second light ARGB", "Light2ColorARGB", "The color of the second cab light", "0 0 0")]
        public Color Light2Color;

    } // End Class ExtendedCVF 
}
