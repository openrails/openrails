// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using winmdroot = global::Windows.Win32;
[assembly: global::System.Reflection.AssemblyMetadata("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
namespace Windows.Win32
{

    /// <content>
    /// Contains extern methods from "KERNEL32.dll".
    /// </content>
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal static partial class PInvoke
    {
        /// <summary>Closes an open object handle.</summary>
        /// <param name="hObject">A valid handle to an open object.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para>The <b>CloseHandle</b> function closes handles to the following objects: </para>
        /// <para>This doc was truncated.</para>
        /// <para><see href="https://learn.microsoft.com/windows/win32/api/handleapi/nf-handleapi-closehandle#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern winmdroot.Foundation.BOOL CloseHandle(winmdroot.Foundation.HANDLE hObject);
    }


    /// <content>
    /// Contains extern methods from "USER32.dll".
    /// </content>
    internal static partial class PInvoke
    {
        /// <summary>Changes the parent window of the specified child window.</summary>
        /// <param name="hWndChild">
        /// <para>Type: <b>HWND</b> A handle to the child window.</para>
        /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setparent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name="hWndNewParent">
        /// <para>Type: <b>HWND</b> A handle to the new parent window. If this parameter is <b>NULL</b>, the desktop window becomes the new parent window. If this parameter is <b>HWND_MESSAGE</b>, the child window becomes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>.</para>
        /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setparent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b> If the function succeeds, the return value is a handle to the previous parent window. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para>An application can use the <b>SetParent</b> function to set the parent window of a pop-up, overlapped, or child window. If the window identified by the <i>hWndChild</i> parameter is visible, the system performs the appropriate redrawing and repainting. For compatibility reasons, <b>SetParent</b> does not modify the <b>WS_CHILD</b> or <b>WS_POPUP</b> window styles of the window whose parent is being changed. Therefore, if <i>hWndNewParent</i> is <b>NULL</b>, you should also clear the <b>WS_CHILD</b> bit and set the <b>WS_POPUP</b> style after calling <b>SetParent</b>. Conversely, if <i>hWndNewParent</i> is not <b>NULL</b> and the window was previously a child of the desktop, you should clear the <b>WS_POPUP</b> style and set the <b>WS_CHILD</b> style before calling <b>SetParent</b>. When you change the parent of a window, you should synchronize the UISTATE of both windows. For more information, see <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-changeuistate">WM_CHANGEUISTATE</a> and <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-updateuistate">WM_UPDATEUISTATE</a>. Unexpected behavior or errors may occur if <i>hWndNewParent</i> and <i>hWndChild</i> are running in different DPI awareness modes. The table below outlines this behavior: </para>
        /// <para>This doc was truncated.</para>
        /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setparent#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern winmdroot.Foundation.HWND SetParent(winmdroot.Foundation.HWND hWndChild, winmdroot.Foundation.HWND hWndNewParent);

        /// <summary>Changes an attribute of the specified window. The function also sets the 32-bit (long) value at the specified offset into the extra window memory. (Unicode)</summary>
        /// <param name="hWnd">
        /// <para>Type: <b>HWND</b> A handle to the window and, indirectly, the class to which the window belongs.</para>
        /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name="nIndex">Type: <b>int</b></param>
        /// <param name="dwNewLong">
        /// <para>Type: <b>LONG</b> The replacement value.</para>
        /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b> If the function succeeds, the return value is the previous value of the specified 32-bit integer. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the previous value of the specified 32-bit integer is zero, and the function succeeds, the return value is zero, but the function does not clear the last error information. This makes it difficult to determine success or failure. To deal with this, you should clear the last error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0 before calling <b>SetWindowLong</b>. Then, function failure will be indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.</para>
        /// </returns>
        /// <remarks>
        /// <para>Certain window data is cached, so changes you make using <b>SetWindowLong</b> will not take effect until you call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowpos">SetWindowPos</a> function. Specifically, if you change any of the frame styles, you must call <b>SetWindowPos</b> with the <b>SWP_FRAMECHANGED</b> flag for the cache to be updated properly. If you use <b>SetWindowLong</b> with the <b>GWL_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. If you use <b>SetWindowLong</b> with the <b>DWL_MSGRESULT</b> index to set the return value for a message processed by a dialog procedure, you should return <b>TRUE</b> directly afterward. Otherwise, if you call any function that results in your dialog procedure receiving a window message, the nested window message could overwrite the return value you set using <b>DWL_MSGRESULT</b>. Calling <b>SetWindowLong</b> with the <b>GWL_WNDPROC</b> index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The <b>SetWindowLong</b> function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a>. This allows the application to create a chain of window procedures. Reserve extra window memory by specifying a nonzero value in the <b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. You must not call <b>SetWindowLong</b> with the <b>GWL_HWNDPARENT</b> index to change the parent of a child window. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setparent">SetParent</a> function. If the window has a class style of <b>CS_CLASSDC</b> or <b>CS_OWNDC</b>, do not set the extended window styles <b>WS_EX_COMPOSITED</b> or <b>WS_EX_LAYERED</b>. Calling <b>SetWindowLong</b> to set the style on a progressbar will reset its position.</para>
        /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongw#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "SetWindowLongW", SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern int SetWindowLong(winmdroot.Foundation.HWND hWnd, winmdroot.UI.WindowsAndMessaging.WINDOW_LONG_PTR_INDEX nIndex, int dwNewLong);
    }

    namespace Foundation
    {
        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
        internal readonly partial struct BOOL
            : IEquatable<BOOL>
        {
            internal readonly int Value;

            internal BOOL(int value) => this.Value = value;

            public static implicit operator int(BOOL value) => value.Value;

            public static explicit operator BOOL(int value) => new BOOL(value);

            public static bool operator ==(BOOL left, BOOL right) => left.Value == right.Value;

            public static bool operator !=(BOOL left, BOOL right) => !(left == right);

            public bool Equals(BOOL other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is BOOL other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();

            public override string ToString() => $"0x{this.Value:x}";

            internal BOOL(bool value) => this.Value = value ? 1 : 0;

            public static implicit operator bool(BOOL value) => value.Value != 0;

            public static implicit operator BOOL(bool value) => new BOOL(value);
        }

        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
        internal readonly partial struct HANDLE
            : IEquatable<HANDLE>
        {
            internal readonly IntPtr Value;

            internal HANDLE(IntPtr value) => this.Value = value;

            internal static HANDLE Null => default;

            internal bool IsNull => Value == default;

            public static implicit operator IntPtr(HANDLE value) => value.Value;

            public static explicit operator HANDLE(IntPtr value) => new HANDLE(value);

            public static bool operator ==(HANDLE left, HANDLE right) => left.Value == right.Value;

            public static bool operator !=(HANDLE left, HANDLE right) => !(left == right);

            public bool Equals(HANDLE other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is HANDLE other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();

            public override string ToString() => $"0x{this.Value:x}";
        }

        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
        internal readonly partial struct HWND
            : IEquatable<HWND>
        {
            internal readonly IntPtr Value;

            internal HWND(IntPtr value) => this.Value = value;

            internal static HWND Null => default;

            internal bool IsNull => Value == default;

            public static implicit operator IntPtr(HWND value) => value.Value;

            public static explicit operator HWND(IntPtr value) => new HWND(value);

            public static bool operator ==(HWND left, HWND right) => left.Value == right.Value;

            public static bool operator !=(HWND left, HWND right) => !(left == right);

            public bool Equals(HWND other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is HWND other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();

            public override string ToString() => $"0x{this.Value:x}";

            public static implicit operator HANDLE(HWND value) => new HANDLE(value.Value);
        }
    }

    namespace UI.WindowsAndMessaging
    {
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
        internal enum WINDOW_LONG_PTR_INDEX
        {
            GWL_EXSTYLE = -20,
            GWLP_HINSTANCE = -6,
            GWLP_HWNDPARENT = -8,
            GWLP_ID = -12,
            GWL_STYLE = -16,
            GWLP_USERDATA = -21,
            GWLP_WNDPROC = -4,
            GWL_HINSTANCE = -6,
            GWL_ID = -12,
            GWL_USERDATA = -21,
            GWL_WNDPROC = -4,
            GWL_HWNDPARENT = -8,
        }

        [Flags]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
        internal enum WINDOW_STYLE : uint
        {
            WS_OVERLAPPED = 0x00000000,
            WS_POPUP = 0x80000000,
            WS_CHILD = 0x40000000,
            WS_MINIMIZE = 0x20000000,
            WS_VISIBLE = 0x10000000,
            WS_DISABLED = 0x08000000,
            WS_CLIPSIBLINGS = 0x04000000,
            WS_CLIPCHILDREN = 0x02000000,
            WS_MAXIMIZE = 0x01000000,
            WS_CAPTION = 0x00C00000,
            WS_BORDER = 0x00800000,
            WS_DLGFRAME = 0x00400000,
            WS_VSCROLL = 0x00200000,
            WS_HSCROLL = 0x00100000,
            WS_SYSMENU = 0x00080000,
            WS_THICKFRAME = 0x00040000,
            WS_GROUP = 0x00020000,
            WS_TABSTOP = 0x00010000,
            WS_MINIMIZEBOX = 0x00020000,
            WS_MAXIMIZEBOX = 0x00010000,
            WS_TILED = 0x00000000,
            WS_ICONIC = 0x20000000,
            WS_SIZEBOX = 0x00040000,
            WS_TILEDWINDOW = 0x00CF0000,
            WS_OVERLAPPEDWINDOW = 0x00CF0000,
            WS_POPUPWINDOW = 0x80880000,
            WS_CHILDWINDOW = 0x40000000,
            WS_ACTIVECAPTION = 0x00000001,
        }
    }
}
